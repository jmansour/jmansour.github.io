{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Underworld 2 is a python-friendly version of the Underworld code which provides a programmable and flexible front end to all the functionality of the code running in a parallel HPC environment. This gives signficant advantages to the user, with access to the power of python libraries for setup of complex problems, analysis at runtime, problem steering, and multi physics coupling. While Underworld2 embraces Jupyter Notebooks as the preferred modelling environment, only standard python is required. The Underworld2 development team is based in Melbourne, Australia at the University of Melbourne and at Monash University led by Louis Moresi. We would like to acknowledge AuScope Simulation, Analysis and Modelling for providing long term funding which has made the project possible. Additional funding for specific improvements and additional functionality has come from the Australian Research Council (http://www.arc.gov.au). The python toolkit was funded by the NeCTAR eresearch_tools program. Underworld was originally developed in collaboration with the Victorian Partnership for Advanced Computing. Version Status Lastest stable release (master branch) Development branch Underworld Installation (docker) If you decide to run this tutorial on your own machine and want to build new examples, you can most easily install underworld from the docker container. Most new users may wish to use the Kitematic GUI to download and run Underworld. Simply search for 'underworldcode/underworld2' within Kitematic, and then click 'CREATE' to launch a container. You will eventually wish to modify your container settings (again through Kitematic) to enable local folder volume mapping, which will allow you to access your local drives within your container. For Linux users, and those who prefer the command line, the following minimal command should be sufficient to access the Underworld2 Jupyter Notebook examples: docker run --rm -p 8888:8888 underworldcode/underworld2 Navigate to localhost:8888 to see the notebooks. Underworld Installation (native) For installation on HPC facilities and if you would like a local build, you will need to download, install and compile the Underworld code and the relevant dependencies. A native build can be difficult in a non-standard environment and we are currently working on HPC deployments of containers. For information on how to build, look on the underworld github pages under docs/install_guides and also see the Underworld blog pages Privacy Note that basic usage metrics are dispatched when you use Underworld. We do this to help assess the usage of our code which is important in justifying our funding. To opt out, set the UW_NO_USAGE_METRICS environment variable. See PRIVACY.md for full details. In the docker environment, we only collect information that the docker version has been run. Bedtime reading These papers explain the theory and implementation for Underworld. The code itself can also be cited via the zenodo DOI. There is a master DOI for all releases and releases after 2.6.0 are automatically given a DOI under the master. If you are using a development branch and wish to obtain a DOI for your specific version we ask that you contact us to make an interim release under the master DOI. Moresi, L., Dufour, F., and Muhlhaus, H.B., 2002, Mantle convection modeling with viscoelastic/brittle lithosphere: Numerical methodology and plate tectonic modeling: Pure And Applied Geophysics, v. 159, no. 10, p. 2335\u20132356, doi: 10.1007/s00024-002-8738-3. Moresi, L., Dufour, F., and Muhlhaus, H.B., 2003, A Lagrangian integration point finite element method for large deformation modeling of viscoelastic geomaterials: Journal of Computational Physics, v. 184, no. 2, p. 476\u2013497. Moresi, L., Quenette, S., Lemiale, V., M\u00e9riaux, C., Appelbe, W., M\u00fchlhaus, 2007, Computational approaches to studying non-linear dynamics of the crust and mantle: Phys. Earth Planet. Inter, v. 163, p. 69\u201382, doi: 10.1016/j.pepi.2007.06.009.","title":"Home"},{"location":"index.html#underworld-installation-docker","text":"If you decide to run this tutorial on your own machine and want to build new examples, you can most easily install underworld from the docker container. Most new users may wish to use the Kitematic GUI to download and run Underworld. Simply search for 'underworldcode/underworld2' within Kitematic, and then click 'CREATE' to launch a container. You will eventually wish to modify your container settings (again through Kitematic) to enable local folder volume mapping, which will allow you to access your local drives within your container. For Linux users, and those who prefer the command line, the following minimal command should be sufficient to access the Underworld2 Jupyter Notebook examples: docker run --rm -p 8888:8888 underworldcode/underworld2 Navigate to localhost:8888 to see the notebooks.","title":"Underworld Installation (docker)"},{"location":"index.html#underworld-installation-native","text":"For installation on HPC facilities and if you would like a local build, you will need to download, install and compile the Underworld code and the relevant dependencies. A native build can be difficult in a non-standard environment and we are currently working on HPC deployments of containers. For information on how to build, look on the underworld github pages under docs/install_guides and also see the Underworld blog pages","title":"Underworld Installation (native)"},{"location":"index.html#privacy","text":"Note that basic usage metrics are dispatched when you use Underworld. We do this to help assess the usage of our code which is important in justifying our funding. To opt out, set the UW_NO_USAGE_METRICS environment variable. See PRIVACY.md for full details. In the docker environment, we only collect information that the docker version has been run.","title":"Privacy"},{"location":"index.html#bedtime-reading","text":"These papers explain the theory and implementation for Underworld. The code itself can also be cited via the zenodo DOI. There is a master DOI for all releases and releases after 2.6.0 are automatically given a DOI under the master. If you are using a development branch and wish to obtain a DOI for your specific version we ask that you contact us to make an interim release under the master DOI. Moresi, L., Dufour, F., and Muhlhaus, H.B., 2002, Mantle convection modeling with viscoelastic/brittle lithosphere: Numerical methodology and plate tectonic modeling: Pure And Applied Geophysics, v. 159, no. 10, p. 2335\u20132356, doi: 10.1007/s00024-002-8738-3. Moresi, L., Dufour, F., and Muhlhaus, H.B., 2003, A Lagrangian integration point finite element method for large deformation modeling of viscoelastic geomaterials: Journal of Computational Physics, v. 184, no. 2, p. 476\u2013497. Moresi, L., Quenette, S., Lemiale, V., M\u00e9riaux, C., Appelbe, W., M\u00fchlhaus, 2007, Computational approaches to studying non-linear dynamics of the crust and mantle: Phys. Earth Planet. Inter, v. 163, p. 69\u201382, doi: 10.1016/j.pepi.2007.06.009.","title":"Bedtime reading"},{"location":"Geodynamics.html","text":"Geodynamics - mathematical background The simplest template set of equations for solid-Earth dynamics cover mass, momentum and heat conservation in a highly viscous fluid allowing for additional effects due to elasticity and plasticity. The Stokes momentum equation neglects inertia but includes an additional term on the right hand side that represents stress history associated with an explicit treatment of viscoelasticity. 1 2 3 \\begin{equation} \\tau_{ij,j} - p_{,i} = \\rho\\left( T, C, \\cdots \\right) - \\tau^{\\delta t}_{ij,j} \\label{eq:stokes-momentum} \\end{equation} \\begin{equation} \\tau_{ij,j} - p_{,i} = \\rho\\left( T, C, \\cdots \\right) - \\tau^{\\delta t}_{ij,j} \\label{eq:stokes-momentum} \\end{equation} $ \\tau $ is the deviatoric stress, p p represents the pressure, \\rho \\rho is density, T T is the temperature, C C is a concentration intended to represent changes in composition. At pressures in planetary interiors, silicate minerals are weakly compressible and this is generally considered as a perturbation to an incompressible flow ignoring bulk viscosity and only considering the long-term elastic resistance to volume change. For the purposes of explaining the formulation, the incompressible constraint equation on the velocity, u u is sufficient. \\begin{equation} u_{i,i} = 0 \\label{eq:stokes-incompressibility} \\end{equation} \\begin{equation} u_{i,i} = 0 \\label{eq:stokes-incompressibility} \\end{equation} The thermal evolution of the system expresses the balance between heat transport by fluid motion, thermal diffusion and internal heat generation. Additional terms can be included to account for heating due to viscous dissipation, for example, but do not change the overall character of the conservation equation. \\begin{equation} T_{,t} - u_i T_{,i} = \\left(\\kappa T_{,i} \\right)_{,i} + Q_T \\label{eq:adv-diffusion-thermal} \\end{equation} \\begin{equation} T_{,t} - u_i T_{,i} = \\left(\\kappa T_{,i} \\right)_{,i} + Q_T \\label{eq:adv-diffusion-thermal} \\end{equation} The most significant feature of this system is the spontaneous appearance of boundary layers where horizontal advection and vertical diffusion are approximately balanced. By contrast, compositional variations are characterised by a much smaller, usually negligible, rate of diffusion: \\begin{equation} C_{,t} - u_i C_{,i} = Q_C \\label{eq:adv-compositional} \\end{equation} \\begin{equation} C_{,t} - u_i C_{,i} = Q_C \\label{eq:adv-compositional} \\end{equation} The thermal and compositional variations couple to the momentum equation through their effect on density. The Boussinesq approximation \\citep{bous:1903}, accounts for the buoyancy forces while neglecting the associated volume change allowing us to assume incompressibility. If the non-diffusive, compositional variation represents a smoothly varying concentration, then the density can be written as 4 \\begin{equation} \\rho = \\rho_0 (1-\\alpha \\Delta T) (1-\\alpha_C \\Delta C) \\end{equation} \\begin{equation} \\rho = \\rho_0 (1-\\alpha \\Delta T) (1-\\alpha_C \\Delta C) \\end{equation} In the case where C represents a state with discrete steps (e.g. a phase change or immiscible fluids), it is common to let \\rho_0 \\rho_0 take discrete values and assume \\alpha_C=0 \\alpha_C=0 . The final requirement is a constitutive relationship for \\ref{eq:stokes-momentum} that links the stress to the velocity unknown. Rheology is one of the defining aspects of the dynamics of the mantle, particularly in the cooler parts of the upper boundary layer where elasticity, non-linearity, and brittle behaviour plays a significant role. A general constitutive law can be expressed as: \\begin{equation} \\frac{\\dot{\\tau}_{ij} }{\\mu} + \\frac{\\tau_{ij}}{\\eta} + \\lambda \\Lambda_{ijkl} \\tau_{kl} = \\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i} \\label{eq:viscoelasticplastic-const-law} \\end{equation} \\begin{equation} \\frac{\\dot{\\tau}_{ij} }{\\mu} + \\frac{\\tau_{ij}}{\\eta} + \\lambda \\Lambda_{ijkl} \\tau_{kl} = \\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i} \\label{eq:viscoelasticplastic-const-law} \\end{equation} where \\mu \\mu is the elastic shear modulus and \\eta \\eta is the shear viscosity (both of which may vary with temperature and composition). \\Lambda \\Lambda is a structural tensor that represents the orientation of the plastic deformation relative to the applied stress and \\lambda \\lambda is a scalar multiplier that is computed to satisfy the stress conditions at yield 5 . Typically, \\eta \\eta varies by several tens of orders of magnitude over the typical temperature ranges expected between the Earth's surface and interior. The orientation tensor and the yield stress are usually modelled to include a simple damage evolution that relates to the work expended in deforming the material at yield. Moresi, L. N., F. Dufour, and H. B. Muhlhaus (2002), Mantle convection modeling with viscoelastic/brittle lithosphere: Numerical methodology and plate tectonic modeling, Pure And Applied Geophysics, 159(10), 2335\u20132356, doi:10.1007/s00024-002-8738-3. \u21a9 Moresi, L. N., F. Dufour, and H. B. Muhlhaus (2003), A Lagrangian integration point finite element method for large deformation modeling of viscoelastic geomaterials, Journal of Computational Physics, 184(2), 476\u2013497, doi:10.1016/S0021-9991(02)00031-1. \u21a9 Farrington, R. J., L. N. Moresi, and F. A. Capitanio (2014), The role of viscoelasticity in subducting plates, Geochemistry, Geophysics, Geosystems, 15(11), 4291\u20134304, doi:10.1002/2014GC005507. \u21a9 van Keken, P. E., S. D. King, H. Schmeling, U. R. Christensen, D. Neumeister, and M. P. Doin (1997), A comparison of methods for the modeling of thermochemical convection, J. Geophys. Res., 102(B10), 22,477\u201322,495. \u21a9 L. Moresi, H. B. Muhlhaus, V. Lemiale, and D. A. May (2007), Incompressible viscous formulations for deformation and yielding of the lithosphere, Geological Society London Special Publications, 282(1), 457\u2013472, doi:10.1144/SP282.19. \u21a9","title":"Geodynamics"},{"location":"Geodynamics.html#geodynamics-mathematical-background","text":"The simplest template set of equations for solid-Earth dynamics cover mass, momentum and heat conservation in a highly viscous fluid allowing for additional effects due to elasticity and plasticity. The Stokes momentum equation neglects inertia but includes an additional term on the right hand side that represents stress history associated with an explicit treatment of viscoelasticity. 1 2 3 \\begin{equation} \\tau_{ij,j} - p_{,i} = \\rho\\left( T, C, \\cdots \\right) - \\tau^{\\delta t}_{ij,j} \\label{eq:stokes-momentum} \\end{equation} \\begin{equation} \\tau_{ij,j} - p_{,i} = \\rho\\left( T, C, \\cdots \\right) - \\tau^{\\delta t}_{ij,j} \\label{eq:stokes-momentum} \\end{equation} $ \\tau $ is the deviatoric stress, p p represents the pressure, \\rho \\rho is density, T T is the temperature, C C is a concentration intended to represent changes in composition. At pressures in planetary interiors, silicate minerals are weakly compressible and this is generally considered as a perturbation to an incompressible flow ignoring bulk viscosity and only considering the long-term elastic resistance to volume change. For the purposes of explaining the formulation, the incompressible constraint equation on the velocity, u u is sufficient. \\begin{equation} u_{i,i} = 0 \\label{eq:stokes-incompressibility} \\end{equation} \\begin{equation} u_{i,i} = 0 \\label{eq:stokes-incompressibility} \\end{equation} The thermal evolution of the system expresses the balance between heat transport by fluid motion, thermal diffusion and internal heat generation. Additional terms can be included to account for heating due to viscous dissipation, for example, but do not change the overall character of the conservation equation. \\begin{equation} T_{,t} - u_i T_{,i} = \\left(\\kappa T_{,i} \\right)_{,i} + Q_T \\label{eq:adv-diffusion-thermal} \\end{equation} \\begin{equation} T_{,t} - u_i T_{,i} = \\left(\\kappa T_{,i} \\right)_{,i} + Q_T \\label{eq:adv-diffusion-thermal} \\end{equation} The most significant feature of this system is the spontaneous appearance of boundary layers where horizontal advection and vertical diffusion are approximately balanced. By contrast, compositional variations are characterised by a much smaller, usually negligible, rate of diffusion: \\begin{equation} C_{,t} - u_i C_{,i} = Q_C \\label{eq:adv-compositional} \\end{equation} \\begin{equation} C_{,t} - u_i C_{,i} = Q_C \\label{eq:adv-compositional} \\end{equation} The thermal and compositional variations couple to the momentum equation through their effect on density. The Boussinesq approximation \\citep{bous:1903}, accounts for the buoyancy forces while neglecting the associated volume change allowing us to assume incompressibility. If the non-diffusive, compositional variation represents a smoothly varying concentration, then the density can be written as 4 \\begin{equation} \\rho = \\rho_0 (1-\\alpha \\Delta T) (1-\\alpha_C \\Delta C) \\end{equation} \\begin{equation} \\rho = \\rho_0 (1-\\alpha \\Delta T) (1-\\alpha_C \\Delta C) \\end{equation} In the case where C represents a state with discrete steps (e.g. a phase change or immiscible fluids), it is common to let \\rho_0 \\rho_0 take discrete values and assume \\alpha_C=0 \\alpha_C=0 . The final requirement is a constitutive relationship for \\ref{eq:stokes-momentum} that links the stress to the velocity unknown. Rheology is one of the defining aspects of the dynamics of the mantle, particularly in the cooler parts of the upper boundary layer where elasticity, non-linearity, and brittle behaviour plays a significant role. A general constitutive law can be expressed as: \\begin{equation} \\frac{\\dot{\\tau}_{ij} }{\\mu} + \\frac{\\tau_{ij}}{\\eta} + \\lambda \\Lambda_{ijkl} \\tau_{kl} = \\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i} \\label{eq:viscoelasticplastic-const-law} \\end{equation} \\begin{equation} \\frac{\\dot{\\tau}_{ij} }{\\mu} + \\frac{\\tau_{ij}}{\\eta} + \\lambda \\Lambda_{ijkl} \\tau_{kl} = \\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i} \\label{eq:viscoelasticplastic-const-law} \\end{equation} where \\mu \\mu is the elastic shear modulus and \\eta \\eta is the shear viscosity (both of which may vary with temperature and composition). \\Lambda \\Lambda is a structural tensor that represents the orientation of the plastic deformation relative to the applied stress and \\lambda \\lambda is a scalar multiplier that is computed to satisfy the stress conditions at yield 5 . Typically, \\eta \\eta varies by several tens of orders of magnitude over the typical temperature ranges expected between the Earth's surface and interior. The orientation tensor and the yield stress are usually modelled to include a simple damage evolution that relates to the work expended in deforming the material at yield. Moresi, L. N., F. Dufour, and H. B. Muhlhaus (2002), Mantle convection modeling with viscoelastic/brittle lithosphere: Numerical methodology and plate tectonic modeling, Pure And Applied Geophysics, 159(10), 2335\u20132356, doi:10.1007/s00024-002-8738-3. \u21a9 Moresi, L. N., F. Dufour, and H. B. Muhlhaus (2003), A Lagrangian integration point finite element method for large deformation modeling of viscoelastic geomaterials, Journal of Computational Physics, 184(2), 476\u2013497, doi:10.1016/S0021-9991(02)00031-1. \u21a9 Farrington, R. J., L. N. Moresi, and F. A. Capitanio (2014), The role of viscoelasticity in subducting plates, Geochemistry, Geophysics, Geosystems, 15(11), 4291\u20134304, doi:10.1002/2014GC005507. \u21a9 van Keken, P. E., S. D. King, H. Schmeling, U. R. Christensen, D. Neumeister, and M. P. Doin (1997), A comparison of methods for the modeling of thermochemical convection, J. Geophys. Res., 102(B10), 22,477\u201322,495. \u21a9 L. Moresi, H. B. Muhlhaus, V. Lemiale, and D. A. May (2007), Incompressible viscous formulations for deformation and yielding of the lithosphere, Geological Society London Special Publications, 282(1), 457\u2013472, doi:10.1144/SP282.19. \u21a9","title":"Geodynamics - mathematical background"},{"location":"Numerics.html","text":"Numerical methods - background Description Underworld is a Lagrangian integration point finite element code. This is a modernization of the original particle-in-cell concept from the 1960s in which a structured mesh and an unstructured particle swarm co-exist. The mesh is used to solve diffusion-dominated parts of the problem and the particle swarm is used to track advected quantities. In the finite element context, the mapping from mesh to particles is through the usual basis functions of the elements and the mapping from particles to mesh is through the integration scheme used to build up the stiffness matrices etc. The applications of the method are mainly in modelling of complex fluids where very large strains occur but the material also has a memory of the entire strain / strain-rate history. In geosciences this occurs due to the visco-elasticity of rocks at lithospheric temperature and their tendency to develop fabric (lattice preferred orientation and stress/strain-dependent grain size). Problems with material interfaces which undergo severe distortion during the deformation are also naturally handled by this method provided there is no slip on the interface. Background The method has been published in detail in Moresi et al (2002, 2003) 1 . These papers dealt exclusively with 2D applications but in recent years, we have introduced a number of improvements in the method to enable us to scale the problem to 3D. For example we developed a fast discrete Voronoi method to compute the integration weights of the particle-to-mesh mapping efficiently 2 . We have also concentrated on extremely robust solvers / preconditioners which are necessary because the material variations and geometrical complexity are both large and unpredictable at the start of the simulation. The benefit of this approach is associated with the separation of the computational mesh from the swarm of points which track the history. This allows us to retain a much more structured computational mesh than the deformation / material history would otherwise allow. We can take full advantage of the most efficient geometrical multigrid solvers and there is no need to preserve structure during any remeshing operations we undertake (for example if we do need to track a free surface or an internal interface). Although there are several complexities introduced by enforcing this separation, we find that the benefits, for our particular class of problems, are significant. Implementation and parallelism Underworld is implemented using the StGermain framework . This provides the essential infrastructure to manage i/o, meshes, particle swarms, finite element operations, in a parallel (domain decomposition, message passing) environment. The numerical solvers are based around the PETSc software suite which focuses on delivering good parallel scalability (up to thousands-of-cores). Our experience to date shows good scalability for thermal problems to 10000+ cores. Moresi, L. N., F. Dufour, and H. B. Muhlhaus (2003), A Lagrangian integration point finite element method for large deformation modeling of viscoelastic geomaterials, Journal of Computational Physics, 184(2), 476\u2013497, doi:10.1016/S0021-9991(02)00031-1. L. Moresi, F. Dufour, and H. B. Muhlhaus. A Lagrangian integration point finite element method for large deformation modeling of viscoelastic geomaterials. Journal Of Computational Physics, 184:476\u2013497, 2003. \u21a9 Veli\u0107, M., D. A. May, and L. N. Moresi (2009), A fast robust algorithm for computing discrete voronoi diagrams, Journal of Mathematical Modelling and \u2026, doi:10.1007/s10852-008-9097-6. \u21a9","title":"Numerical Methods"},{"location":"Numerics.html#numerical-methods-background","text":"","title":"Numerical methods - background"},{"location":"Numerics.html#description","text":"Underworld is a Lagrangian integration point finite element code. This is a modernization of the original particle-in-cell concept from the 1960s in which a structured mesh and an unstructured particle swarm co-exist. The mesh is used to solve diffusion-dominated parts of the problem and the particle swarm is used to track advected quantities. In the finite element context, the mapping from mesh to particles is through the usual basis functions of the elements and the mapping from particles to mesh is through the integration scheme used to build up the stiffness matrices etc. The applications of the method are mainly in modelling of complex fluids where very large strains occur but the material also has a memory of the entire strain / strain-rate history. In geosciences this occurs due to the visco-elasticity of rocks at lithospheric temperature and their tendency to develop fabric (lattice preferred orientation and stress/strain-dependent grain size). Problems with material interfaces which undergo severe distortion during the deformation are also naturally handled by this method provided there is no slip on the interface.","title":"Description"},{"location":"Numerics.html#background","text":"The method has been published in detail in Moresi et al (2002, 2003) 1 . These papers dealt exclusively with 2D applications but in recent years, we have introduced a number of improvements in the method to enable us to scale the problem to 3D. For example we developed a fast discrete Voronoi method to compute the integration weights of the particle-to-mesh mapping efficiently 2 . We have also concentrated on extremely robust solvers / preconditioners which are necessary because the material variations and geometrical complexity are both large and unpredictable at the start of the simulation. The benefit of this approach is associated with the separation of the computational mesh from the swarm of points which track the history. This allows us to retain a much more structured computational mesh than the deformation / material history would otherwise allow. We can take full advantage of the most efficient geometrical multigrid solvers and there is no need to preserve structure during any remeshing operations we undertake (for example if we do need to track a free surface or an internal interface). Although there are several complexities introduced by enforcing this separation, we find that the benefits, for our particular class of problems, are significant.","title":"Background"},{"location":"Numerics.html#implementation-and-parallelism","text":"Underworld is implemented using the StGermain framework . This provides the essential infrastructure to manage i/o, meshes, particle swarms, finite element operations, in a parallel (domain decomposition, message passing) environment. The numerical solvers are based around the PETSc software suite which focuses on delivering good parallel scalability (up to thousands-of-cores). Our experience to date shows good scalability for thermal problems to 10000+ cores. Moresi, L. N., F. Dufour, and H. B. Muhlhaus (2003), A Lagrangian integration point finite element method for large deformation modeling of viscoelastic geomaterials, Journal of Computational Physics, 184(2), 476\u2013497, doi:10.1016/S0021-9991(02)00031-1. L. Moresi, F. Dufour, and H. B. Muhlhaus. A Lagrangian integration point finite element method for large deformation modeling of viscoelastic geomaterials. Journal Of Computational Physics, 184:476\u2013497, 2003. \u21a9 Veli\u0107, M., D. A. May, and L. N. Moresi (2009), A fast robust algorithm for computing discrete voronoi diagrams, Journal of Mathematical Modelling and \u2026, doi:10.1007/s10852-008-9097-6. \u21a9","title":"Implementation and parallelism"},{"location":"Practice.html","text":"Practical matters This is a placeholder: how to run the code, what to consider in parallel what a notebook is and how to convert it Some pointers to other resources.","title":"Practical Matters"},{"location":"Practice.html#practical-matters","text":"This is a placeholder: how to run the code, what to consider in parallel what a notebook is and how to convert it Some pointers to other resources.","title":"Practical matters"},{"location":"UserGuide/01_GettingStarted.html","text":"Getting started Keywords: import, IPython notebooks Welcome to using Underworld! Underworld 2 provides a Python user interface to the Underworld code providing a programmable and flexible front end to the code running in a parallel HPC environment. This gives signficant advantages to the user, allowing them to leverage third party Python libraries for model configuration, analysis at runtime, coupling of multiple physics, etc. The Python interface was partly funded by the NeCTAR eResearch_tools program. The Python interface allows users to make use of Jupyter notebooks. This allows for an interactive approach to the development and analysis of models. Documentation Underworld documentation is broken down into: examples : These notebooks go through the entire workflow for geophysics type problems. user guide : A more focused look at particular aspects of Underworld (e.g. swarm particles). publications : Notebooks which replicate models and results from the literature. docstrings : The Underworld API includes Python docstring type documentation. Underworld requires basic knowledge of Python; constructs such as lists, tuples, modules, for-loops, printing and simple functions. This guide covers the basics of how to load modules for Underworld and how to use Jupyter notebooks. A short overview of a typical Underworld model with plots is given at the end of this guide. The purpose of the user guide is to give users a more detailed understanding of the various aspects of modelling with Underworld. For those interested in getting moving as quickly as possible, the examples are perhaps a better place to start. Underworld objects utilise Python docstrings to provide documentation inline. You may access this documentation directly by using the native Python help() function. Quick help information in the form of a pop-up window can be obtained by using a question mark after the object within IPython/Jupyter notebooks; e.g. uw? . Notebooks If you are new to the Jupyter Notebook, you may wish to familiarise yourself with the notebook environment first. There are many useful examples available online. Also, when using the notebook interactively, the Help menu bar option provides handy references. Installation This guide assumes that you have already installed Underworld. Details on how to install Underworld may be found at the project github page: https://github.com/underworldcode/underworld2 How to get help If you encounter issues or suspect a bug, please create a ticket using the issue tracker on github . Importing Run the following cell (either the run button on the menu above or press shift+enter ) to load the Underworld module: import underworld as uw A quick demo Let's do a quick run through of setting up some basic Underworld objects. # First, create a mesh: mesh = uw.mesh.FeMesh_Cartesian( elementType = (\"Q1\"), elementRes = (8, 8), minCoord = (0., 0.), maxCoord = (2., 1.)) # Next we create a mesh variable: temperatureField = mesh.add_variable( nodeDofCount=1 ) # Let's initialise the variable with some data: for index, coord in enumerate(mesh.data): temperatureField.data[index] = coord[1] # set the temperature to be the vertical (y) coordinate # Finally we will plot the temperature field using ``gLucifer`` after importing the gLucifer module. import glucifer fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Surface(mesh, temperatureField, colours=\"blue white red\") ) fig.append( glucifer.objects.Mesh(mesh) ) fig.show() Typically we might then setup boundary conditions, particle swarms, rheology and systems to be solved. All of these topics are discussed in the following sections of the user guide.","title":"Getting Started"},{"location":"UserGuide/01_GettingStarted.html#getting-started","text":"Keywords: import, IPython notebooks","title":"Getting started"},{"location":"UserGuide/01_GettingStarted.html#welcome-to-using-underworld","text":"Underworld 2 provides a Python user interface to the Underworld code providing a programmable and flexible front end to the code running in a parallel HPC environment. This gives signficant advantages to the user, allowing them to leverage third party Python libraries for model configuration, analysis at runtime, coupling of multiple physics, etc. The Python interface was partly funded by the NeCTAR eResearch_tools program. The Python interface allows users to make use of Jupyter notebooks. This allows for an interactive approach to the development and analysis of models.","title":"Welcome to using Underworld!"},{"location":"UserGuide/01_GettingStarted.html#documentation","text":"Underworld documentation is broken down into: examples : These notebooks go through the entire workflow for geophysics type problems. user guide : A more focused look at particular aspects of Underworld (e.g. swarm particles). publications : Notebooks which replicate models and results from the literature. docstrings : The Underworld API includes Python docstring type documentation. Underworld requires basic knowledge of Python; constructs such as lists, tuples, modules, for-loops, printing and simple functions. This guide covers the basics of how to load modules for Underworld and how to use Jupyter notebooks. A short overview of a typical Underworld model with plots is given at the end of this guide. The purpose of the user guide is to give users a more detailed understanding of the various aspects of modelling with Underworld. For those interested in getting moving as quickly as possible, the examples are perhaps a better place to start. Underworld objects utilise Python docstrings to provide documentation inline. You may access this documentation directly by using the native Python help() function. Quick help information in the form of a pop-up window can be obtained by using a question mark after the object within IPython/Jupyter notebooks; e.g. uw? .","title":"Documentation"},{"location":"UserGuide/01_GettingStarted.html#notebooks","text":"If you are new to the Jupyter Notebook, you may wish to familiarise yourself with the notebook environment first. There are many useful examples available online. Also, when using the notebook interactively, the Help menu bar option provides handy references.","title":"Notebooks"},{"location":"UserGuide/01_GettingStarted.html#installation","text":"This guide assumes that you have already installed Underworld. Details on how to install Underworld may be found at the project github page: https://github.com/underworldcode/underworld2","title":"Installation"},{"location":"UserGuide/01_GettingStarted.html#how-to-get-help","text":"If you encounter issues or suspect a bug, please create a ticket using the issue tracker on github .","title":"How to get help"},{"location":"UserGuide/01_GettingStarted.html#importing","text":"Run the following cell (either the run button on the menu above or press shift+enter ) to load the Underworld module: import underworld as uw","title":"Importing"},{"location":"UserGuide/01_GettingStarted.html#a-quick-demo","text":"Let's do a quick run through of setting up some basic Underworld objects. # First, create a mesh: mesh = uw.mesh.FeMesh_Cartesian( elementType = (\"Q1\"), elementRes = (8, 8), minCoord = (0., 0.), maxCoord = (2., 1.)) # Next we create a mesh variable: temperatureField = mesh.add_variable( nodeDofCount=1 ) # Let's initialise the variable with some data: for index, coord in enumerate(mesh.data): temperatureField.data[index] = coord[1] # set the temperature to be the vertical (y) coordinate # Finally we will plot the temperature field using ``gLucifer`` after importing the gLucifer module. import glucifer fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Surface(mesh, temperatureField, colours=\"blue white red\") ) fig.append( glucifer.objects.Mesh(mesh) ) fig.show() Typically we might then setup boundary conditions, particle swarms, rheology and systems to be solved. All of these topics are discussed in the following sections of the user guide.","title":"A quick demo"},{"location":"UserGuide/02_TheMesh.html","text":"The Mesh The finite element mesh is a fundamental construct for Underworld modelling. It will generally determine your domain geometry, and the resolution of the finite element system. For parallel simulations, the mesh topology will also determine the domain decomposition for the problem. Currently underworld only provides curvilinear mesh capabilities. Overview: Creating mesh objects. Element types. Deforming the mesh. Loading and saving the mesh. Special sets. Mesh variables Setting values on a mesh variables. Gradients of mesh variable fields. Loading and saving mesh variable data. Keywords: mesh variables, finite elements, load, save, initial conditions Creating the mesh First create an 2x2 element mesh. By default the mesh will be of rectangular geometry, with domain extents specified via the minCoord and maxCoord constructor parameters. import underworld as uw import glucifer mesh = uw.mesh.FeMesh_Cartesian( elementType = (\"Q1\"), elementRes = (2, 2), minCoord = (0.0, 0.0), maxCoord = (2.0, 1.0) ) # visualising the result figMesh = glucifer.Figure(figsize=(800,400)) figMesh.append( glucifer.objects.Mesh(mesh, nodeNumbers=True, pointsize=10) ) figMesh.show() Mesh node location data is available as numpy arrays via the data mesh instances attribute: for item in mesh.data: print(item) [ 0. 0.] [ 1. 0.] [ 2. 0.] [ 0. 0.5] [ 1. 0.5] [ 2. 0.5] [ 0. 1.] [ 1. 1.] [ 2. 1.] Note that data in underworld is always published as arrays of shape (num_items, count) , where num_items is the number of items in the dataset (in this case, 3x3 nodes, so 9 ), and count is the size of each data item (so 1 for scalar data, 2 or 3 for vectors in 2- and 3-dimensions respectively, etc). In parallel, each process will be assigned responsibility for a subsection of the domain, and as such the length ( num_items ) of the arrays will generally be different across processes. As such, while it might be tempting to use numpy.reshape to reshape your arrays to reflect the cartesian mesh topology, this approach will not work in parallel and is therefore not usually recommended. You should instead traverse data arrays as 1-d lists (each item of size count ). Following this pattern will usually result in models which can safely be run in serial or parallel. Element Types Underworld supports two primary element types: a linear element type ( Q1 ) and a quadratic element type ( Q2 ). Interpolation using these element types will provide continuous results across element boundaries, though note that interpolant derivatives will be discontinous across boundaries. Underworld also supports mixed element types, where a secondary element type may also be specified. This formulation is critical for stable solutions to Stokes type problems, with velocity fields being represented by the primary element type, and pressure fields by the secondary type. Secondary element types are not continuous across element boundaries. Supported secondary types are constant ( dQ0 ), linear ( dPc1 ) and bilinear ( dQ1 ). Refer to http://femtable.org for further details on element types. Mesh element types are specified as a textual argument to the elementType constructor parameter. A primary type must always be provided ( Q1 or Q2 ), and where a secondary type is required, the primary/secondary types are provided as a pair ( Q1/dQ0 , Q2/dPc1 or Q2/dQ1 ). For mixed type elements, two mesh objects are generated by the constructor, one for the primary and one for the secondary elements. The primary mesh will be the object returned directly by the constructor, with the secondary mesh available via the primary mesh's subMesh attribute: pmesh = uw.mesh.FeMesh_Cartesian( elementType=\"Q2/dpc1\" ) smesh = pmesh.subMesh print(\"{}: primary node count \\n{}: secondary node count\".format(len(pmesh.data),len(smesh.data))) 81: primary node count 48: secondary node count Note that where constructor parameters are omitted, default values are used. For example, here a 4x4 mesh is generated because elementRes is not specified. Defaults values are baked into the underworld API and may be determined in Jupyter by pressing shift - tab with the cursor inside the constructor parenthesis, or by using the Python help() function (with the class/function of interest as the argument). Default values are useful for quickly mocking up models, but may change without notice so should not be relied upon. Element boundaries (and therefore domain geometry and resolution) is entirely determined by the primary mesh, with the location of the secondary mesh nodes slaved to the primary mesh nodes. Secondary mesh nodes are visualised below. figMesh2 = glucifer.Figure() figMesh2.append( glucifer.objects.Mesh(pmesh) ) figMesh2.append( glucifer.objects.Mesh(smesh, nodeNumbers=True, pointsize=10) ) figMesh2.show() Deforming the mesh It is often desirable to deform the mesh to either conform the domain to some geometry, or to implement mesh refinement by bunching nodes in certain domain regions. The user is free to modify the mesh as desired, though care must be taken to ensure elements are not improperly transformed (Jacobians should not become singular) and to avoid tangling (face normals should be consistent). To deform the mesh, the user will directly modify the node coordinates via the usual data array. Note however that modifications are only possible from within the deform_mesh() context manager, as otherwise the array is read-only. with mesh.deform_mesh(): mesh.data[4][0] += 0.05 figMesh.show() Note that in the above example, for simplicity, we've simply moved an arbitrary mesh node. Usually you will not want to construct your logic in ways which rely on the node numbers themselves, as this will usually not be consistent across parallel simulations, and/or as you vary model resolution. We now look at a more realistic example where we deform the mesh to increase the resolution at the top of the domain. There are countless ways this may be achieved, but here we use the simple transformation z \\rightarrow \\sqrt{z} z \\rightarrow \\sqrt{z} : mesh = uw.mesh.FeMesh_Cartesian(elementRes=(32,32),maxCoord=(2.0,1.0)) with mesh.deform_mesh(): for index, coord in enumerate(mesh.data): mesh.data[index][1] = mesh.data[index][1]**0.5 figMesh3 = glucifer.Figure(figsize=(800,400)) figMesh3.append(glucifer.objects.Mesh(mesh)) figMesh3.show() Saving and loading the mesh Mesh coordinate data can be saved in hdf5 format using the mesh instance save method: ignore = mesh.save('deformedMesh.h5') To check that this has worked we will reset the mesh, visualise, then load the saved data and visualise again: mesh.reset() figMesh3.show() Now re-load and display: mesh.load('deformedMesh.h5') figMesh3.show() If you are resuming a simulation, you will usually need to reload the previous state of your simulation. In Underworld, the pattern is always to first recreate vanilla equivalent objects, and then reload the data. So in the case of the mesh above, you must first recreate a standard mesh object, and it must be of identical resolution and element type. Finally you will reload the data. restartMesh = uw.mesh.FeMesh_Cartesian(elementRes=(32,32)) restartMesh.load('deformedMesh.h5') import numpy as np result = np.allclose(mesh.data,restartMesh.data) # if this didn't work correctly, let's raise an error to alert the user. if result==False: raise RuntimeError(\"Restarted mesh is not identical to original mesh.\") # let's remove the saved file as it is no longer required. if uw.rank()==0: import os; os.remove('deformedMesh.h5') Special sets Special sets are sets of nodes which are in some way special to a given mesh object. For instance, for the cartesian mesh you will often wish to tie special values to the walls to form your problem boundary conditions. The list of special sets is provided via the specialSets list object: mesh = uw.mesh.FeMesh_Cartesian(elementRes=(2,2)) mesh.specialSets.keys() ['MaxI_VertexSet', 'Top_VertexSet', 'Left_VertexSet', 'MinI_VertexSet', 'AllWalls_VertexSet', 'Bottom_VertexSet', 'Right_VertexSet', 'MinJ_VertexSet', 'MaxJ_VertexSet', 'Empty'] The sets are named with respect to the (I,J,K) cartesian indexing of the mesh, with the I index usually used for the horizontal (left/right), J for the vertical, and K for horizontal (front/back). Note that this is just a matter of convention, and you are free to chose how the cartesian coordinates map within your model. So, for example, MinI_VertexSet specifies the set of nodes belonings to what we would normally consider to be the left wall, and similarly MaxI_VertexSet the right wall. We now also provide the alias ( Left_VertexSet , Right_VertexSet , etc) for the most common use case. leftset = mesh.specialSets['MinI_VertexSet'] print(leftset) FeMesh_IndexSet([0, 3, 6]) You can confirm that these are indeed the left nodes with reference to the mesh visualisation at the top of the page. Note that the special set indices always specify parallel local indices. In almost all instances, you will interact with only local data and identifiers. This pattern is critical to successful parallel operation, and is usually a natural way of constructing your models. You should also note that the above visualisation shows the global node numbering, though for these serial demonstrations the values are identical. Your checkpointed mesh (and mesh variable) data will however be ordered according to its global numbering. If for some reason you need to determine the global identifiers, they are stored in the data_elgId array. An important shorthand for your modelling is to use the special sets directly to index into arrays. For instance, we can find the coordinates of all left wall nodes directly as follows: mesh.data[leftset] array([[ 0. , 0. ], [ 0. , 0.5], [ 0. , 1. ]]) Mesh Variables Mesh variables are used to encode spatial data across the mesh. Underworld mesh variables assign data for each node of the mesh, so for example you might assign a temperature value at each mesh node. Mesh variables also leverage the mesh element shape functions to form interpolations within elements, allowing our discrete datasets to have continuous analogues formed. Mesh variables may be used for any number of purposes when constructing models, but most importantly they form the unknowns for the finite element numerical systems you will be solving. We create a mesh variable by using the mesh's add_variable() method, and specifying the nodeDofCount (node degree of freedom count). With nodeDofCount=1 a scalar variable is defined at each node of the mesh eg, temperature field. import math mesh = uw.mesh.FeMesh_Cartesian( elementType = (\"Q1\"), elementRes = (4, 4), minCoord = (0., 0.), maxCoord = (2., 1.) ) # now create our mesh variable temperatureField = mesh.add_variable( nodeDofCount=1 ) Setting values on the MeshVariable We may now set values on the mesh variable. As you will find with most Underworld data carrying objects, you will access the data directly via the data attribute. Our data is stored there as a numpy array, and you may therefore accessed or modified it using standard Numpy operations. Let's initialise the temperature variable with a function based on its spatial coordinates \\[ T = 100\\exp(1-z) \\] We will walk over the mesh vertex data to access coordinate information. As the temperature field data is by design a 1-1 map to the vertex data, we know the index of the mesh vertex will be the index of the associated temperature datum. Note that the Python built-in enumerate() acts to return both the index of a piece of data in a list (or array), and the data itself. pi = math.pi for index, coord in enumerate(mesh.data): temperatureField.data[index] = 100.*math.exp(1.-coord[1]) # vis results fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Surface(mesh, temperatureField) ) fig.append( glucifer.objects.Mesh(mesh) ) fig.show() To describe for example a velocity, a vector mesh variable is required. We set nodeDofCount=2 accordingly, and initialise to: \\mathbf{v} = \\left( z_0 - z, x - x_0 \\right) \\mathbf{v} = \\left( z_0 - z, x - x_0 \\right) velocityField = mesh.add_variable( nodeDofCount=2 ) coordmid = (1., 0.5) for index, coord in enumerate(mesh.data): vx = coordmid[1] - coord[1] vz = coord[0] - coordmid[0] velocityField.data[index] = (vx, vz) # visualise both the velocity and temperature fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.VectorArrows(mesh, velocityField, scaling=0.2, arrowHead=0.2) ) fig.show() Mesh variables gradients Mesh variable gradients are calculated according to: \\nabla A(\\mathbf{r}) = A_i\\nabla\\Phi_i(\\mathbf{r}) $$ Note that gradients derived in this way are not generally continuous across element boundaries. Note that we access the different gradient components via the square bracket operator, with ordering: $$ [ \\frac{\\partial T}{\\partial x}, \\frac{\\partial T}{\\partial y}, \\frac{\\partial T}{\\partial z} ] $$ or for a vector field: $$ [ \\frac{\\partial v_x}{\\partial x}, \\frac{\\partial v_x}{\\partial y}, \\frac{\\partial v_x}{\\partial z}, \\frac{\\partial v_y}{\\partial x}, \\frac{\\partial v_y}{\\partial y}, \\frac{\\partial v_y}{\\partial z}, \\frac{\\partial v_z}{\\partial x}, \\frac{\\partial v_z}{\\partial y}, \\frac{\\partial v_z}{\\partial z} ] \\nabla A(\\mathbf{r}) = A_i\\nabla\\Phi_i(\\mathbf{r}) $$ Note that gradients derived in this way are not generally continuous across element boundaries. Note that we access the different gradient components via the square bracket operator, with ordering: $$ [ \\frac{\\partial T}{\\partial x}, \\frac{\\partial T}{\\partial y}, \\frac{\\partial T}{\\partial z} ] $$ or for a vector field: $$ [ \\frac{\\partial v_x}{\\partial x}, \\frac{\\partial v_x}{\\partial y}, \\frac{\\partial v_x}{\\partial z}, \\frac{\\partial v_y}{\\partial x}, \\frac{\\partial v_y}{\\partial y}, \\frac{\\partial v_y}{\\partial z}, \\frac{\\partial v_z}{\\partial x}, \\frac{\\partial v_z}{\\partial y}, \\frac{\\partial v_z}{\\partial z} ] The gradient of the field is accessible via the fn_gradient attribute on the mesh variable. gradfield = temperatureField.fn_gradient[1] figGrad = glucifer.Figure(figsize=(800,400)) figGrad.append( glucifer.objects.Surface(mesh, gradfield) ) figGrad.show() Loading and saving variables In this example we will use the set values for the temperature field, save them to file, reset them, and then recover the original data by loading from the file. You will use the usual save() and load() methods on the mesh variable. Note that as for the mesh, Underworld uses HDF5 for writing data to disk. temperatureField.save('MeshVariableSaveExample.h5') # now create a new variable to load this data into loadedVariable = mesh.add_variable(1) # init to zero to be sure loadedVariable.data[:] = 0. # now load the data into the new variable loadedVariable.load('MeshVariableSaveExample.h5') # sanity check via Numpy array comparison import numpy as np result = np.allclose(temperatureField.data, loadedVariable.data) # if this didn't work correctly, let's raise an error to alert the user. if result == False: raise RuntimeError(\"The loaded variable does not correspond to the saved variable.\") # remove the saved file as it is no longer required. if uw.rank()==0: import os; os.remove(\"MeshVariableSaveExample.h5\")","title":"TheMesh"},{"location":"UserGuide/02_TheMesh.html#the-mesh","text":"The finite element mesh is a fundamental construct for Underworld modelling. It will generally determine your domain geometry, and the resolution of the finite element system. For parallel simulations, the mesh topology will also determine the domain decomposition for the problem. Currently underworld only provides curvilinear mesh capabilities.","title":"The Mesh"},{"location":"UserGuide/02_TheMesh.html#overview","text":"Creating mesh objects. Element types. Deforming the mesh. Loading and saving the mesh. Special sets. Mesh variables Setting values on a mesh variables. Gradients of mesh variable fields. Loading and saving mesh variable data. Keywords: mesh variables, finite elements, load, save, initial conditions","title":"Overview:"},{"location":"UserGuide/02_TheMesh.html#creating-the-mesh","text":"First create an 2x2 element mesh. By default the mesh will be of rectangular geometry, with domain extents specified via the minCoord and maxCoord constructor parameters. import underworld as uw import glucifer mesh = uw.mesh.FeMesh_Cartesian( elementType = (\"Q1\"), elementRes = (2, 2), minCoord = (0.0, 0.0), maxCoord = (2.0, 1.0) ) # visualising the result figMesh = glucifer.Figure(figsize=(800,400)) figMesh.append( glucifer.objects.Mesh(mesh, nodeNumbers=True, pointsize=10) ) figMesh.show() Mesh node location data is available as numpy arrays via the data mesh instances attribute: for item in mesh.data: print(item) [ 0. 0.] [ 1. 0.] [ 2. 0.] [ 0. 0.5] [ 1. 0.5] [ 2. 0.5] [ 0. 1.] [ 1. 1.] [ 2. 1.] Note that data in underworld is always published as arrays of shape (num_items, count) , where num_items is the number of items in the dataset (in this case, 3x3 nodes, so 9 ), and count is the size of each data item (so 1 for scalar data, 2 or 3 for vectors in 2- and 3-dimensions respectively, etc). In parallel, each process will be assigned responsibility for a subsection of the domain, and as such the length ( num_items ) of the arrays will generally be different across processes. As such, while it might be tempting to use numpy.reshape to reshape your arrays to reflect the cartesian mesh topology, this approach will not work in parallel and is therefore not usually recommended. You should instead traverse data arrays as 1-d lists (each item of size count ). Following this pattern will usually result in models which can safely be run in serial or parallel.","title":"Creating the mesh"},{"location":"UserGuide/02_TheMesh.html#element-types","text":"Underworld supports two primary element types: a linear element type ( Q1 ) and a quadratic element type ( Q2 ). Interpolation using these element types will provide continuous results across element boundaries, though note that interpolant derivatives will be discontinous across boundaries. Underworld also supports mixed element types, where a secondary element type may also be specified. This formulation is critical for stable solutions to Stokes type problems, with velocity fields being represented by the primary element type, and pressure fields by the secondary type. Secondary element types are not continuous across element boundaries. Supported secondary types are constant ( dQ0 ), linear ( dPc1 ) and bilinear ( dQ1 ). Refer to http://femtable.org for further details on element types. Mesh element types are specified as a textual argument to the elementType constructor parameter. A primary type must always be provided ( Q1 or Q2 ), and where a secondary type is required, the primary/secondary types are provided as a pair ( Q1/dQ0 , Q2/dPc1 or Q2/dQ1 ). For mixed type elements, two mesh objects are generated by the constructor, one for the primary and one for the secondary elements. The primary mesh will be the object returned directly by the constructor, with the secondary mesh available via the primary mesh's subMesh attribute: pmesh = uw.mesh.FeMesh_Cartesian( elementType=\"Q2/dpc1\" ) smesh = pmesh.subMesh print(\"{}: primary node count \\n{}: secondary node count\".format(len(pmesh.data),len(smesh.data))) 81: primary node count 48: secondary node count Note that where constructor parameters are omitted, default values are used. For example, here a 4x4 mesh is generated because elementRes is not specified. Defaults values are baked into the underworld API and may be determined in Jupyter by pressing shift - tab with the cursor inside the constructor parenthesis, or by using the Python help() function (with the class/function of interest as the argument). Default values are useful for quickly mocking up models, but may change without notice so should not be relied upon. Element boundaries (and therefore domain geometry and resolution) is entirely determined by the primary mesh, with the location of the secondary mesh nodes slaved to the primary mesh nodes. Secondary mesh nodes are visualised below. figMesh2 = glucifer.Figure() figMesh2.append( glucifer.objects.Mesh(pmesh) ) figMesh2.append( glucifer.objects.Mesh(smesh, nodeNumbers=True, pointsize=10) ) figMesh2.show()","title":"Element Types"},{"location":"UserGuide/02_TheMesh.html#deforming-the-mesh","text":"It is often desirable to deform the mesh to either conform the domain to some geometry, or to implement mesh refinement by bunching nodes in certain domain regions. The user is free to modify the mesh as desired, though care must be taken to ensure elements are not improperly transformed (Jacobians should not become singular) and to avoid tangling (face normals should be consistent). To deform the mesh, the user will directly modify the node coordinates via the usual data array. Note however that modifications are only possible from within the deform_mesh() context manager, as otherwise the array is read-only. with mesh.deform_mesh(): mesh.data[4][0] += 0.05 figMesh.show() Note that in the above example, for simplicity, we've simply moved an arbitrary mesh node. Usually you will not want to construct your logic in ways which rely on the node numbers themselves, as this will usually not be consistent across parallel simulations, and/or as you vary model resolution. We now look at a more realistic example where we deform the mesh to increase the resolution at the top of the domain. There are countless ways this may be achieved, but here we use the simple transformation z \\rightarrow \\sqrt{z} z \\rightarrow \\sqrt{z} : mesh = uw.mesh.FeMesh_Cartesian(elementRes=(32,32),maxCoord=(2.0,1.0)) with mesh.deform_mesh(): for index, coord in enumerate(mesh.data): mesh.data[index][1] = mesh.data[index][1]**0.5 figMesh3 = glucifer.Figure(figsize=(800,400)) figMesh3.append(glucifer.objects.Mesh(mesh)) figMesh3.show()","title":"Deforming the mesh"},{"location":"UserGuide/02_TheMesh.html#saving-and-loading-the-mesh","text":"Mesh coordinate data can be saved in hdf5 format using the mesh instance save method: ignore = mesh.save('deformedMesh.h5') To check that this has worked we will reset the mesh, visualise, then load the saved data and visualise again: mesh.reset() figMesh3.show() Now re-load and display: mesh.load('deformedMesh.h5') figMesh3.show() If you are resuming a simulation, you will usually need to reload the previous state of your simulation. In Underworld, the pattern is always to first recreate vanilla equivalent objects, and then reload the data. So in the case of the mesh above, you must first recreate a standard mesh object, and it must be of identical resolution and element type. Finally you will reload the data. restartMesh = uw.mesh.FeMesh_Cartesian(elementRes=(32,32)) restartMesh.load('deformedMesh.h5') import numpy as np result = np.allclose(mesh.data,restartMesh.data) # if this didn't work correctly, let's raise an error to alert the user. if result==False: raise RuntimeError(\"Restarted mesh is not identical to original mesh.\") # let's remove the saved file as it is no longer required. if uw.rank()==0: import os; os.remove('deformedMesh.h5')","title":"Saving and loading the mesh"},{"location":"UserGuide/02_TheMesh.html#special-sets","text":"Special sets are sets of nodes which are in some way special to a given mesh object. For instance, for the cartesian mesh you will often wish to tie special values to the walls to form your problem boundary conditions. The list of special sets is provided via the specialSets list object: mesh = uw.mesh.FeMesh_Cartesian(elementRes=(2,2)) mesh.specialSets.keys() ['MaxI_VertexSet', 'Top_VertexSet', 'Left_VertexSet', 'MinI_VertexSet', 'AllWalls_VertexSet', 'Bottom_VertexSet', 'Right_VertexSet', 'MinJ_VertexSet', 'MaxJ_VertexSet', 'Empty'] The sets are named with respect to the (I,J,K) cartesian indexing of the mesh, with the I index usually used for the horizontal (left/right), J for the vertical, and K for horizontal (front/back). Note that this is just a matter of convention, and you are free to chose how the cartesian coordinates map within your model. So, for example, MinI_VertexSet specifies the set of nodes belonings to what we would normally consider to be the left wall, and similarly MaxI_VertexSet the right wall. We now also provide the alias ( Left_VertexSet , Right_VertexSet , etc) for the most common use case. leftset = mesh.specialSets['MinI_VertexSet'] print(leftset) FeMesh_IndexSet([0, 3, 6]) You can confirm that these are indeed the left nodes with reference to the mesh visualisation at the top of the page. Note that the special set indices always specify parallel local indices. In almost all instances, you will interact with only local data and identifiers. This pattern is critical to successful parallel operation, and is usually a natural way of constructing your models. You should also note that the above visualisation shows the global node numbering, though for these serial demonstrations the values are identical. Your checkpointed mesh (and mesh variable) data will however be ordered according to its global numbering. If for some reason you need to determine the global identifiers, they are stored in the data_elgId array. An important shorthand for your modelling is to use the special sets directly to index into arrays. For instance, we can find the coordinates of all left wall nodes directly as follows: mesh.data[leftset] array([[ 0. , 0. ], [ 0. , 0.5], [ 0. , 1. ]])","title":"Special sets"},{"location":"UserGuide/02_TheMesh.html#mesh-variables","text":"Mesh variables are used to encode spatial data across the mesh. Underworld mesh variables assign data for each node of the mesh, so for example you might assign a temperature value at each mesh node. Mesh variables also leverage the mesh element shape functions to form interpolations within elements, allowing our discrete datasets to have continuous analogues formed. Mesh variables may be used for any number of purposes when constructing models, but most importantly they form the unknowns for the finite element numerical systems you will be solving. We create a mesh variable by using the mesh's add_variable() method, and specifying the nodeDofCount (node degree of freedom count). With nodeDofCount=1 a scalar variable is defined at each node of the mesh eg, temperature field. import math mesh = uw.mesh.FeMesh_Cartesian( elementType = (\"Q1\"), elementRes = (4, 4), minCoord = (0., 0.), maxCoord = (2., 1.) ) # now create our mesh variable temperatureField = mesh.add_variable( nodeDofCount=1 )","title":"Mesh Variables"},{"location":"UserGuide/02_TheMesh.html#setting-values-on-the-meshvariable","text":"We may now set values on the mesh variable. As you will find with most Underworld data carrying objects, you will access the data directly via the data attribute. Our data is stored there as a numpy array, and you may therefore accessed or modified it using standard Numpy operations. Let's initialise the temperature variable with a function based on its spatial coordinates \\[ T = 100\\exp(1-z) \\] We will walk over the mesh vertex data to access coordinate information. As the temperature field data is by design a 1-1 map to the vertex data, we know the index of the mesh vertex will be the index of the associated temperature datum. Note that the Python built-in enumerate() acts to return both the index of a piece of data in a list (or array), and the data itself. pi = math.pi for index, coord in enumerate(mesh.data): temperatureField.data[index] = 100.*math.exp(1.-coord[1]) # vis results fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Surface(mesh, temperatureField) ) fig.append( glucifer.objects.Mesh(mesh) ) fig.show() To describe for example a velocity, a vector mesh variable is required. We set nodeDofCount=2 accordingly, and initialise to: \\mathbf{v} = \\left( z_0 - z, x - x_0 \\right) \\mathbf{v} = \\left( z_0 - z, x - x_0 \\right) velocityField = mesh.add_variable( nodeDofCount=2 ) coordmid = (1., 0.5) for index, coord in enumerate(mesh.data): vx = coordmid[1] - coord[1] vz = coord[0] - coordmid[0] velocityField.data[index] = (vx, vz) # visualise both the velocity and temperature fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.VectorArrows(mesh, velocityField, scaling=0.2, arrowHead=0.2) ) fig.show()","title":"Setting values on the MeshVariable"},{"location":"UserGuide/02_TheMesh.html#mesh-variables-gradients","text":"Mesh variable gradients are calculated according to: \\nabla A(\\mathbf{r}) = A_i\\nabla\\Phi_i(\\mathbf{r}) $$ Note that gradients derived in this way are not generally continuous across element boundaries. Note that we access the different gradient components via the square bracket operator, with ordering: $$ [ \\frac{\\partial T}{\\partial x}, \\frac{\\partial T}{\\partial y}, \\frac{\\partial T}{\\partial z} ] $$ or for a vector field: $$ [ \\frac{\\partial v_x}{\\partial x}, \\frac{\\partial v_x}{\\partial y}, \\frac{\\partial v_x}{\\partial z}, \\frac{\\partial v_y}{\\partial x}, \\frac{\\partial v_y}{\\partial y}, \\frac{\\partial v_y}{\\partial z}, \\frac{\\partial v_z}{\\partial x}, \\frac{\\partial v_z}{\\partial y}, \\frac{\\partial v_z}{\\partial z} ] \\nabla A(\\mathbf{r}) = A_i\\nabla\\Phi_i(\\mathbf{r}) $$ Note that gradients derived in this way are not generally continuous across element boundaries. Note that we access the different gradient components via the square bracket operator, with ordering: $$ [ \\frac{\\partial T}{\\partial x}, \\frac{\\partial T}{\\partial y}, \\frac{\\partial T}{\\partial z} ] $$ or for a vector field: $$ [ \\frac{\\partial v_x}{\\partial x}, \\frac{\\partial v_x}{\\partial y}, \\frac{\\partial v_x}{\\partial z}, \\frac{\\partial v_y}{\\partial x}, \\frac{\\partial v_y}{\\partial y}, \\frac{\\partial v_y}{\\partial z}, \\frac{\\partial v_z}{\\partial x}, \\frac{\\partial v_z}{\\partial y}, \\frac{\\partial v_z}{\\partial z} ] The gradient of the field is accessible via the fn_gradient attribute on the mesh variable. gradfield = temperatureField.fn_gradient[1] figGrad = glucifer.Figure(figsize=(800,400)) figGrad.append( glucifer.objects.Surface(mesh, gradfield) ) figGrad.show()","title":"Mesh variables gradients"},{"location":"UserGuide/02_TheMesh.html#loading-and-saving-variables","text":"In this example we will use the set values for the temperature field, save them to file, reset them, and then recover the original data by loading from the file. You will use the usual save() and load() methods on the mesh variable. Note that as for the mesh, Underworld uses HDF5 for writing data to disk. temperatureField.save('MeshVariableSaveExample.h5') # now create a new variable to load this data into loadedVariable = mesh.add_variable(1) # init to zero to be sure loadedVariable.data[:] = 0. # now load the data into the new variable loadedVariable.load('MeshVariableSaveExample.h5') # sanity check via Numpy array comparison import numpy as np result = np.allclose(temperatureField.data, loadedVariable.data) # if this didn't work correctly, let's raise an error to alert the user. if result == False: raise RuntimeError(\"The loaded variable does not correspond to the saved variable.\") # remove the saved file as it is no longer required. if uw.rank()==0: import os; os.remove(\"MeshVariableSaveExample.h5\")","title":"Loading and saving variables"},{"location":"UserGuide/03_Swarms.html","text":"Swarms In Underworld, the swarm is an object that defines a collection of particles. Swarms are usually used to track the Lagrangian quantities required for a given model, such as a material type identifier, or the plastic strain of an advecting parcel of fluid. Swarm may be used passively to record information as they advect, or actively where the values recorded on particles actually feed into rheologies or forces. Swarms of particles may: Advect through the mesh according to a user specified velocity. Store arbitrary data on a per-particle basis. Freely cross process boundaries in parallel simulations. The user is free to create as many swarms as required and each swarm may contain an arbitrary number of particles. The data layout for any given swarm is identical across all its particles, though different swarms may have different layouts. For example, SwarmA may contain 100 particles, and each particle may encode an int and a float , while SwarmB may contain 15 particles, each particle encoding three float values. Particles may also be added to a swarm at any stage either directly or through population control mechanisms. It is also possible to delete particles, though currently this is only possible through indirect means. Overview Creating a swarm object and adding particles. Moving particles. Swarm variables. Shapes with particle swarms. Saving and loading swarms. Keywords: swarms, particles, shapes. Creating a swarm object and adding particles Creating a swarm is very simple. You will first require a mesh, as the mesh object is used to determine domain and parallel decomposition of your model. import underworld as uw import glucifer import numpy as np mesh = uw.mesh.FeMesh_Cartesian(maxCoord=(2.,1.)) swarm = uw.swarm.Swarm( mesh=mesh ) Once you have created your swarm, you can then add particles. To add particles, you will either use a layout object, or generate a numpy array with the required particle coordinates. Let's first look at using layouts: swarmLayout = uw.swarm.layouts.PerCellSpaceFillerLayout( swarm=swarm, particlesPerCell=20 ) # perform the populating swarm.populate_using_layout( layout=swarmLayout ) # vis fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Points(swarm=swarm, pointSize=5, colourBar=False) ) fig.append( glucifer.objects.Mesh(mesh) ) fig.show() Layouts are usually the best option where you want to populate the entire domain with particles. This is the usual use case where you intend on using particles dynamically. Note also that layouts may only be used to populate swarm objects which are currently empty. There are numerous layouts available in the underworld.swarm.layouts submodule. Swarms can also be populated using numpy arrays that specify particle coordinates. This is how you will add particles when you wish to explicitly specify their coordinates and the total number of particles. The usual use case for this is adding passive swarms for analytic purposes, such as tracking interfaces, or extracting data at fixed coordinates throughout your simulations. Let's create a new swarm and add particles explicitly. swarmCustom = uw.swarm.Swarm( mesh=mesh, particleEscape=True ) # create the array swarmCoords = np.array([ [0.4,0.2], [0.8,0.4],[1.2,0.6],[1.6,0.8],[3.6,1.8]]) # use the array to add particles at the specified coordinates. swarmCustom.add_particles_with_coordinates(swarmCoords) array([ 0, 1, 2, 3, -1], dtype=int32) Note the array returned above by the add_particles_with_coordinates method. It specifies the local identifiers for the added particles. Coordinates which are not within the (local) domain will be ignored and are signified with a -1 . For parallel simulation, the domain is partitioned across all processes, and therefore coordinates which are ignored on one process (ie, no particle created) may be consumed on another process (ie, particle created). Let's have a look at our new swarm. fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Points(swarm=swarmCustom, pointSize=10, colourBar=False) ) fig.append( glucifer.objects.Mesh(mesh)) fig.show() Moving particles To move particles, you have two options. You can explicitly move particles using the data numpy array on the swarm (or equivalently via particleCoordinates.data ), or you can use the swarm advector object ( underworld.Systems.SwarmAdvector ). The latter is a natural choice when advecting a swarm with a velocity field that you have either defined, or is the result of a Stokes solve. It is the usual way in which particles are advected. Let us start with a very basic constant velocity field with which to advect particles vel = mesh.add_variable(2) vel.data[:] = (1.,0.) advector = uw.systems.SwarmAdvector(vel,swarmCustom) dt = advector.get_max_dt() advector.integrate(dt) fig.show() Note that the swarm advector requires a MeshVariable class velocity field object, and does not yet support the more general Function class. To modify particle coordinates directly, we must use the deform_swarm context manager, much as the deform_mesh manager is required to modify the mesh. We will first move a single particle: with swarmCustom.deform_swarm(): swarmCustom.data[1] = (0.4,0.5) fig.show() Underworld also supports particle deletion, though currently this is only possible by moving particles outside the domain. Note that the swarm object must also be created with particleEscape=True . with swarmCustom.deform_swarm(): swarmCustom.data[1] = (9999,9999.) fig.show() Swarm variables You may add data storing variables to the swarm via the add_variable() swarm method. Each particle will record a value of the given type and count: swarmVariable = swarmCustom.add_variable(dataType='double', count=1) swarmVariable.data[0] = 1. swarmVariable.data[1] = 10. swarmVariable.data[2] = 100. fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Points( swarm=swarmCustom, pointSize=20, fn_colour=swarmVariable, colourBar = True, colours=\"red green blue\", logScale=True) ) fig.append( glucifer.objects.Mesh(mesh, opacity=0.25)) fig.show() Shapes with particle swarms This example will demonstrate the creation of geometry using swarm variables. Particle geometries often form means to define initial fluid/material distribution in models. You will see later how once you have defined a material identifier on each particle, you can then delegate different behaviours based on this identifier using Function objects. First we'll create a vanilla swarm with a materialIndex variable to record the material type: mesh = uw.mesh.FeMesh_Cartesian( elementRes = (64, 64), maxCoord = (2., 1.) ) swarm = uw.swarm.Swarm( mesh=mesh ) # add a data variable which will store an index to determine material materialIndex = swarm.add_variable( dataType=\"int\", count=1 ) # populate our swarm across the mesh domain swarmLayout = uw.swarm.layouts.PerCellSpaceFillerLayout( swarm=swarm, particlesPerCell=20 ) swarm.populate_using_layout( layout=swarmLayout ) materialIndex.data[:] = 0 We want to configure our materialIndex such that it defines a circle. We will use a Python loop to traverse all the particles, and for particles who's coordinates fall inside our circle shape, we will set their materialIndex value to 1 . Note that we have already initialised the materialIndex values to 0 above, so we only need to modify the values of particles within the circle. # our circles parameters circleRadius = 0.1 circleCentre = (1., 0.5) # the particle loop for index, coord in enumerate(swarm.particleCoordinates.data): x = coord[0] z = coord[1] xx = x - circleCentre[0] zz = z - circleCentre[1] condition = (xx*xx + zz*zz < circleRadius**2) if(condition == True): # inside the circle materialIndex.data[index] = 1 # vis fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Points( swarm=swarm, fn_colour=materialIndex, colours='blue red', colourBar=True, pointSize=2.0 ) ) fig.show() More efficient ways to achieve this are presented in the Functions section of the user guide, though for operations that are usually only performed once in a simulation (such as initialisation), we recommend using whichever method you find most natural, as the costs are usually negligible. Saving and load a swarms and swarm variables As with other data types, the save() method is used to save Swarm and SwarmVariable objects. ignore = swarm.save(\"SwarmWithCircle.h5\") ignore = materialIndex.save(\"SwarmWithCircle.materialIndex.h5\") Note that the above methods return SavedFileData objects which are used required if you wish to create XDMF files and can be ignored otherwise. Although it is not necessary to do so, we record them to the ignore instance as they are not required here. See the Utilities section of the user guide for further information. Similarly, the load() method is used to load Swarm and SwarmVariable objects. Note that it is necessary to load the Swarm object before the corresponding SwarmVariable object can be loaded. Ie, you cannot load directly onto an existing SwarmVariable without first loading a Swarm . This is to ensure that both objects are in a compatible state (specifically, the correct number of particles exists and the data ordering is identical). swarmCopy = uw.swarm.Swarm( mesh=mesh ) swarmCopy.load(\"SwarmWithCircle.h5\") # The swarm geometry is now loaded but the swarmVariables are not restored. # We have to explicitly create and re-populate any variables we have previously saved materialIndexCopy = swarmCopy.add_variable(\"int\",1) materialIndexCopy.load(\"SwarmWithCircle.materialIndex.h5\") fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Points( swarm=swarmCopy, fn_colour=materialIndexCopy, colours='blue red', colourBar=True, pointSize=2.0 ) ) fig.show() # Cleanup if uw.rank()==0: import os os.remove( \"SwarmWithCircle.h5\" ) os.remove( \"SwarmWithCircle.materialIndex.h5\" )","title":"Swarms"},{"location":"UserGuide/03_Swarms.html#swarms","text":"In Underworld, the swarm is an object that defines a collection of particles. Swarms are usually used to track the Lagrangian quantities required for a given model, such as a material type identifier, or the plastic strain of an advecting parcel of fluid. Swarm may be used passively to record information as they advect, or actively where the values recorded on particles actually feed into rheologies or forces. Swarms of particles may: Advect through the mesh according to a user specified velocity. Store arbitrary data on a per-particle basis. Freely cross process boundaries in parallel simulations. The user is free to create as many swarms as required and each swarm may contain an arbitrary number of particles. The data layout for any given swarm is identical across all its particles, though different swarms may have different layouts. For example, SwarmA may contain 100 particles, and each particle may encode an int and a float , while SwarmB may contain 15 particles, each particle encoding three float values. Particles may also be added to a swarm at any stage either directly or through population control mechanisms. It is also possible to delete particles, though currently this is only possible through indirect means.","title":"Swarms"},{"location":"UserGuide/03_Swarms.html#overview","text":"Creating a swarm object and adding particles. Moving particles. Swarm variables. Shapes with particle swarms. Saving and loading swarms. Keywords: swarms, particles, shapes.","title":"Overview"},{"location":"UserGuide/03_Swarms.html#creating-a-swarm-object-and-adding-particles","text":"Creating a swarm is very simple. You will first require a mesh, as the mesh object is used to determine domain and parallel decomposition of your model. import underworld as uw import glucifer import numpy as np mesh = uw.mesh.FeMesh_Cartesian(maxCoord=(2.,1.)) swarm = uw.swarm.Swarm( mesh=mesh ) Once you have created your swarm, you can then add particles. To add particles, you will either use a layout object, or generate a numpy array with the required particle coordinates. Let's first look at using layouts: swarmLayout = uw.swarm.layouts.PerCellSpaceFillerLayout( swarm=swarm, particlesPerCell=20 ) # perform the populating swarm.populate_using_layout( layout=swarmLayout ) # vis fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Points(swarm=swarm, pointSize=5, colourBar=False) ) fig.append( glucifer.objects.Mesh(mesh) ) fig.show() Layouts are usually the best option where you want to populate the entire domain with particles. This is the usual use case where you intend on using particles dynamically. Note also that layouts may only be used to populate swarm objects which are currently empty. There are numerous layouts available in the underworld.swarm.layouts submodule. Swarms can also be populated using numpy arrays that specify particle coordinates. This is how you will add particles when you wish to explicitly specify their coordinates and the total number of particles. The usual use case for this is adding passive swarms for analytic purposes, such as tracking interfaces, or extracting data at fixed coordinates throughout your simulations. Let's create a new swarm and add particles explicitly. swarmCustom = uw.swarm.Swarm( mesh=mesh, particleEscape=True ) # create the array swarmCoords = np.array([ [0.4,0.2], [0.8,0.4],[1.2,0.6],[1.6,0.8],[3.6,1.8]]) # use the array to add particles at the specified coordinates. swarmCustom.add_particles_with_coordinates(swarmCoords) array([ 0, 1, 2, 3, -1], dtype=int32) Note the array returned above by the add_particles_with_coordinates method. It specifies the local identifiers for the added particles. Coordinates which are not within the (local) domain will be ignored and are signified with a -1 . For parallel simulation, the domain is partitioned across all processes, and therefore coordinates which are ignored on one process (ie, no particle created) may be consumed on another process (ie, particle created). Let's have a look at our new swarm. fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Points(swarm=swarmCustom, pointSize=10, colourBar=False) ) fig.append( glucifer.objects.Mesh(mesh)) fig.show()","title":"Creating a swarm object and adding particles"},{"location":"UserGuide/03_Swarms.html#moving-particles","text":"To move particles, you have two options. You can explicitly move particles using the data numpy array on the swarm (or equivalently via particleCoordinates.data ), or you can use the swarm advector object ( underworld.Systems.SwarmAdvector ). The latter is a natural choice when advecting a swarm with a velocity field that you have either defined, or is the result of a Stokes solve. It is the usual way in which particles are advected. Let us start with a very basic constant velocity field with which to advect particles vel = mesh.add_variable(2) vel.data[:] = (1.,0.) advector = uw.systems.SwarmAdvector(vel,swarmCustom) dt = advector.get_max_dt() advector.integrate(dt) fig.show() Note that the swarm advector requires a MeshVariable class velocity field object, and does not yet support the more general Function class. To modify particle coordinates directly, we must use the deform_swarm context manager, much as the deform_mesh manager is required to modify the mesh. We will first move a single particle: with swarmCustom.deform_swarm(): swarmCustom.data[1] = (0.4,0.5) fig.show() Underworld also supports particle deletion, though currently this is only possible by moving particles outside the domain. Note that the swarm object must also be created with particleEscape=True . with swarmCustom.deform_swarm(): swarmCustom.data[1] = (9999,9999.) fig.show()","title":"Moving particles"},{"location":"UserGuide/03_Swarms.html#swarm-variables","text":"You may add data storing variables to the swarm via the add_variable() swarm method. Each particle will record a value of the given type and count: swarmVariable = swarmCustom.add_variable(dataType='double', count=1) swarmVariable.data[0] = 1. swarmVariable.data[1] = 10. swarmVariable.data[2] = 100. fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Points( swarm=swarmCustom, pointSize=20, fn_colour=swarmVariable, colourBar = True, colours=\"red green blue\", logScale=True) ) fig.append( glucifer.objects.Mesh(mesh, opacity=0.25)) fig.show()","title":"Swarm variables"},{"location":"UserGuide/03_Swarms.html#shapes-with-particle-swarms","text":"This example will demonstrate the creation of geometry using swarm variables. Particle geometries often form means to define initial fluid/material distribution in models. You will see later how once you have defined a material identifier on each particle, you can then delegate different behaviours based on this identifier using Function objects. First we'll create a vanilla swarm with a materialIndex variable to record the material type: mesh = uw.mesh.FeMesh_Cartesian( elementRes = (64, 64), maxCoord = (2., 1.) ) swarm = uw.swarm.Swarm( mesh=mesh ) # add a data variable which will store an index to determine material materialIndex = swarm.add_variable( dataType=\"int\", count=1 ) # populate our swarm across the mesh domain swarmLayout = uw.swarm.layouts.PerCellSpaceFillerLayout( swarm=swarm, particlesPerCell=20 ) swarm.populate_using_layout( layout=swarmLayout ) materialIndex.data[:] = 0 We want to configure our materialIndex such that it defines a circle. We will use a Python loop to traverse all the particles, and for particles who's coordinates fall inside our circle shape, we will set their materialIndex value to 1 . Note that we have already initialised the materialIndex values to 0 above, so we only need to modify the values of particles within the circle. # our circles parameters circleRadius = 0.1 circleCentre = (1., 0.5) # the particle loop for index, coord in enumerate(swarm.particleCoordinates.data): x = coord[0] z = coord[1] xx = x - circleCentre[0] zz = z - circleCentre[1] condition = (xx*xx + zz*zz < circleRadius**2) if(condition == True): # inside the circle materialIndex.data[index] = 1 # vis fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Points( swarm=swarm, fn_colour=materialIndex, colours='blue red', colourBar=True, pointSize=2.0 ) ) fig.show() More efficient ways to achieve this are presented in the Functions section of the user guide, though for operations that are usually only performed once in a simulation (such as initialisation), we recommend using whichever method you find most natural, as the costs are usually negligible.","title":"Shapes with particle swarms"},{"location":"UserGuide/03_Swarms.html#saving-and-load-a-swarms-and-swarm-variables","text":"As with other data types, the save() method is used to save Swarm and SwarmVariable objects. ignore = swarm.save(\"SwarmWithCircle.h5\") ignore = materialIndex.save(\"SwarmWithCircle.materialIndex.h5\") Note that the above methods return SavedFileData objects which are used required if you wish to create XDMF files and can be ignored otherwise. Although it is not necessary to do so, we record them to the ignore instance as they are not required here. See the Utilities section of the user guide for further information. Similarly, the load() method is used to load Swarm and SwarmVariable objects. Note that it is necessary to load the Swarm object before the corresponding SwarmVariable object can be loaded. Ie, you cannot load directly onto an existing SwarmVariable without first loading a Swarm . This is to ensure that both objects are in a compatible state (specifically, the correct number of particles exists and the data ordering is identical). swarmCopy = uw.swarm.Swarm( mesh=mesh ) swarmCopy.load(\"SwarmWithCircle.h5\") # The swarm geometry is now loaded but the swarmVariables are not restored. # We have to explicitly create and re-populate any variables we have previously saved materialIndexCopy = swarmCopy.add_variable(\"int\",1) materialIndexCopy.load(\"SwarmWithCircle.materialIndex.h5\") fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Points( swarm=swarmCopy, fn_colour=materialIndexCopy, colours='blue red', colourBar=True, pointSize=2.0 ) ) fig.show() # Cleanup if uw.rank()==0: import os os.remove( \"SwarmWithCircle.h5\" ) os.remove( \"SwarmWithCircle.materialIndex.h5\" )","title":"Saving and load a swarms and swarm variables"},{"location":"UserGuide/04_Functions.html","text":"Functions Function class objects provide the building blocks for mathematical expression within Underworld2. The primary aim of this class is to enable a natural description of mathematics through the Python syntax so that users may quickly and accurately prototype model behaviour. Functions are used extensively across the Underworld2 API and provide a unified interface to Underworld2 discrete objects ( SwarmVariable and MeshVariable objects). Overview: A simple example. Usage basics. Module overview. The evaluate() method. The input function. Branching functions. Keywords: functions, swarms, meshvariables, materials A Simple Example Let us define a function which we might use as a variable heat conductivity for a thermal problem. It will take the following temperature dependent form: k(\\mathbf{x}) = 5 +8\\exp({5T(\\mathbf{x})}) k(\\mathbf{x}) = 5 +8\\exp({5T(\\mathbf{x})}) import os import underworld as uw from underworld import function as fn import glucifer # first create a mesh and variable mesh = uw.mesh.FeMesh_Cartesian(elementRes=(64,64), maxCoord=(2.,1.)) tempVar = mesh.add_variable(1) # init the temp variable for index,coord in enumerate(mesh.data): tempVar.data[index] = coord[1] # and now define the function. fn_k = 5. + 8.*fn.math.exp(5.*tempVar) # a # vis fig = glucifer.Figure(figsize=(800,400)) fig.append(glucifer.objects.Surface(mesh,fn_k)) # b fig.show() # c Let's deconstruct the Function defined at step (a) above: fn_k = 5. # 1 + 8.* # 2 fn.math.exp( # 3 5.*temp ) # 4 Things to note at the positions above: You can directly use Python native numerical objects. Under the hood, the native Python float object created here ' 5. ' will be automatically converted to an Underworld2 Constant type function. Note that arithmetic operations only currently support float type objects, and an exception will be thrown for other types. For this reason, you often need to be careful where you use Python natives (for instance, using ' 5 ' here instead of ' 5. ' would result in an error). Again, the native ' 8. ' will be automatically converted. The addition operator here will be automatically converted to an Underworld Addition operation through operator overloading. Likewise for the multiplication operation. Note that for an exponential function, we need to use the Underworld provided fn.math.exp function, not the Python math module exp function. Here the argument ( 5.*temp ) is itself a Function , and Function compounding applies. Importantly, note that the MeshVariable is used directly in the arithmetic, and this is possible because it is also a Function class object (more on this soon). At step (b), we provide the function to the visualisation object ( Surface ). Function objects are expected in many places across the Underworld2 API. Finally, at step (c), the actually function evaluation occurs, though under the hood it is a two step process. In the first step, tests are performed to ensure that the provided function is compatible with the required operation. Compatibility is dependent on a number of factors which we discuss below ('Conformal input & output checking'), and if there are any problems an exception will be raised here to notify the user. The second step is the required function evaluation, and will generally be the most compuationally expensive phase. Usage basics Underworld data objects As seen in the example above, Underworld data objects ( MeshVariable and SwarmVariable types) may be used directly within functions, as they are indeed themselves Function objects (via Python multiple inheritance). The Function class provides a uniform interface to these objects and is (largely) agnostic to the underlying data discretisation, instead providing mechanisms for evaluation at arbitrary coordinates. Note that true arbitrary coordinate evaluation is not possible for SwarmVariable objects, as they are purely discrete and do not (currently) have supporting interpolation functions. The special case inputs provided by objects of the FunctionInput class may be used for SwarmVariable objects (more on this soon). The following simple example demonstrates querying a MeshVariable object. # create a new mesh variable sinvar = mesh.add_variable(1) # initialise with a sine perturbation import numpy as np sinvar.data[:,0] = np.sin( np.pi*mesh.data[:,0] ) # use the `evaluate()` method to perform query.. more on this below result = sinvar.evaluate( (0.25,0.) ) print(\"Evaluation result: {}\".format(result)) Evaluation result: [[ 0.70710678]] # Let's define a test which we will use to ensure we're getting the correct numbers: def test( result, expected ): if not np.allclose(result, expected, rtol=2e-2, atol=2e-2 ): raise RuntimeError(\"Error! Expected result was not obtained.\") # use test import math test(result,math.sqrt(2.)/2.) Elementary algebraic operations Use the Python equivalents ( + , - , * , / ) directly with your Function objects! Function objects are operator overloaded to facilitate this. Note however that only functions which return floating point type values are compatible with elementary operations currently, and an exception will be raised otherwise. Let's have a play with some mesh variables initialised to constants. # create some more mesh variables and initialise two_var = mesh.add_variable(1) six_var = mesh.add_variable(1) two_var.data[:] = 2. six_var.data[:] = 6. # create some functions via the Python operators fn_plus = two_var + six_var fn_minus = two_var - six_var fn_div = two_var / six_var fn_times = two_var * six_var # check results.. evaluate anywhere as our mesh variables are constant coord = (0.1234, 0.5678) resultplus = fn_plus.evaluate( coord ) resultminus = fn_minus.evaluate( coord ) resultdiv = fn_div.evaluate( coord ) resulttimes = fn_times.evaluate( coord ) print(\"Addition result : {}\".format(resultplus)) print(\"Subtraction result : {}\".format(resultminus)) print(\"Division result : {}\".format(resultdiv)) print(\"Multiplication result: {}\".format(resulttimes)) # run tests test(resultplus, 8.) test(resultminus,-4.) test(resultdiv, 1./3.) test(resulttimes, 12.) Addition result : [[ 8.]] Subtraction result : [[-4.]] Division result : [[ 0.33333333]] Multiplication result: [[ 12.]] Convenience conversions Python elementary types (int/floats/etc) may be used directly with Underworld Function objects in algebraic operations. Likewise, Python tuples (or lists) of Underworld Functions are automatically converted into Function objects which return vector results composed of the tuple/list entries. It is often important to remember that the elementary algebraic operations are only compatible with float type objects, and therefore you will often need to write ' 5. ' (which will be converted to a double precision float object) instead of ' 5 ' (which will be converted to a integer object). # create a new mesh variable and initialise with cosine data cosvar = mesh.add_variable(1) cosvar.data[:,0] = np.cos( np.pi*mesh.data[:,0] ) # create function. note that `2.` and the `1.` are automatically converted sin2 = 2.*sinvar*cosvar + 1. # evaluate somewhere and then test import random coord = ( random.random(), 0. ) result = sin2.evaluate(coord) expected = math.sin(2.*math.pi*coord[0]) + 1. # via double angle formula test(result, expected) # also let's create a vector function on the fly. # first create a vector mesh variable vecvar = mesh.add_variable(2) vecvar.data[:] = (1.,1.) # now the function definition, evaluation, and test fn_vec = vecvar + (sinvar, cosvar) result = fn_vec.evaluate(coord) expected = (math.sin(math.pi*coord[0]) + 1., math.cos(math.pi*coord[0]) + 1.) test(result,expected) Note that conversions can only occur automatically where the Python object (tuple or primary math object) comes in contact with an Underworld function, whereby conversion occurs by virtue of the object overloading. However, occasionally we may wish to explicitly perform conversions, generally where we wish to use the evaluate() method or when we wish to utilise overloading. The convert() static method on the Function class provides this functionality: vec_as_py_tuple = (sinvar, cosvar) print(\"`vec_as_py_tuple` type is: {}\".format(type(vec_as_py_tuple))) # this will not work! # vec_as_py_tuple.evaluate() vec_as_uw_fn = fn.Function.convert(vec_as_py_tuple) print(\"`vec_as_uw_fn` type is: {}\".format(type(vec_as_uw_fn))) # this is better print(\"evaluate: {}\".format(vec_as_uw_fn.evaluate(coord))) `vec_as_py_tuple` type is: <type 'tuple'> `vec_as_uw_fn` type is: <class 'underworld.function._function.add'> evaluate: [[ 0.36876784 0.92885861]] Basic mathematical functions Basic functions (such as sin() and exp() ) are provided by the underworld.function.math module. Note that the Python math module is not compatible with Underworld2 functions (you must use our math module). Operator overloads are also provided from the indexing operator ( [] ) and the power operator ( ** ). We will construct some more double angle formula here. While in the previous example, we used Numpy to initialise a mesh variable object to construct sin and cos like functions, here all mathematical operations will be performed by Underworld Function objects. # trig funcs sin = fn.math.sin() cos = fn.math.cos() tan = fn.math.tan() # double angle formula sin_2theta = 2.*sin*cos cos_2theta = 1. - 2.*sin**2 tan_2theta = (2.*tan)/(1.-tan**2) # get somewhere to evaluate theta = random.random() # do things check out? test( sin_2theta.evaluate(theta), math.sin(2*theta) ) test( cos_2theta.evaluate(theta), math.cos(2*theta) ) test( tan_2theta.evaluate(theta), math.tan(2*theta) ) Relational and logical functions Relational functions are constructed via the Python relational operators ( < , <= , > , >= ). Underworld functions for AND , OR and XOR logical operations are also available, and these overload the Python bitwise operators ( & , | , ^ ) (though they do not perform bitwise operations). These functions will all return boolean results. # define a logical function for inside a unit circle. # we will use the `input()` function as a proxy for the coordinate (see below). radius = 1. coord = fn.input() inside_circle = ( coord[0]**2 + coord[1]**2 < radius**2 ) # test at some locations test( inside_circle.evaluate( (0. ,0. ) ), True ) test( inside_circle.evaluate( (1. ,1. ) ), False ) test( inside_circle.evaluate( (0.5,0.5) ), True ) test( inside_circle.evaluate( (0.9,0.5) ), False ) # now something a bit more complex.. first, some circles radius = 0.25 offset = (1.0,0.5) deltax = radius*math.cos(math.pi/4.) deltay = radius*math.sin(math.pi/4.) coord1 = fn.input() - offset circle1 = ( fn.math.dot(coord1,coord1) < radius**2 ) coord2 = coord1 - ( deltax, deltay) circle2 = ( fn.math.dot(coord2,coord2) < radius**2 ) coord3 = coord1 - (-deltax, deltay) circle3 = ( fn.math.dot(coord3,coord3) < radius**2 ) coord4 = coord1 - ( deltax,-deltay) circle4 = ( fn.math.dot(coord4,coord4) < radius**2 ) coord5 = coord1 - (-deltax,-deltay) circle5 = ( fn.math.dot(coord5,coord5) < radius**2 ) # now create a cross.. note the use of the OR operator cross = ( (fn.math.abs(coord1[0])<radius/2.) | (fn.math.abs(coord1[1])<radius/2.) ) # visualise the XOR of these shapes fig = glucifer.Figure(figsize=(800,400)) fig.append(glucifer.objects.Surface(mesh, circle1^circle2^circle3^circle4^circle5^cross, resolution=600, onMesh=False, colours=['white','blue'])) fig.show() Conformal input & output checking When you define your functions, they are input agnostic in the sense that you describe your function without declaring the type of argument that will be used when the function is eventually evaluated. At evaluation time, checks are performed to ensure the argument is compatible with the provided function. Likewise, the output returned by the evaluated function will be checked to ensure it is of the required form. If a check fails, an exception is thrown. Incompatible function input The example below demonstrates an incompatible input type. We will use the tempVar object created earlier, and attempt to evaluate it with a scalar input. This is not a valid operation, as tempVar is a MeshVariable type object and therefore can only be successfully evaluated at a valid domain coordinate, and therefore requires a vector input (the coordinate!). We will also use the min() function to set a lower bound (of zero) on the function's returned results. positiveTemp = fn.misc.min(0.,tempVar) try: positiveTemp.evaluate((0.1,)) except RuntimeError as e: print(\"RuntimeError: \"+str(e)) RuntimeError: Issue utilising function of class 'MeshVariable' constructed at: Line 8 of notebook cell 1: tempVar = mesh.add_variable(1) Error message: Function input dimensionality (1) does not appear to match mesh variable dimensionality (2). Let's deconstruct this error message. The second part specifies the actual problem that was encountered, in this case the input being a scalar where a vector was required. The first part tells you where the function that cannot be evaluated was defined. This is useful information because often you will define a function in a very different place to where you will eventually evaluate it. More importantly, complex functions are usually defined through numerous Python calls (as in this case where we introduce min() ), so we try to flag to you the actual subfunction that was problematic (in this case tempVar , not min ). Functions can of course only be evaluated at a point within their domain. So for MeshVariable objects, you may only evaluate at a coordinate within the mesh domain. Furthermore, in parallel, you may only evaluate within the mesh domain local to the process: try: positiveTemp.evaluate((-1.0,1.0)) # but the failure will occur at evaluation time. except ValueError as e: print(\"RuntimeError: \"+str(e)) RuntimeError: Issue utilising function of class 'MeshVariable' constructed at: Line 8 of notebook cell 1: tempVar = mesh.add_variable(1) Error message: FeVariable interpolation at location (-1, 1) does not appear to be valid. Location is probably outside local domain. SwarmVariable objects are purely discrete (they do not carry interpolation functions as do their MeshVariable counterpart), so their domain is the set of all particles coordinates. As such, an arbitrary coordinate cannot be used as an input. However due to algorithmic considerations, it is also not possible to feed in the coordinate of a particle for evaluation, and instead you must use the special FunctionInput class for evaluations, which we will explore shortly. swarm = uw.swarm.Swarm(mesh) svar = swarm.add_variable('double',1) swarm.populate_using_layout(uw.swarm.layouts.PerCellSpaceFillerLayout(swarm,1)) try: svar.evaluate((0.2,0.3)) except RuntimeError as e: print(\"RuntimeError: \"+str(e)) RuntimeError: Issue utilising function of class 'SwarmVariable' constructed at: Line 2 of notebook cell 11: svar = swarm.add_variable('double',1) Error message: Unable to evaluate function using provided input. Note that your function is constructed using a SwarmVariable. We do not currently support interpolation of SwarmVariables, so where you wish to `evaluate()` a SwarmVariable based function, you may only do so using the swarm itself as the input to the function evaluation, resulting in evaluation at each particle location. Note also that for evaluation, you must use the Swarm object from which the SwarmVariable was derived. Alternatively, you may wish to project your function onto a MeshVariable (using a MeshVariable_Projection object) and then perform interpolation on the MeshVariable object. Incompatible function output All functions require inputs of a certain form, and also return results of a (generally different) form. The object that is performing the evaluation then utilises these outputs for its given task. In the following example, we are trying to visualise a function using the Surface visualisation object. This object generates a raster image representing the provided function, with a single colour mapped to a given scalar function result. As such, while the function is successfully evaluated in the following, it returns a vector result where a scalar is required. # the `Surface` object can only visualise scalar objects fig = glucifer.Figure() try: fig.append(glucifer.objects.Surface(mesh,vecvar)) # failure will occur here except RuntimeError as e: print(\"RuntimeError: \"+str(e)) RuntimeError: Provided function must return a scalar result. Function are dynamic Functions are dynamic in the sense that they do not capture a static representation of their constituent functions at definition time, but instead simply refer to these functions at evaluation time. This means that if any of the constituent functions change (such as when you update your velocity field), these changes are reflected immediately: # create mesh var and init to 1. meshvar = mesh.add_variable(1) meshvar.data[:] = 1. # now create a function which utilises the mesh var and evaluate evaluation_coord = (0.1,0.2) fn_test = meshvar * 5. result_before = fn_test.evaluate(evaluation_coord) # now modify the meshvar and evaluate the fn again meshvar.data[:] = -1. result_after = fn_test.evaluate(evaluation_coord) print(result_before,result_after) (array([[ 5.]]), array([[-5.]])) Module Overview The user is encouraged to drill down interactively into submodules to discover all available functionality. Documentation and examples are provided via class docstrings. A general overview of the top level is provided here: Submodules: analytic : Analytic solution functions. branching : Functions which provide branching type behaviour. exception : Functions which raise exceptions under certain conditions. math : Basic mathematics functions. misc : Miscellaneous other functions. rheology : Functions which perform rheology specific behaviours. shape : Functions which perform geometric operations. tensor : Functions which perform operations on tensor functions. view : Functions which only observe function evaluations without modifying results. Classes: coord : This function is an alias to the input() function. input : This is the identity function. It simply returns its input. Function : The Function base class. FunctionInput : The FunctionInput base class. The evaluate() Method Once you have created functions, you will pass these into various objects within the Underworld2 API, however you will often also wish to directly evaluate the functions you have created for analytic or testing purposes. The evaluate() method provides this capability. Here are some basic examples using the function created previously: # evaluate at single location, provide as a coordinate tuple or list. result = fn_k.evaluate( (0.3,0.2) ) print( \"Single evaluation result = \\n{}\\n\".format(result)) # evaluate at a set of locations, provide these as a numpy array. import numpy as np count = 10 # create an empty array locations = np.zeros( (count,2) ) # specify evaluation coodinates locations[:,0] = 0.5 locations[:,1] = np.linspace(0.,1.,count) # evaluate result = fn_k.evaluate(locations) print( \"Multi evaluation result = \\n{}\".format(result)) Single evaluation result = [[ 26.74625463]] Multi evaluation result = [[ 13. ] [ 18.94327199] [ 29.30185422] [ 47.3559204 ] [ 78.82251482] [ 133.66592538] [ 229.25299916] [ 395.8525702 ] [ 686.22046174] [ 1192.30527282]] The FunctionInput class A further type of input to function evaluation are FunctionInput class objects. These are shortcuts to their underlying data, but leverage the fundamental object data for higher efficiency evaluations, and sometimes as a necessity to facilitate the evaluation. Currently provided FunctionInput classes include: underworld.mesh.FeMesh : Evaluation at all mesh vertex coordinates. underworld.mesh.FeMesh_IndexSet : Evaluation at the mesh vertex coordinates within the set. underworld.swarm.Swarm : Evaluation at all swarm particle coordinates. underworld.swarm.VoronoiIntegrationSwarm : Evaluation at all voronoi swarm particle coordinates. The above behave as FunctionInput classes by way of the multiple inheritence mechanisms of Python. For example, mesh objects (ie, objects of class FeMesh ) are also FunctionInput objects. Note that you will get identical evaluation results using the entire mesh vertex Numpy array as evaluation input, or using the mesh directly as an input: # first lets confirm that mesh is indeed a `FunctionInput` object if not isinstance(mesh, fn.FunctionInput): raise RuntimeError(\"Error! The mesh does not appear to be an instance of the `FunctionInput` class.\") # now evaluate at all mesh vertices: results_using_functioninput = fn_k.evaluate(mesh) # likewise, let's do the numpy equivalent results_using_numpy = fn_k.evaluate(mesh.data) # confirm identical results if not np.allclose( results_using_functioninput, results_using_numpy ): raise RuntimeError(\"Error! Results differ where they should be the same.\") Note that the FeMesh_IndexSet which contains all mesh vertices should also return identical results: # first create the 'empty' set allindices = mesh.specialSets['Empty'] # now invert to obtain the 'full' set allindices.invert() # evaluate results_using_indexset = fn_k.evaluate(allindices) # again confirm identical results if not np.allclose( results_using_functioninput, results_using_indexset ): raise RuntimeError(\"Error! Results differ where they should be the same.\") While all the above methods yield the same numerical results, note that there are efficiency differences. When you provide a Numpy array as input to a MeshVariable object evaluation, it is first necessary to determine which element the evaluation coordinate belongs to, which can be an expensive operation (in particular for deformed mesh). Once the owning element is determined, the interpolation itself needs to be calculated. However, when using the mesh object directly as a function input, the evaluation leverages higher level object information to directly extract the nodal values (ie, owning element and interpolation are not required). Consider the following timing results: # first evaluate directly using mesh %timeit tempVar.evaluate(mesh) 1000 loops, best of 3: 877 \u00b5s per loop # now evaluate via numpy array %timeit tempVar.evaluate(mesh.data) 100 loops, best of 3: 3.44 ms per loop # now flag the mesh as deformed. note that we are not # moving any mesh vertices, but simply flagging the # mesh as deformed. with mesh.deform_mesh(): pass %timeit fn_k.evaluate(mesh.data) mesh.reset() # reset the mesh for future operations 10 loops, best of 3: 82 ms per loop So we see that there isn't a dramatic difference until the mesh is deformed . Note also that as we haven't truly deformed the mesh, the observed result will generally be the best case scenario. The other important FunctionInput objects are the swarm based items. In the case of functions which utilise SwarmVariable objects, these are the only option for evaluation from within Python. This is because particles are inherently discrete, and therefore evaluation at arbitrary locations is not directly possible. In some case where you supply SwarmVariable functions to be used within Underworld operations (such as a viscosity for the Stokes system), a nearest neighbour calculation is implicitly utilised, however these mechanisms are not (yet) exposed for calls to the evaluate() method. Future releases will provide greater functionality for operating over SwarmVariable functions. Again, simply pass the swarm to the evaluate function to utilse the swarm FunctionInput behaviour: # first add a swarm to the existing mesh and populate swarm = uw.swarm.Swarm(mesh) swarm.populate_using_layout( uw.swarm.layouts.PerCellSpaceFillerLayout(swarm,20) ) # add variable to use for conductivity k_var = swarm.add_variable('double',1) # now initialise these particles to have values which correspond to those # provided by fn_k. we can use either `swarm` or `swarm.data` as inputs # here and the results in this case will be identical. k_var.data[:] = fn_k.evaluate(swarm) # note that k_var is itself of the `Function` class if not isinstance(k_var, fn.Function): raise RuntimeError(\"Error! Swarm variable does not appear to be of `Function` class\") # now try to evaluate at arbitrary location # k_var.evaluate( (0.3,0.2) ) # this will raise a RuntimeError! # now evaluate using swarm results_using_swarm_k_var = k_var.evaluate( swarm ) # also evaluate fn_k using swarm results_using_swarm_fn_k = fn_k.evaluate( swarm ) if not np.allclose( results_using_swarm_fn_k, results_using_swarm_fn_k ): raise RuntimeError(\"Error! These arrays should have identical values.\") The input function The function.input class simply provides the identity function. It returns whatever values are passed to it! # create the input class/function fn_input = fn.input() # confirm behaviour print(fn_input.evaluate( 2. ) ) print(fn_input.evaluate( ((0.2), (0.3)) )) print(fn_input.evaluate( ((0.2), (0.3), (0.4)) )) print(fn_input.evaluate( mesh.data[0:5] )) if not np.allclose(mesh.data, fn_input.evaluate(mesh.data)): raise RuntimeError(\"Error! These arrays should have identical values.\") [[ 2.]] [[ 0.2 0.3]] [[ 0.2 0.3 0.4]] [[ 0. 0. ] [ 0.03125 0. ] [ 0.0625 0. ] [ 0.09375 0. ] [ 0.125 0. ]] The input function is most often used when you wish to construct functions which operate over a particular coordinate axis: # Create sinusoidal function in the horizontal direction. # Note that the square brackets operator is overloaded to extract # a certain axis' value from vector functions. fn_sin = fn.math.sin(8.*np.pi*fn_input[0]) # take a look fig = glucifer.Figure(figsize=(800,400)) fig.append(glucifer.objects.Surface(mesh,fn_sin)) fig.show() We also provide an alias to this class in function.coord . This is strictly a Python alias, and is identical in all ways (except name!) to function.input . It is provided because we often use the input function to operate on coordinate values (as above), but it is worth noting that function inputs are certainly not restricted to coordinates or vectors, and in these cases it would be misleading to use the coord function. Branching Functions Branching functions are functions which nest other functions, and select which function to execute based on some condition (also expressed as a function!). The most common use case for branching functions are for defining materials within your model which exhibit different behaviours (based on their associated function). Note that Underworld2 does not include an explict 'material' construct (unlike Underworld1), however the equivalent functionality may be obtained through branching functions. Two branching functions are currently provided: function.branching.map : Key/value type mapping of behavior. function.branching.conditional : if/elif type behaviour. Refer to respective API documentation for further information on these function classes. The map function is usually used to construct material type behaviours. Note that the map function provides a subset of the conditional function behaviour, though it has performance advantages. Let us construct a basic model with material type behaviours: # setup a mesh and swarm mesh = uw.mesh.FeMesh_Cartesian(elementRes=(64,32),minCoord=(-2.0, -1.0), maxCoord=(2.0, 1.0)) swarm = uw.swarm.Swarm(mesh) swarm.populate_using_layout(uw.swarm.layouts.PerCellSpaceFillerLayout(swarm,80)) # add a variable which will act as the key function for the map function. material_index = swarm.add_variable(\"int\",1) # add the following for convenience and clarity. outside_circle = 0 inside_circle = 1 # initialise material_index to be outside_circle everywhere material_index.data[:] = outside_circle # now set to inside_circle where inside circle! r2 = 0.8 for index, position in enumerate(swarm.particleCoordinates.data): if position[0]**2 + position[1]**2 < r2: material_index.data[index] = inside_circle # create mapped behaviour dictionary fn_z = fn.input()[1] map_dict = { outside_circle:fn_z, inside_circle:fn_sin } # create function fn_map = fn.branching.map( fn_key = material_index, mapping = map_dict ) # viz fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Points(swarm,fn_map, pointSize=1.5) ) fig.show() Alternatively, we can achieve an identical result using the conditional function, and its evaluate() method: # the 'position' variable (created above) retains a reference to the # particleCoordinates numpy array. this inteferes with adding a new # swarm variable, so we must delete it. del position # add a new variable first (we will test later for equality) material_index2 = swarm.add_variable(\"int\",1) # first define a function which returns true if inside the circle coord = fn.input() fn_in_circle = fn.math.dot(coord,coord) < r2 # note the overload of the '<' operator # now create the conditional fn_conditional = fn.branching.conditional( ( (fn_in_circle, inside_circle), ( True, outside_circle) ) ) # use the evaluate, writing the results out to the material_index2 material_index2.data[:] = fn_conditional.evaluate(swarm) # check to ensure that we have identical results if not (material_index2.data == material_index.data).all(): raise RuntimeError(\"Error! These arrays should have identical values.\")","title":"Functions"},{"location":"UserGuide/04_Functions.html#functions","text":"Function class objects provide the building blocks for mathematical expression within Underworld2. The primary aim of this class is to enable a natural description of mathematics through the Python syntax so that users may quickly and accurately prototype model behaviour. Functions are used extensively across the Underworld2 API and provide a unified interface to Underworld2 discrete objects ( SwarmVariable and MeshVariable objects). Overview: A simple example. Usage basics. Module overview. The evaluate() method. The input function. Branching functions. Keywords: functions, swarms, meshvariables, materials","title":"Functions"},{"location":"UserGuide/04_Functions.html#a-simple-example","text":"Let us define a function which we might use as a variable heat conductivity for a thermal problem. It will take the following temperature dependent form: k(\\mathbf{x}) = 5 +8\\exp({5T(\\mathbf{x})}) k(\\mathbf{x}) = 5 +8\\exp({5T(\\mathbf{x})}) import os import underworld as uw from underworld import function as fn import glucifer # first create a mesh and variable mesh = uw.mesh.FeMesh_Cartesian(elementRes=(64,64), maxCoord=(2.,1.)) tempVar = mesh.add_variable(1) # init the temp variable for index,coord in enumerate(mesh.data): tempVar.data[index] = coord[1] # and now define the function. fn_k = 5. + 8.*fn.math.exp(5.*tempVar) # a # vis fig = glucifer.Figure(figsize=(800,400)) fig.append(glucifer.objects.Surface(mesh,fn_k)) # b fig.show() # c Let's deconstruct the Function defined at step (a) above: fn_k = 5. # 1 + 8.* # 2 fn.math.exp( # 3 5.*temp ) # 4 Things to note at the positions above: You can directly use Python native numerical objects. Under the hood, the native Python float object created here ' 5. ' will be automatically converted to an Underworld2 Constant type function. Note that arithmetic operations only currently support float type objects, and an exception will be thrown for other types. For this reason, you often need to be careful where you use Python natives (for instance, using ' 5 ' here instead of ' 5. ' would result in an error). Again, the native ' 8. ' will be automatically converted. The addition operator here will be automatically converted to an Underworld Addition operation through operator overloading. Likewise for the multiplication operation. Note that for an exponential function, we need to use the Underworld provided fn.math.exp function, not the Python math module exp function. Here the argument ( 5.*temp ) is itself a Function , and Function compounding applies. Importantly, note that the MeshVariable is used directly in the arithmetic, and this is possible because it is also a Function class object (more on this soon). At step (b), we provide the function to the visualisation object ( Surface ). Function objects are expected in many places across the Underworld2 API. Finally, at step (c), the actually function evaluation occurs, though under the hood it is a two step process. In the first step, tests are performed to ensure that the provided function is compatible with the required operation. Compatibility is dependent on a number of factors which we discuss below ('Conformal input & output checking'), and if there are any problems an exception will be raised here to notify the user. The second step is the required function evaluation, and will generally be the most compuationally expensive phase.","title":"A Simple Example"},{"location":"UserGuide/04_Functions.html#usage-basics","text":"","title":"Usage basics"},{"location":"UserGuide/04_Functions.html#underworld-data-objects","text":"As seen in the example above, Underworld data objects ( MeshVariable and SwarmVariable types) may be used directly within functions, as they are indeed themselves Function objects (via Python multiple inheritance). The Function class provides a uniform interface to these objects and is (largely) agnostic to the underlying data discretisation, instead providing mechanisms for evaluation at arbitrary coordinates. Note that true arbitrary coordinate evaluation is not possible for SwarmVariable objects, as they are purely discrete and do not (currently) have supporting interpolation functions. The special case inputs provided by objects of the FunctionInput class may be used for SwarmVariable objects (more on this soon). The following simple example demonstrates querying a MeshVariable object. # create a new mesh variable sinvar = mesh.add_variable(1) # initialise with a sine perturbation import numpy as np sinvar.data[:,0] = np.sin( np.pi*mesh.data[:,0] ) # use the `evaluate()` method to perform query.. more on this below result = sinvar.evaluate( (0.25,0.) ) print(\"Evaluation result: {}\".format(result)) Evaluation result: [[ 0.70710678]] # Let's define a test which we will use to ensure we're getting the correct numbers: def test( result, expected ): if not np.allclose(result, expected, rtol=2e-2, atol=2e-2 ): raise RuntimeError(\"Error! Expected result was not obtained.\") # use test import math test(result,math.sqrt(2.)/2.)","title":"Underworld data objects"},{"location":"UserGuide/04_Functions.html#elementary-algebraic-operations","text":"Use the Python equivalents ( + , - , * , / ) directly with your Function objects! Function objects are operator overloaded to facilitate this. Note however that only functions which return floating point type values are compatible with elementary operations currently, and an exception will be raised otherwise. Let's have a play with some mesh variables initialised to constants. # create some more mesh variables and initialise two_var = mesh.add_variable(1) six_var = mesh.add_variable(1) two_var.data[:] = 2. six_var.data[:] = 6. # create some functions via the Python operators fn_plus = two_var + six_var fn_minus = two_var - six_var fn_div = two_var / six_var fn_times = two_var * six_var # check results.. evaluate anywhere as our mesh variables are constant coord = (0.1234, 0.5678) resultplus = fn_plus.evaluate( coord ) resultminus = fn_minus.evaluate( coord ) resultdiv = fn_div.evaluate( coord ) resulttimes = fn_times.evaluate( coord ) print(\"Addition result : {}\".format(resultplus)) print(\"Subtraction result : {}\".format(resultminus)) print(\"Division result : {}\".format(resultdiv)) print(\"Multiplication result: {}\".format(resulttimes)) # run tests test(resultplus, 8.) test(resultminus,-4.) test(resultdiv, 1./3.) test(resulttimes, 12.) Addition result : [[ 8.]] Subtraction result : [[-4.]] Division result : [[ 0.33333333]] Multiplication result: [[ 12.]]","title":"Elementary algebraic operations"},{"location":"UserGuide/04_Functions.html#convenience-conversions","text":"Python elementary types (int/floats/etc) may be used directly with Underworld Function objects in algebraic operations. Likewise, Python tuples (or lists) of Underworld Functions are automatically converted into Function objects which return vector results composed of the tuple/list entries. It is often important to remember that the elementary algebraic operations are only compatible with float type objects, and therefore you will often need to write ' 5. ' (which will be converted to a double precision float object) instead of ' 5 ' (which will be converted to a integer object). # create a new mesh variable and initialise with cosine data cosvar = mesh.add_variable(1) cosvar.data[:,0] = np.cos( np.pi*mesh.data[:,0] ) # create function. note that `2.` and the `1.` are automatically converted sin2 = 2.*sinvar*cosvar + 1. # evaluate somewhere and then test import random coord = ( random.random(), 0. ) result = sin2.evaluate(coord) expected = math.sin(2.*math.pi*coord[0]) + 1. # via double angle formula test(result, expected) # also let's create a vector function on the fly. # first create a vector mesh variable vecvar = mesh.add_variable(2) vecvar.data[:] = (1.,1.) # now the function definition, evaluation, and test fn_vec = vecvar + (sinvar, cosvar) result = fn_vec.evaluate(coord) expected = (math.sin(math.pi*coord[0]) + 1., math.cos(math.pi*coord[0]) + 1.) test(result,expected) Note that conversions can only occur automatically where the Python object (tuple or primary math object) comes in contact with an Underworld function, whereby conversion occurs by virtue of the object overloading. However, occasionally we may wish to explicitly perform conversions, generally where we wish to use the evaluate() method or when we wish to utilise overloading. The convert() static method on the Function class provides this functionality: vec_as_py_tuple = (sinvar, cosvar) print(\"`vec_as_py_tuple` type is: {}\".format(type(vec_as_py_tuple))) # this will not work! # vec_as_py_tuple.evaluate() vec_as_uw_fn = fn.Function.convert(vec_as_py_tuple) print(\"`vec_as_uw_fn` type is: {}\".format(type(vec_as_uw_fn))) # this is better print(\"evaluate: {}\".format(vec_as_uw_fn.evaluate(coord))) `vec_as_py_tuple` type is: <type 'tuple'> `vec_as_uw_fn` type is: <class 'underworld.function._function.add'> evaluate: [[ 0.36876784 0.92885861]]","title":"Convenience conversions"},{"location":"UserGuide/04_Functions.html#basic-mathematical-functions","text":"Basic functions (such as sin() and exp() ) are provided by the underworld.function.math module. Note that the Python math module is not compatible with Underworld2 functions (you must use our math module). Operator overloads are also provided from the indexing operator ( [] ) and the power operator ( ** ). We will construct some more double angle formula here. While in the previous example, we used Numpy to initialise a mesh variable object to construct sin and cos like functions, here all mathematical operations will be performed by Underworld Function objects. # trig funcs sin = fn.math.sin() cos = fn.math.cos() tan = fn.math.tan() # double angle formula sin_2theta = 2.*sin*cos cos_2theta = 1. - 2.*sin**2 tan_2theta = (2.*tan)/(1.-tan**2) # get somewhere to evaluate theta = random.random() # do things check out? test( sin_2theta.evaluate(theta), math.sin(2*theta) ) test( cos_2theta.evaluate(theta), math.cos(2*theta) ) test( tan_2theta.evaluate(theta), math.tan(2*theta) )","title":"Basic mathematical functions"},{"location":"UserGuide/04_Functions.html#relational-and-logical-functions","text":"Relational functions are constructed via the Python relational operators ( < , <= , > , >= ). Underworld functions for AND , OR and XOR logical operations are also available, and these overload the Python bitwise operators ( & , | , ^ ) (though they do not perform bitwise operations). These functions will all return boolean results. # define a logical function for inside a unit circle. # we will use the `input()` function as a proxy for the coordinate (see below). radius = 1. coord = fn.input() inside_circle = ( coord[0]**2 + coord[1]**2 < radius**2 ) # test at some locations test( inside_circle.evaluate( (0. ,0. ) ), True ) test( inside_circle.evaluate( (1. ,1. ) ), False ) test( inside_circle.evaluate( (0.5,0.5) ), True ) test( inside_circle.evaluate( (0.9,0.5) ), False ) # now something a bit more complex.. first, some circles radius = 0.25 offset = (1.0,0.5) deltax = radius*math.cos(math.pi/4.) deltay = radius*math.sin(math.pi/4.) coord1 = fn.input() - offset circle1 = ( fn.math.dot(coord1,coord1) < radius**2 ) coord2 = coord1 - ( deltax, deltay) circle2 = ( fn.math.dot(coord2,coord2) < radius**2 ) coord3 = coord1 - (-deltax, deltay) circle3 = ( fn.math.dot(coord3,coord3) < radius**2 ) coord4 = coord1 - ( deltax,-deltay) circle4 = ( fn.math.dot(coord4,coord4) < radius**2 ) coord5 = coord1 - (-deltax,-deltay) circle5 = ( fn.math.dot(coord5,coord5) < radius**2 ) # now create a cross.. note the use of the OR operator cross = ( (fn.math.abs(coord1[0])<radius/2.) | (fn.math.abs(coord1[1])<radius/2.) ) # visualise the XOR of these shapes fig = glucifer.Figure(figsize=(800,400)) fig.append(glucifer.objects.Surface(mesh, circle1^circle2^circle3^circle4^circle5^cross, resolution=600, onMesh=False, colours=['white','blue'])) fig.show()","title":"Relational and logical functions"},{"location":"UserGuide/04_Functions.html#conformal-input-output-checking","text":"When you define your functions, they are input agnostic in the sense that you describe your function without declaring the type of argument that will be used when the function is eventually evaluated. At evaluation time, checks are performed to ensure the argument is compatible with the provided function. Likewise, the output returned by the evaluated function will be checked to ensure it is of the required form. If a check fails, an exception is thrown.","title":"Conformal input &amp; output checking"},{"location":"UserGuide/04_Functions.html#incompatible-function-input","text":"The example below demonstrates an incompatible input type. We will use the tempVar object created earlier, and attempt to evaluate it with a scalar input. This is not a valid operation, as tempVar is a MeshVariable type object and therefore can only be successfully evaluated at a valid domain coordinate, and therefore requires a vector input (the coordinate!). We will also use the min() function to set a lower bound (of zero) on the function's returned results. positiveTemp = fn.misc.min(0.,tempVar) try: positiveTemp.evaluate((0.1,)) except RuntimeError as e: print(\"RuntimeError: \"+str(e)) RuntimeError: Issue utilising function of class 'MeshVariable' constructed at: Line 8 of notebook cell 1: tempVar = mesh.add_variable(1) Error message: Function input dimensionality (1) does not appear to match mesh variable dimensionality (2). Let's deconstruct this error message. The second part specifies the actual problem that was encountered, in this case the input being a scalar where a vector was required. The first part tells you where the function that cannot be evaluated was defined. This is useful information because often you will define a function in a very different place to where you will eventually evaluate it. More importantly, complex functions are usually defined through numerous Python calls (as in this case where we introduce min() ), so we try to flag to you the actual subfunction that was problematic (in this case tempVar , not min ). Functions can of course only be evaluated at a point within their domain. So for MeshVariable objects, you may only evaluate at a coordinate within the mesh domain. Furthermore, in parallel, you may only evaluate within the mesh domain local to the process: try: positiveTemp.evaluate((-1.0,1.0)) # but the failure will occur at evaluation time. except ValueError as e: print(\"RuntimeError: \"+str(e)) RuntimeError: Issue utilising function of class 'MeshVariable' constructed at: Line 8 of notebook cell 1: tempVar = mesh.add_variable(1) Error message: FeVariable interpolation at location (-1, 1) does not appear to be valid. Location is probably outside local domain. SwarmVariable objects are purely discrete (they do not carry interpolation functions as do their MeshVariable counterpart), so their domain is the set of all particles coordinates. As such, an arbitrary coordinate cannot be used as an input. However due to algorithmic considerations, it is also not possible to feed in the coordinate of a particle for evaluation, and instead you must use the special FunctionInput class for evaluations, which we will explore shortly. swarm = uw.swarm.Swarm(mesh) svar = swarm.add_variable('double',1) swarm.populate_using_layout(uw.swarm.layouts.PerCellSpaceFillerLayout(swarm,1)) try: svar.evaluate((0.2,0.3)) except RuntimeError as e: print(\"RuntimeError: \"+str(e)) RuntimeError: Issue utilising function of class 'SwarmVariable' constructed at: Line 2 of notebook cell 11: svar = swarm.add_variable('double',1) Error message: Unable to evaluate function using provided input. Note that your function is constructed using a SwarmVariable. We do not currently support interpolation of SwarmVariables, so where you wish to `evaluate()` a SwarmVariable based function, you may only do so using the swarm itself as the input to the function evaluation, resulting in evaluation at each particle location. Note also that for evaluation, you must use the Swarm object from which the SwarmVariable was derived. Alternatively, you may wish to project your function onto a MeshVariable (using a MeshVariable_Projection object) and then perform interpolation on the MeshVariable object.","title":"Incompatible function input"},{"location":"UserGuide/04_Functions.html#incompatible-function-output","text":"All functions require inputs of a certain form, and also return results of a (generally different) form. The object that is performing the evaluation then utilises these outputs for its given task. In the following example, we are trying to visualise a function using the Surface visualisation object. This object generates a raster image representing the provided function, with a single colour mapped to a given scalar function result. As such, while the function is successfully evaluated in the following, it returns a vector result where a scalar is required. # the `Surface` object can only visualise scalar objects fig = glucifer.Figure() try: fig.append(glucifer.objects.Surface(mesh,vecvar)) # failure will occur here except RuntimeError as e: print(\"RuntimeError: \"+str(e)) RuntimeError: Provided function must return a scalar result.","title":"Incompatible function output"},{"location":"UserGuide/04_Functions.html#function-are-dynamic","text":"Functions are dynamic in the sense that they do not capture a static representation of their constituent functions at definition time, but instead simply refer to these functions at evaluation time. This means that if any of the constituent functions change (such as when you update your velocity field), these changes are reflected immediately: # create mesh var and init to 1. meshvar = mesh.add_variable(1) meshvar.data[:] = 1. # now create a function which utilises the mesh var and evaluate evaluation_coord = (0.1,0.2) fn_test = meshvar * 5. result_before = fn_test.evaluate(evaluation_coord) # now modify the meshvar and evaluate the fn again meshvar.data[:] = -1. result_after = fn_test.evaluate(evaluation_coord) print(result_before,result_after) (array([[ 5.]]), array([[-5.]]))","title":"Function are dynamic"},{"location":"UserGuide/04_Functions.html#module-overview","text":"The user is encouraged to drill down interactively into submodules to discover all available functionality. Documentation and examples are provided via class docstrings. A general overview of the top level is provided here:","title":"Module Overview"},{"location":"UserGuide/04_Functions.html#submodules","text":"analytic : Analytic solution functions. branching : Functions which provide branching type behaviour. exception : Functions which raise exceptions under certain conditions. math : Basic mathematics functions. misc : Miscellaneous other functions. rheology : Functions which perform rheology specific behaviours. shape : Functions which perform geometric operations. tensor : Functions which perform operations on tensor functions. view : Functions which only observe function evaluations without modifying results.","title":"Submodules:"},{"location":"UserGuide/04_Functions.html#classes","text":"coord : This function is an alias to the input() function. input : This is the identity function. It simply returns its input. Function : The Function base class. FunctionInput : The FunctionInput base class.","title":"Classes:"},{"location":"UserGuide/04_Functions.html#the-evaluate-method","text":"Once you have created functions, you will pass these into various objects within the Underworld2 API, however you will often also wish to directly evaluate the functions you have created for analytic or testing purposes. The evaluate() method provides this capability. Here are some basic examples using the function created previously: # evaluate at single location, provide as a coordinate tuple or list. result = fn_k.evaluate( (0.3,0.2) ) print( \"Single evaluation result = \\n{}\\n\".format(result)) # evaluate at a set of locations, provide these as a numpy array. import numpy as np count = 10 # create an empty array locations = np.zeros( (count,2) ) # specify evaluation coodinates locations[:,0] = 0.5 locations[:,1] = np.linspace(0.,1.,count) # evaluate result = fn_k.evaluate(locations) print( \"Multi evaluation result = \\n{}\".format(result)) Single evaluation result = [[ 26.74625463]] Multi evaluation result = [[ 13. ] [ 18.94327199] [ 29.30185422] [ 47.3559204 ] [ 78.82251482] [ 133.66592538] [ 229.25299916] [ 395.8525702 ] [ 686.22046174] [ 1192.30527282]]","title":"The evaluate() Method"},{"location":"UserGuide/04_Functions.html#the-functioninput-class","text":"A further type of input to function evaluation are FunctionInput class objects. These are shortcuts to their underlying data, but leverage the fundamental object data for higher efficiency evaluations, and sometimes as a necessity to facilitate the evaluation. Currently provided FunctionInput classes include: underworld.mesh.FeMesh : Evaluation at all mesh vertex coordinates. underworld.mesh.FeMesh_IndexSet : Evaluation at the mesh vertex coordinates within the set. underworld.swarm.Swarm : Evaluation at all swarm particle coordinates. underworld.swarm.VoronoiIntegrationSwarm : Evaluation at all voronoi swarm particle coordinates. The above behave as FunctionInput classes by way of the multiple inheritence mechanisms of Python. For example, mesh objects (ie, objects of class FeMesh ) are also FunctionInput objects. Note that you will get identical evaluation results using the entire mesh vertex Numpy array as evaluation input, or using the mesh directly as an input: # first lets confirm that mesh is indeed a `FunctionInput` object if not isinstance(mesh, fn.FunctionInput): raise RuntimeError(\"Error! The mesh does not appear to be an instance of the `FunctionInput` class.\") # now evaluate at all mesh vertices: results_using_functioninput = fn_k.evaluate(mesh) # likewise, let's do the numpy equivalent results_using_numpy = fn_k.evaluate(mesh.data) # confirm identical results if not np.allclose( results_using_functioninput, results_using_numpy ): raise RuntimeError(\"Error! Results differ where they should be the same.\") Note that the FeMesh_IndexSet which contains all mesh vertices should also return identical results: # first create the 'empty' set allindices = mesh.specialSets['Empty'] # now invert to obtain the 'full' set allindices.invert() # evaluate results_using_indexset = fn_k.evaluate(allindices) # again confirm identical results if not np.allclose( results_using_functioninput, results_using_indexset ): raise RuntimeError(\"Error! Results differ where they should be the same.\") While all the above methods yield the same numerical results, note that there are efficiency differences. When you provide a Numpy array as input to a MeshVariable object evaluation, it is first necessary to determine which element the evaluation coordinate belongs to, which can be an expensive operation (in particular for deformed mesh). Once the owning element is determined, the interpolation itself needs to be calculated. However, when using the mesh object directly as a function input, the evaluation leverages higher level object information to directly extract the nodal values (ie, owning element and interpolation are not required). Consider the following timing results: # first evaluate directly using mesh %timeit tempVar.evaluate(mesh) 1000 loops, best of 3: 877 \u00b5s per loop # now evaluate via numpy array %timeit tempVar.evaluate(mesh.data) 100 loops, best of 3: 3.44 ms per loop # now flag the mesh as deformed. note that we are not # moving any mesh vertices, but simply flagging the # mesh as deformed. with mesh.deform_mesh(): pass %timeit fn_k.evaluate(mesh.data) mesh.reset() # reset the mesh for future operations 10 loops, best of 3: 82 ms per loop So we see that there isn't a dramatic difference until the mesh is deformed . Note also that as we haven't truly deformed the mesh, the observed result will generally be the best case scenario. The other important FunctionInput objects are the swarm based items. In the case of functions which utilise SwarmVariable objects, these are the only option for evaluation from within Python. This is because particles are inherently discrete, and therefore evaluation at arbitrary locations is not directly possible. In some case where you supply SwarmVariable functions to be used within Underworld operations (such as a viscosity for the Stokes system), a nearest neighbour calculation is implicitly utilised, however these mechanisms are not (yet) exposed for calls to the evaluate() method. Future releases will provide greater functionality for operating over SwarmVariable functions. Again, simply pass the swarm to the evaluate function to utilse the swarm FunctionInput behaviour: # first add a swarm to the existing mesh and populate swarm = uw.swarm.Swarm(mesh) swarm.populate_using_layout( uw.swarm.layouts.PerCellSpaceFillerLayout(swarm,20) ) # add variable to use for conductivity k_var = swarm.add_variable('double',1) # now initialise these particles to have values which correspond to those # provided by fn_k. we can use either `swarm` or `swarm.data` as inputs # here and the results in this case will be identical. k_var.data[:] = fn_k.evaluate(swarm) # note that k_var is itself of the `Function` class if not isinstance(k_var, fn.Function): raise RuntimeError(\"Error! Swarm variable does not appear to be of `Function` class\") # now try to evaluate at arbitrary location # k_var.evaluate( (0.3,0.2) ) # this will raise a RuntimeError! # now evaluate using swarm results_using_swarm_k_var = k_var.evaluate( swarm ) # also evaluate fn_k using swarm results_using_swarm_fn_k = fn_k.evaluate( swarm ) if not np.allclose( results_using_swarm_fn_k, results_using_swarm_fn_k ): raise RuntimeError(\"Error! These arrays should have identical values.\")","title":"The FunctionInput class"},{"location":"UserGuide/04_Functions.html#the-input-function","text":"The function.input class simply provides the identity function. It returns whatever values are passed to it! # create the input class/function fn_input = fn.input() # confirm behaviour print(fn_input.evaluate( 2. ) ) print(fn_input.evaluate( ((0.2), (0.3)) )) print(fn_input.evaluate( ((0.2), (0.3), (0.4)) )) print(fn_input.evaluate( mesh.data[0:5] )) if not np.allclose(mesh.data, fn_input.evaluate(mesh.data)): raise RuntimeError(\"Error! These arrays should have identical values.\") [[ 2.]] [[ 0.2 0.3]] [[ 0.2 0.3 0.4]] [[ 0. 0. ] [ 0.03125 0. ] [ 0.0625 0. ] [ 0.09375 0. ] [ 0.125 0. ]] The input function is most often used when you wish to construct functions which operate over a particular coordinate axis: # Create sinusoidal function in the horizontal direction. # Note that the square brackets operator is overloaded to extract # a certain axis' value from vector functions. fn_sin = fn.math.sin(8.*np.pi*fn_input[0]) # take a look fig = glucifer.Figure(figsize=(800,400)) fig.append(glucifer.objects.Surface(mesh,fn_sin)) fig.show() We also provide an alias to this class in function.coord . This is strictly a Python alias, and is identical in all ways (except name!) to function.input . It is provided because we often use the input function to operate on coordinate values (as above), but it is worth noting that function inputs are certainly not restricted to coordinates or vectors, and in these cases it would be misleading to use the coord function.","title":"The input function"},{"location":"UserGuide/04_Functions.html#branching-functions","text":"Branching functions are functions which nest other functions, and select which function to execute based on some condition (also expressed as a function!). The most common use case for branching functions are for defining materials within your model which exhibit different behaviours (based on their associated function). Note that Underworld2 does not include an explict 'material' construct (unlike Underworld1), however the equivalent functionality may be obtained through branching functions. Two branching functions are currently provided: function.branching.map : Key/value type mapping of behavior. function.branching.conditional : if/elif type behaviour. Refer to respective API documentation for further information on these function classes. The map function is usually used to construct material type behaviours. Note that the map function provides a subset of the conditional function behaviour, though it has performance advantages. Let us construct a basic model with material type behaviours: # setup a mesh and swarm mesh = uw.mesh.FeMesh_Cartesian(elementRes=(64,32),minCoord=(-2.0, -1.0), maxCoord=(2.0, 1.0)) swarm = uw.swarm.Swarm(mesh) swarm.populate_using_layout(uw.swarm.layouts.PerCellSpaceFillerLayout(swarm,80)) # add a variable which will act as the key function for the map function. material_index = swarm.add_variable(\"int\",1) # add the following for convenience and clarity. outside_circle = 0 inside_circle = 1 # initialise material_index to be outside_circle everywhere material_index.data[:] = outside_circle # now set to inside_circle where inside circle! r2 = 0.8 for index, position in enumerate(swarm.particleCoordinates.data): if position[0]**2 + position[1]**2 < r2: material_index.data[index] = inside_circle # create mapped behaviour dictionary fn_z = fn.input()[1] map_dict = { outside_circle:fn_z, inside_circle:fn_sin } # create function fn_map = fn.branching.map( fn_key = material_index, mapping = map_dict ) # viz fig = glucifer.Figure(figsize=(800,400)) fig.append( glucifer.objects.Points(swarm,fn_map, pointSize=1.5) ) fig.show() Alternatively, we can achieve an identical result using the conditional function, and its evaluate() method: # the 'position' variable (created above) retains a reference to the # particleCoordinates numpy array. this inteferes with adding a new # swarm variable, so we must delete it. del position # add a new variable first (we will test later for equality) material_index2 = swarm.add_variable(\"int\",1) # first define a function which returns true if inside the circle coord = fn.input() fn_in_circle = fn.math.dot(coord,coord) < r2 # note the overload of the '<' operator # now create the conditional fn_conditional = fn.branching.conditional( ( (fn_in_circle, inside_circle), ( True, outside_circle) ) ) # use the evaluate, writing the results out to the material_index2 material_index2.data[:] = fn_conditional.evaluate(swarm) # check to ensure that we have identical results if not (material_index2.data == material_index.data).all(): raise RuntimeError(\"Error! These arrays should have identical values.\")","title":"Branching Functions"},{"location":"UserGuide/05_Systems.html","text":"Systems and Solvers Numerous dynamic systems are implemented in Underworld. They may be found within the systems submodule. Classes are documented with examples using Python docstrings and doctests. This information is available directly in the Python interpreter (using the help() builtin function). However, the rendered version of docstrings is generally more useful, and is available at the Underworld Read the Docs page: http://underworld2.readthedocs.io/en/latest/underworld.systems.html#underworld.systems.Stokes","title":"Systems"},{"location":"UserGuide/05_Systems.html#systems-and-solvers","text":"Numerous dynamic systems are implemented in Underworld. They may be found within the systems submodule. Classes are documented with examples using Python docstrings and doctests. This information is available directly in the Python interpreter (using the help() builtin function). However, the rendered version of docstrings is generally more useful, and is available at the Underworld Read the Docs page: http://underworld2.readthedocs.io/en/latest/underworld.systems.html#underworld.systems.Stokes","title":"Systems and Solvers"},{"location":"UserGuide/06_Utilities.html","text":"Utilities Overview: Integrals. Checkpointing. Generating XDMF files. Keywords: checkpointing, utilities, volume integrals, surface integrals, xdmf Integral Class The Integral class constructs the volume integral F_{i} = \\int_V \\, f_i(\\mathbf{x}) \\, \\mathrm{d} V F_{i} = \\int_V \\, f_i(\\mathbf{x}) \\, \\mathrm{d} V for some function f_i f_i (specified by a Function object), over some domain V V (specified by an FeMesh object), or the surface integral F_{i} = \\oint_{\\Gamma} \\, f_i(\\mathbf{x}) \\, \\mathrm{d}\\Gamma F_{i} = \\oint_{\\Gamma} \\, f_i(\\mathbf{x}) \\, \\mathrm{d}\\Gamma for some surface \\Gamma \\Gamma (specified via an IndexSet object on the mesh). # setup some objects for demonstration import underworld as uw from underworld import function as fn import glucifer import math # setup required objects mesh = uw.mesh.FeMesh_Cartesian(minCoord=(-1,-1), elementRes=(32,32)) temperatureField = mesh.add_variable( 1 ) velocityField = mesh.add_variable( 2 ) # init temperatureField.data[:,0] = -mesh.data[:,1]/2. + 0.5 velocityField.data[:,0] = -mesh.data[:,1] velocityField.data[:,1] = mesh.data[:,0] # viz fig1 = glucifer.Figure() velmagfield = uw.function.math.sqrt( uw.function.math.dot( velocityField, velocityField ) ) fig1.append( glucifer.objects.VectorArrows(mesh, velocityField, arrowHead=0.2, scaling=0.1) ) fig1.append( glucifer.objects.Surface( mesh, temperatureField ) ) fig1.show() In the following example, we will calculate a root mean square velocity defined as: $$ v_{rms} = \\sqrt{ \\frac{ \\int_V (\\mathbf{v}.\\mathbf{v}) \\, \\mathrm{d}V } {\\int_V \\, \\mathrm{d}V} } $$ The same result can be achieved through a number of paths. Call the integrate() method on a Function object. Call the integrate() method on an FeMesh object. Create an Integral class object, and call its integrate() method. Note that all three methods result in identical calculations. # define required function vdotv = fn.math.dot( velocityField, velocityField ) # evaluate area (domain) integrals on the function # 2 methods available v2sum_1 = vdotv.integrate( mesh ) # ... option 1 v2sum_2 = mesh.integrate( vdotv ) # ... option 2 volume = mesh.integrate( 1.0 ) # finally, calculate RMS v_rms = math.sqrt( v2sum_1[0] )/volume[0] print('Option 1 - RMS velocity = {0:.3f}'.format(v_rms)) v_rms = math.sqrt( v2sum_2[0] )/volume[0] print('Option 2 - RMS velocity = {0:.3f}'.format(v_rms)) Option 1 - RMS velocity = 0.408 Option 2 - RMS velocity = 0.408 # option 3 # create integral objects, passing in functions v2sum_integral = uw.utils.Integral( mesh=mesh, fn=vdotv ) volume_integral = uw.utils.Integral( mesh=mesh, fn=1. ) # evaluate integrals v2sum = v2sum_integral.evaluate() volume = volume_integral.evaluate() # finally, calculate RMS v_rms = math.sqrt( v2sum[0] )/volume[0] print('RMS velocity = {0:.3f}'.format(v_rms)) RMS velocity = 0.408 To evaluate an integral over a subdomain the fn.branching.conditional class may be useful: # create circle function radius = 1. coord = fn.coord() fn_sphere = fn.math.dot( coord, coord ) < radius**2 # setup a function that is 1 if the coordinates, are inside the circle, and zero otherwise. conditions = [ ( fn_sphere , 1.0), ( True , 0.0) ] kernelFunction = fn.branching.conditional( conditions ) # create and evaluate integral volume = mesh.integrate( kernelFunction ) print('Area from integral = {0:6.8e}'.format(volume[0])) Area from integral = 3.14559221e+00 In the following example, we will calculate the Nusselt number defined by Nu = -h \\frac{ \\oint_{\\Gamma_{t}} \\partial_z T (\\mathbf{x}) \\, \\mathrm{d}\\Gamma}{ \\int_{\\Gamma_{b}} T (\\mathbf{x}) \\, \\mathrm{d}\\Gamma} Nu = -h \\frac{ \\oint_{\\Gamma_{t}} \\partial_z T (\\mathbf{x}) \\, \\mathrm{d}\\Gamma}{ \\int_{\\Gamma_{b}} T (\\mathbf{x}) \\, \\mathrm{d}\\Gamma} where h h is the height of the domain, and \\Gamma_t \\Gamma_t and \\Gamma_b \\Gamma_b are the top and bottom surfaces respectively. NB. Surface integrals must still be implemented using the old implementation mesh of creating a uw.utils.Integral object nuTop = uw.utils.Integral( fn=temperatureField.fn_gradient[1], mesh=mesh, integrationType='Surface', surfaceIndexSet=mesh.specialSets[\"MaxJ_VertexSet\"]) nuBottom = uw.utils.Integral( fn=temperatureField, mesh=mesh, integrationType='Surface', surfaceIndexSet=mesh.specialSets[\"MinJ_VertexSet\"]) Once again we activate these integrals using the evaluate function. nu = - nuTop.evaluate()[0]/nuBottom.evaluate()[0] print('Nusselt number = {0:.6f}'.format(nu)) Nusselt number = 0.500000 Checkpointing Checkpointing is the process of saving sufficient data to facilitate restarting your simulations at a later stage. Note that we do not provide explicit checkpointing functionality, but instead provide the tools required for the loading and saving of heavy data. Which data items are required for restart will depend on the systems you have used and how you have constructed your models. The following Underworld data structures have load/save functionality: * SwarmVariables * Swarm * MeshVariables * Mesh All files are saved in HDF5 format. Note : When saving a SwarmVariable , if you wish to reload the SwarmVariable data at a later stage, you must also save the Swarm for the corresponding state (generally, the same timestep). This requirement is due to the population control mechanisms swarms generally used for swarms, and also due to particles crossing process boundaries. When you come to reload the Swarm and SwarmVariable , you must load the Swarm first . Note again that the Swarm and SwarmVariable must be of corresponding state for successful reload. outputPath = 'checkpointing/' # Make output directory if necessary import os if uw.rank()==0: if not os.path.exists(outputPath): os.makedirs(outputPath) SwarmVariable Below a Swarm and a SwarmVariable , are created and saved to disk, then a new swarm loads the data from disk. Save the swarm data to disk using the save() method on the Swarm and SwarmVariable objects. Note the handle object that is returned from the save() method. This is currently used for xdmf() operation, see below. Load the swarm data from disk using the load() method on the Swarm and SwarmVariable objects swarm1 = uw.swarm.Swarm(mesh) swarm1var = swarm1.add_variable(dataType='int', count=1) layout = uw.swarm.layouts.PerCellSpaceFillerLayout(swarm1,particlesPerCell=5) swarm1.populate_using_layout(layout) # evaluate kernalFunction for each particle in swarm1, record result in swarmvar1 swarm1var.data[:] = kernelFunction.evaluate(swarm1.particleCoordinates.data) fig = glucifer.Figure() fig.append( glucifer.objects.Mesh(mesh) ) fig.append( glucifer.objects.Points(swarm1, fn_colour=swarm1var, pointSize=6.0 ) ) fig.show() s1Hnd = swarm1.save(outputPath+'swarm.h5') s1vHnd = swarm1var.save(outputPath+'swarmvar.h5') # new swarm swarm2 = uw.swarm.Swarm(mesh) swarm2var = swarm2.add_variable(dataType='int', count=1) swarm2.load(outputPath+'swarm.h5') swarm2var.load(outputPath+'swarmvar.h5') import numpy as np print \"Are the swarm variables close? ...\", np.allclose( swarm2var.data[:], swarm1var.data[:] ) print \"Are the swarm particle coordinates close? ... \", np.allclose( swarm2.particleCoordinates.data[:], swarm1.particleCoordinates.data[:]) Are the swarm variables close? ... True Are the swarm particle coordinates close? ... True ** MeshVariables ** The MeshVariable object behaves similarly to SwarmVariable object with the save() and load() functionality. mHnd = mesh.save(outputPath+'mesh.h5') velHnd = velocityField.save(outputPath+'velocity.h5', mHnd) # 2nd arg, mHnd, is optional newField = mesh.add_variable( nodeDofCount=velocityField.nodeDofCount ) newField.load(outputPath+'velocity.h5') print \"Are the mesh variables close ? ...\", np.allclose( newField.data, velocityField.data ) Are the mesh variables close ? ... True Writing to XDMF files The XDMF file format brings together data and geometric information in a format the can be viewed with ParaView . The handlers that were returned after the save() operations above specify this information in hdf5 format. * data as MeshVariable and SwarmVariable * geometric as the Mesh and Swarm The handlers are passed to Underworld's XDMF methods, along with textual names to give the Variable in the .xdmf file. velocityField.xdmf(outputPath+'velocity.xdmf', velHnd, \"MyField\", mHnd, \"TheMesh\", modeltime=0.0) swarm1var.xdmf(outputPath+'swarmvar.xdmf', s1vHnd, \"SwarmVariable\", s1Hnd, \"TheSwarm\", modeltime=0.1) Write XDMF file For more details on using XDMF write and to see it in a dynamical simulation context, see the example 1_06_Rayleigh_Taylor . if uw.rank() == 0: import os if os.path.exists(outputPath): os.remove(outputPath+'mesh.h5') os.remove(outputPath+'velocity.h5') os.remove(outputPath+'swarm.h5') os.remove(outputPath+'swarmvar.h5') os.remove(outputPath+'velocity.xdmf') os.remove(outputPath+'swarmvar.xdmf') os.rmdir(outputPath)","title":"Utilities"},{"location":"UserGuide/06_Utilities.html#utilities","text":"Overview: Integrals. Checkpointing. Generating XDMF files. Keywords: checkpointing, utilities, volume integrals, surface integrals, xdmf","title":"Utilities"},{"location":"UserGuide/06_Utilities.html#integral-class","text":"The Integral class constructs the volume integral F_{i} = \\int_V \\, f_i(\\mathbf{x}) \\, \\mathrm{d} V F_{i} = \\int_V \\, f_i(\\mathbf{x}) \\, \\mathrm{d} V for some function f_i f_i (specified by a Function object), over some domain V V (specified by an FeMesh object), or the surface integral F_{i} = \\oint_{\\Gamma} \\, f_i(\\mathbf{x}) \\, \\mathrm{d}\\Gamma F_{i} = \\oint_{\\Gamma} \\, f_i(\\mathbf{x}) \\, \\mathrm{d}\\Gamma for some surface \\Gamma \\Gamma (specified via an IndexSet object on the mesh). # setup some objects for demonstration import underworld as uw from underworld import function as fn import glucifer import math # setup required objects mesh = uw.mesh.FeMesh_Cartesian(minCoord=(-1,-1), elementRes=(32,32)) temperatureField = mesh.add_variable( 1 ) velocityField = mesh.add_variable( 2 ) # init temperatureField.data[:,0] = -mesh.data[:,1]/2. + 0.5 velocityField.data[:,0] = -mesh.data[:,1] velocityField.data[:,1] = mesh.data[:,0] # viz fig1 = glucifer.Figure() velmagfield = uw.function.math.sqrt( uw.function.math.dot( velocityField, velocityField ) ) fig1.append( glucifer.objects.VectorArrows(mesh, velocityField, arrowHead=0.2, scaling=0.1) ) fig1.append( glucifer.objects.Surface( mesh, temperatureField ) ) fig1.show() In the following example, we will calculate a root mean square velocity defined as: $$ v_{rms} = \\sqrt{ \\frac{ \\int_V (\\mathbf{v}.\\mathbf{v}) \\, \\mathrm{d}V } {\\int_V \\, \\mathrm{d}V} } $$ The same result can be achieved through a number of paths. Call the integrate() method on a Function object. Call the integrate() method on an FeMesh object. Create an Integral class object, and call its integrate() method. Note that all three methods result in identical calculations. # define required function vdotv = fn.math.dot( velocityField, velocityField ) # evaluate area (domain) integrals on the function # 2 methods available v2sum_1 = vdotv.integrate( mesh ) # ... option 1 v2sum_2 = mesh.integrate( vdotv ) # ... option 2 volume = mesh.integrate( 1.0 ) # finally, calculate RMS v_rms = math.sqrt( v2sum_1[0] )/volume[0] print('Option 1 - RMS velocity = {0:.3f}'.format(v_rms)) v_rms = math.sqrt( v2sum_2[0] )/volume[0] print('Option 2 - RMS velocity = {0:.3f}'.format(v_rms)) Option 1 - RMS velocity = 0.408 Option 2 - RMS velocity = 0.408 # option 3 # create integral objects, passing in functions v2sum_integral = uw.utils.Integral( mesh=mesh, fn=vdotv ) volume_integral = uw.utils.Integral( mesh=mesh, fn=1. ) # evaluate integrals v2sum = v2sum_integral.evaluate() volume = volume_integral.evaluate() # finally, calculate RMS v_rms = math.sqrt( v2sum[0] )/volume[0] print('RMS velocity = {0:.3f}'.format(v_rms)) RMS velocity = 0.408 To evaluate an integral over a subdomain the fn.branching.conditional class may be useful: # create circle function radius = 1. coord = fn.coord() fn_sphere = fn.math.dot( coord, coord ) < radius**2 # setup a function that is 1 if the coordinates, are inside the circle, and zero otherwise. conditions = [ ( fn_sphere , 1.0), ( True , 0.0) ] kernelFunction = fn.branching.conditional( conditions ) # create and evaluate integral volume = mesh.integrate( kernelFunction ) print('Area from integral = {0:6.8e}'.format(volume[0])) Area from integral = 3.14559221e+00 In the following example, we will calculate the Nusselt number defined by Nu = -h \\frac{ \\oint_{\\Gamma_{t}} \\partial_z T (\\mathbf{x}) \\, \\mathrm{d}\\Gamma}{ \\int_{\\Gamma_{b}} T (\\mathbf{x}) \\, \\mathrm{d}\\Gamma} Nu = -h \\frac{ \\oint_{\\Gamma_{t}} \\partial_z T (\\mathbf{x}) \\, \\mathrm{d}\\Gamma}{ \\int_{\\Gamma_{b}} T (\\mathbf{x}) \\, \\mathrm{d}\\Gamma} where h h is the height of the domain, and \\Gamma_t \\Gamma_t and \\Gamma_b \\Gamma_b are the top and bottom surfaces respectively. NB. Surface integrals must still be implemented using the old implementation mesh of creating a uw.utils.Integral object nuTop = uw.utils.Integral( fn=temperatureField.fn_gradient[1], mesh=mesh, integrationType='Surface', surfaceIndexSet=mesh.specialSets[\"MaxJ_VertexSet\"]) nuBottom = uw.utils.Integral( fn=temperatureField, mesh=mesh, integrationType='Surface', surfaceIndexSet=mesh.specialSets[\"MinJ_VertexSet\"]) Once again we activate these integrals using the evaluate function. nu = - nuTop.evaluate()[0]/nuBottom.evaluate()[0] print('Nusselt number = {0:.6f}'.format(nu)) Nusselt number = 0.500000","title":"Integral Class"},{"location":"UserGuide/06_Utilities.html#checkpointing","text":"Checkpointing is the process of saving sufficient data to facilitate restarting your simulations at a later stage. Note that we do not provide explicit checkpointing functionality, but instead provide the tools required for the loading and saving of heavy data. Which data items are required for restart will depend on the systems you have used and how you have constructed your models. The following Underworld data structures have load/save functionality: * SwarmVariables * Swarm * MeshVariables * Mesh All files are saved in HDF5 format. Note : When saving a SwarmVariable , if you wish to reload the SwarmVariable data at a later stage, you must also save the Swarm for the corresponding state (generally, the same timestep). This requirement is due to the population control mechanisms swarms generally used for swarms, and also due to particles crossing process boundaries. When you come to reload the Swarm and SwarmVariable , you must load the Swarm first . Note again that the Swarm and SwarmVariable must be of corresponding state for successful reload. outputPath = 'checkpointing/' # Make output directory if necessary import os if uw.rank()==0: if not os.path.exists(outputPath): os.makedirs(outputPath) SwarmVariable Below a Swarm and a SwarmVariable , are created and saved to disk, then a new swarm loads the data from disk. Save the swarm data to disk using the save() method on the Swarm and SwarmVariable objects. Note the handle object that is returned from the save() method. This is currently used for xdmf() operation, see below. Load the swarm data from disk using the load() method on the Swarm and SwarmVariable objects swarm1 = uw.swarm.Swarm(mesh) swarm1var = swarm1.add_variable(dataType='int', count=1) layout = uw.swarm.layouts.PerCellSpaceFillerLayout(swarm1,particlesPerCell=5) swarm1.populate_using_layout(layout) # evaluate kernalFunction for each particle in swarm1, record result in swarmvar1 swarm1var.data[:] = kernelFunction.evaluate(swarm1.particleCoordinates.data) fig = glucifer.Figure() fig.append( glucifer.objects.Mesh(mesh) ) fig.append( glucifer.objects.Points(swarm1, fn_colour=swarm1var, pointSize=6.0 ) ) fig.show() s1Hnd = swarm1.save(outputPath+'swarm.h5') s1vHnd = swarm1var.save(outputPath+'swarmvar.h5') # new swarm swarm2 = uw.swarm.Swarm(mesh) swarm2var = swarm2.add_variable(dataType='int', count=1) swarm2.load(outputPath+'swarm.h5') swarm2var.load(outputPath+'swarmvar.h5') import numpy as np print \"Are the swarm variables close? ...\", np.allclose( swarm2var.data[:], swarm1var.data[:] ) print \"Are the swarm particle coordinates close? ... \", np.allclose( swarm2.particleCoordinates.data[:], swarm1.particleCoordinates.data[:]) Are the swarm variables close? ... True Are the swarm particle coordinates close? ... True ** MeshVariables ** The MeshVariable object behaves similarly to SwarmVariable object with the save() and load() functionality. mHnd = mesh.save(outputPath+'mesh.h5') velHnd = velocityField.save(outputPath+'velocity.h5', mHnd) # 2nd arg, mHnd, is optional newField = mesh.add_variable( nodeDofCount=velocityField.nodeDofCount ) newField.load(outputPath+'velocity.h5') print \"Are the mesh variables close ? ...\", np.allclose( newField.data, velocityField.data ) Are the mesh variables close ? ... True","title":"Checkpointing"},{"location":"UserGuide/06_Utilities.html#writing-to-xdmf-files","text":"The XDMF file format brings together data and geometric information in a format the can be viewed with ParaView . The handlers that were returned after the save() operations above specify this information in hdf5 format. * data as MeshVariable and SwarmVariable * geometric as the Mesh and Swarm The handlers are passed to Underworld's XDMF methods, along with textual names to give the Variable in the .xdmf file. velocityField.xdmf(outputPath+'velocity.xdmf', velHnd, \"MyField\", mHnd, \"TheMesh\", modeltime=0.0) swarm1var.xdmf(outputPath+'swarmvar.xdmf', s1vHnd, \"SwarmVariable\", s1Hnd, \"TheSwarm\", modeltime=0.1) Write XDMF file For more details on using XDMF write and to see it in a dynamical simulation context, see the example 1_06_Rayleigh_Taylor . if uw.rank() == 0: import os if os.path.exists(outputPath): os.remove(outputPath+'mesh.h5') os.remove(outputPath+'velocity.h5') os.remove(outputPath+'swarm.h5') os.remove(outputPath+'swarmvar.h5') os.remove(outputPath+'velocity.xdmf') os.remove(outputPath+'swarmvar.xdmf') os.rmdir(outputPath)","title":"Writing to XDMF files"},{"location":"UserGuide/07_Visualisation.html","text":"Visualisation The glucifer module provides visualisation capabilities for Underworld modelling. This notebook demonstrates: setting up figure objects drawing meshes, surfaces, points and vector arrows saving figures to file publication ready figures interactive viewer Keywords: visualisation, glucifer, 3D plots, interactive plots Note All classes and functions have corresponding docstrings which are available via the python help() function. import underworld as uw import glucifer The Figure The Figure class is the base container object for your glucifer visualisations. It provides the canvas to which you will add the renderings from your drawing objects. newfigure = glucifer.Figure() Drawing Objects Drawing objects are the items that are rendered within a Figure . Available drawing objects (and associated documentation) may be found within the glucifer.objects Rendered API documentation for glucifer objects may be found at: http://underworld2.readthedocs.io/en/latest/glucifer.objects.html Mesh Render mesh geometry and node indices. Note, the append() method is used to attach this drawing object to a figure object lists of drawing objects. # create mesh and display it mesh = uw.mesh.FeMesh_Cartesian( 'Q1', (2,2), (0.,0.), (1.,1.) ) fig = glucifer.Figure ( edgecolour=\"black\") fig.Mesh( mesh, nodeNumbers=True ) fig.show() Surface This object will draw the desired faces of a scalar field. Check help(Surface) for the full options of the Surface drawing object. # create an object with a single value at each mesh point fevar = mesh.add_variable( 1 ) # give the variable some values fevar.data[:] = 0. fevar.data[0] = 10. fevar.data[4] = 30. fevar.data[8] = 10. fig = glucifer.Figure ( edgecolour=\"black\" ) fig.Surface( mesh, fevar, colours=\"red yellow green\", onMesh=False ) fig.show() VectorArrows This object will draw an array of vector arrows across the image using the provided vector field to determine their direction. Check help(VectorArrows) for the full options of the VectorArrows drawing object. # create a new meshvariable (note that it has 2 values at each mesh point) fevarVec = mesh.add_variable( 2 ) # initialise the vector field to something fevarVec.data[:] = [ 0., 0.] fevarVec.data[0] = [ 1., 1.] fevarVec.data[1] = [ 0., 1.] fevarVec.data[2] = [-1., 1.] fevarVec.data[3] = [ 1., 0.] fevarVec.data[5] = [-1., 0.] fevarVec.data[6] = [ 1.,-1.] fevarVec.data[7] = [ 0.,-1.] fevarVec.data[8] = [-1.,-1.] Create and show vector arrow figure. fig = glucifer.Figure( edgecolour=\"black\" ) fig.VectorArrows( mesh, fevarVec, scaling=0.1, arrowHead=0.2 ) fig.show() Points This object will draw a swarm of points using the provided Underworld swarm for the point locations and an Underworld swarm variable for the point colours (or size or opacity). Check help(Points) for the full options of the Points drawing object. Firstly, create a swarm over the whole mesh with 200 particles per cell. swarm = uw.swarm.Swarm( mesh=mesh ) layout = uw.swarm.layouts.PerCellSpaceFillerLayout( swarm=swarm, particlesPerCell=200 ) swarm.populate_using_layout( layout ) Plot the swarm particle distribution. fig = glucifer.Figure( edgecolour=\"blue\" ) fig.Points( swarm=swarm, pointSize=5, colourBar = False ) fig.show() Now add a swarm variable to define the colour. swarmVar = swarm.add_variable(\"double\",1) swarmVar.data[:] = 0. swarmVar.data[200:400] = 1. swarmVar.data[400:600] = 2. swarmVar.data[600:800] = 3. someFn = uw.function.coord()[0] Since there are 4 cells and 200 per cell we can divide the swarm up into 4 equal sections and give each a different colour. These will be randomly distributed around the figure. The fn_colour argument in the points object asigns colours to each swarm particle depending on the variable swarmVar . fn_colour accepts Function objects too and is a powerful tool to quickly visualise a model setup. fig = glucifer.Figure( edgecolour=\"black\" ) fig.Points(swarm=swarm, fn_colour=swarmVar, pointSize=10, colours='black red green blue') fig.show() Image Layering Multiple drawing objects can, of course, be layered upon each other to build up complex images. This is achieved by making multiple calls append() fig = glucifer.Figure( edgecolour=\"black\" ) fig.VectorArrows( mesh, fevarVec, scaling=0.1, arrowHead=0.2, opacity=0.6 ) fig.Surface( mesh, fevar, colours=\"red yellow green\" ) fig.show() Saving Results To output results to raster files (such as PNG), simply use the savefig() method. figfile = fig.save_image(\"savedfigure\") import glob import os if figfile: print(glob.glob( figfile )) ['savedfigure.png'] Let's clean up the directory by deleting this output figure file. if figfile: os.remove( figfile ) Likewise, for those who wish to utilise the native viewer, the database object can be saved using the saveDB() method: fig.save_database(\"dbFile.gldb\") print(glob.glob(\"dbFile.gldb\")) ['dbFile.gldb'] Again, let's clean up the local directory. os.remove( \"dbFile.gldb\" ) Publication quality figures With minor modifications gLucifer figures are easily made publication ready. Firstly, let's increase the image quality with the \"quality\" parameter. Values can be 1 (low) to 3 (high), but note that higher values can take longer to render, especially for large images. Here we also set the margin around the edges of the plot and apply rulers with tick labels. fig = glucifer.Figure(title=\"Test Plot\", quality=3, margin=0.078, rulers=True, rulerticks=5) Modifying surface plots Setup surface plot with colour gradient contrast bias towards more red (fix red as the colour for the value 25.0 by preceding the colour with this value in brackets) and some transparency (append a colon and the transparency value to the colour). surf = fig.Surface( mesh, fevar, colours=\"red (25.0)yellow:0.8 green:0.5\") Alter the properties of the colour bar associated with the surface plot. Here we set the number of tick marks to 3 and the values of the first and third ticks, modify the margin and width and set the alignment to right (available values: left/right [vertical], bottom/top [horizontal]). surf.colourBar[\"ticks\"] = 3 surf.colourBar[\"position\"] = 0.1 surf.colourBar[\"size\"] = [0.8,0.04] surf.colourBar[\"tickvalues\"] = [10, 25] surf.colourBar[\"align\"] = \"right\" Adding floating labels Labels can be added by specifying the label text and position. Font size can also be set with the \"scaling\" parameter. A single font size applies to all labels on an object, so changing the font scaling of the default object will change all labels already added - to add a different sized label we attach it to a the surface object instead. #Plot a label to the default figure object (fig.draw) fig.draw.label(\"Label1 @ Centre\", (0.2,0.7,0)) #Plot a lable to a previously added object surf.label(\"Label2 @ Centre\", (0.2,0.3,0), scaling=1.25) Plot final figure to screen. This can also be saved to PNG/JPEG or a WebGL visualisation. fig.show() Save a high resolution image The save image function takes an optional output width and height parameter (if width is provided without height, it will be calculated automatically) fig.save_image(\"highdef.png\", (1600,0)) 'highdef.png' Interactivity & Scripting An interactive viewer can be opened from inside the notebook by importing the \"lavavu\" module and using the figure's window() method: fig = glucifer.Figure( edgecolour=\"black\", quality=3 ) fig.Surface( mesh, fevar, colours=\"red yellow green\", colourBar = False ) fig.VectorArrows( mesh, fevarVec, scaling=0.1, arrowHead=0.2) <glucifer.objects.VectorArrows at 0x7f7c367bcdd0> Once this interactive viewer is open we can either shift the view using the mouse, or we can send commands to shift the view from inside the notebook. if not glucifer.lavavu: raise KeyboardInterrupt #Stop notebook here if no vis enabled lv = fig.window() lv.rotate('y', 45) lv.redisplay() .lvctrl input { display: inline; } .lvctrl input[type=range] { width: 200px; } .lvctrl input[type=button] { width: 100px; } .lvctrl input[type=number] { width: 120px; height: 28px; border-radius: 0; border: 1px dotted #999;} .lvctrl pre { display: inline; } .lvctrl p { color: gray; margin: 0px} /* Colour select */ .colourbg {display: inline-block; margin:5px 0px; width: 100px; height: 20px; border: 1px dotted #999; } .colour {display: inline-block; width: 100%; height: 100%; margin: 0px; padding: 0px; border: none;} .checkerboard {background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAIElEQVQ4jWP4TwAcOHAAL2YYNWBYGEBIASEwasCwMAAALvidroqDalkAAAAASUVORK5CYII=\");} .palette { margin: 3px; border:1px solid #000; border: 1px dotted #000;} .lvtab { border: 1px solid #999; padding: 5px; } .lvtabbar { width:100%; overflow:hidden; margin-top: 5px; } .lvtabbar .lvtabbar-item { padding:4px 8px; float:left; width:auto; border:none; outline:none; display:block; } .lvtabbar .dropdown-hover,.lvtabbar .dropdown-click { position:static; float:left; } .lvtabbar .lvbutton { white-space:normal; } .lvbutton:hover { color:#000!important; background-color:#ccc!important; border: 1px solid #999; border-bottom: 0; } .lvbutton { border: 1px solid #999; border-bottom: 0; border-radius: 5px 5px 0px 0px; margin-right: 3px; display:inline-block; outline:0; padding:4px 8px; vertical-align:middle; overflow:hidden; text-decoration:none; color:inherit; background-color:inherit; text-align:center; cursor:pointer; white-space:nowrap; } .lvseltab,.hover-lvseltab:hover { color:#fff!important; background-color:#555!important; } precision highp float; varying vec4 vColour; void main(void) { gl_FragColor = vColour; } precision highp float; //Line vertex shader attribute vec3 aVertexPosition; uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform vec4 uColour; varying vec4 vColour; void main(void) { vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0); gl_Position = uPMatrix * mvPosition; vColour = uColour; } // gl-matrix 1.3.7 - https://github.com/toji/gl-matrix/blob/master/LICENSE.md (function(w,D){\"object\"===typeof exports?module.exports=D(global):\"function\"===false/*OK: removed require.js support.. typeof define&&define.amd*/?define([],function(){return D(w)}):D(w)})(this,function(w){function D(a){return o=a}function G(){return o=\"undefined\"!==typeof Float32Array?Float32Array:Array}var E={};(function(){if(\"undefined\"!=typeof Float32Array){var a=new Float32Array(1),b=new Int32Array(a.buffer);E.invsqrt=function(c){a[0]=c;b[0]=1597463007-(b[0]>>1);var d=a[0];return d*(1.5-0.5*c*d*d)}}else E.invsqrt=function(a){return 1/ Math.sqrt(a)}})();var o=null;G();var r={create:function(a){var b=new o(3);a?(b[0]=a[0],b[1]=a[1],b[2]=a[2]):b[0]=b[1]=b[2]=0;return b},createFrom:function(a,b,c){var d=new o(3);d[0]=a;d[1]=b;d[2]=c;return d},set:function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];return b},equal:function(a,b){return a===b||1.0E-6>Math.abs(a[0]-b[0])&&1.0E-6>Math.abs(a[1]-b[1])&&1.0E-6>Math.abs(a[2]-b[2])},add:function(a,b,c){if(!c||a===c)return a[0]+=b[0],a[1]+=b[1],a[2]+=b[2],a;c[0]=a[0]+b[0];c[1]=a[1]+b[1];c[2]=a[2]+b[2]; return c},subtract:function(a,b,c){if(!c||a===c)return a[0]-=b[0],a[1]-=b[1],a[2]-=b[2],a;c[0]=a[0]-b[0];c[1]=a[1]-b[1];c[2]=a[2]-b[2];return c},multiply:function(a,b,c){if(!c||a===c)return a[0]*=b[0],a[1]*=b[1],a[2]*=b[2],a;c[0]=a[0]*b[0];c[1]=a[1]*b[1];c[2]=a[2]*b[2];return c},negate:function(a,b){b||(b=a);b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];return b},scale:function(a,b,c){if(!c||a===c)return a[0]*=b,a[1]*=b,a[2]*=b,a;c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;return c},normalize:function(a,b){b||(b=a);var c= a[0],d=a[1],e=a[2],g=Math.sqrt(c*c+d*d+e*e);if(!g)return b[0]=0,b[1]=0,b[2]=0,b;if(1===g)return b[0]=c,b[1]=d,b[2]=e,b;g=1/g;b[0]=c*g;b[1]=d*g;b[2]=e*g;return b},cross:function(a,b,c){c||(c=a);var d=a[0],e=a[1],a=a[2],g=b[0],f=b[1],b=b[2];c[0]=e*b-a*f;c[1]=a*g-d*b;c[2]=d*f-e*g;return c},length:function(a){var b=a[0],c=a[1],a=a[2];return Math.sqrt(b*b+c*c+a*a)},squaredLength:function(a){var b=a[0],c=a[1],a=a[2];return b*b+c*c+a*a},dot:function(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]},direction:function(a, b,c){c||(c=a);var d=a[0]-b[0],e=a[1]-b[1],a=a[2]-b[2],b=Math.sqrt(d*d+e*e+a*a);if(!b)return c[0]=0,c[1]=0,c[2]=0,c;b=1/b;c[0]=d*b;c[1]=e*b;c[2]=a*b;return c},lerp:function(a,b,c,d){d||(d=a);d[0]=a[0]+c*(b[0]-a[0]);d[1]=a[1]+c*(b[1]-a[1]);d[2]=a[2]+c*(b[2]-a[2]);return d},dist:function(a,b){var c=b[0]-a[0],d=b[1]-a[1],e=b[2]-a[2];return Math.sqrt(c*c+d*d+e*e)}},H=null,y=new o(4);r.unproject=function(a,b,c,d,e){e||(e=a);H||(H=x.create());var g=H;y[0]=2*(a[0]-d[0])/d[2]-1;y[1]=2*(a[1]-d[1])/d[3]-1;y[2]= 2*a[2]-1;y[3]=1;x.multiply(c,b,g);if(!x.inverse(g))return null;x.multiplyVec4(g,y);if(0===y[3])return null;e[0]=y[0]/y[3];e[1]=y[1]/y[3];e[2]=y[2]/y[3];return e};var L=r.createFrom(1,0,0),M=r.createFrom(0,1,0),N=r.createFrom(0,0,1),z=r.create();r.rotationTo=function(a,b,c){c||(c=k.create());var d=r.dot(a,b);if(1<=d)k.set(O,c);else if(-0.999999>d)r.cross(L,a,z),1.0E-6>r.length(z)&&r.cross(M,a,z),1.0E-6>r.length(z)&&r.cross(N,a,z),r.normalize(z),k.fromAngleAxis(Math.PI,z,c);else{var d=Math.sqrt(2*(1+ d)),e=1/d;r.cross(a,b,z);c[0]=z[0]*e;c[1]=z[1]*e;c[2]=z[2]*e;c[3]=0.5*d;k.normalize(c)}1<c[3]?c[3]=1:-1>c[3]&&(c[3]=-1);return c};r.str=function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\"]\"};var A={create:function(a){var b=new o(9);a?(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3],b[4]=a[4],b[5]=a[5],b[6]=a[6],b[7]=a[7],b[8]=a[8]):b[0]=b[1]=b[2]=b[3]=b[4]=b[5]=b[6]=b[7]=b[8]=0;return b},createFrom:function(a,b,c,d,e,g,f,h,j){var i=new o(9);i[0]=a;i[1]=b;i[2]=c;i[3]=d;i[4]=e;i[5]=g;i[6]=f;i[7]=h;i[8]=j;return i}, determinant:function(a){var b=a[3],c=a[4],d=a[5],e=a[6],g=a[7],f=a[8];return a[0]*(f*c-d*g)+a[1]*(-f*b+d*e)+a[2]*(g*b-c*e)},inverse:function(a,b){var c=a[0],d=a[1],e=a[2],g=a[3],f=a[4],h=a[5],j=a[6],i=a[7],m=a[8],l=m*f-h*i,C=-m*g+h*j,q=i*g-f*j,n=c*l+d*C+e*q;if(!n)return null;n=1/n;b||(b=A.create());b[0]=l*n;b[1]=(-m*d+e*i)*n;b[2]=(h*d-e*f)*n;b[3]=C*n;b[4]=(m*c-e*j)*n;b[5]=(-h*c+e*g)*n;b[6]=q*n;b[7]=(-i*c+d*j)*n;b[8]=(f*c-d*g)*n;return b},multiply:function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2], f=a[3],h=a[4],j=a[5],i=a[6],m=a[7],a=a[8],l=b[0],C=b[1],q=b[2],n=b[3],k=b[4],p=b[5],o=b[6],s=b[7],b=b[8];c[0]=l*d+C*f+q*i;c[1]=l*e+C*h+q*m;c[2]=l*g+C*j+q*a;c[3]=n*d+k*f+p*i;c[4]=n*e+k*h+p*m;c[5]=n*g+k*j+p*a;c[6]=o*d+s*f+b*i;c[7]=o*e+s*h+b*m;c[8]=o*g+s*j+b*a;return c},multiplyVec2:function(a,b,c){c||(c=b);var d=b[0],b=b[1];c[0]=d*a[0]+b*a[3]+a[6];c[1]=d*a[1]+b*a[4]+a[7];return c},multiplyVec3:function(a,b,c){c||(c=b);var d=b[0],e=b[1],b=b[2];c[0]=d*a[0]+e*a[3]+b*a[6];c[1]=d*a[1]+e*a[4]+b*a[7];c[2]= d*a[2]+e*a[5]+b*a[8];return c},set:function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];return b},equal:function(a,b){return a===b||1.0E-6>Math.abs(a[0]-b[0])&&1.0E-6>Math.abs(a[1]-b[1])&&1.0E-6>Math.abs(a[2]-b[2])&&1.0E-6>Math.abs(a[3]-b[3])&&1.0E-6>Math.abs(a[4]-b[4])&&1.0E-6>Math.abs(a[5]-b[5])&&1.0E-6>Math.abs(a[6]-b[6])&&1.0E-6>Math.abs(a[7]-b[7])&&1.0E-6>Math.abs(a[8]-b[8])},identity:function(a){a||(a=A.create());a[0]=1;a[1]=0;a[2]=0;a[3]=0; a[4]=1;a[5]=0;a[6]=0;a[7]=0;a[8]=1;return a},transpose:function(a,b){if(!b||a===b){var c=a[1],d=a[2],e=a[5];a[1]=a[3];a[2]=a[6];a[3]=c;a[5]=a[7];a[6]=d;a[7]=e;return a}b[0]=a[0];b[1]=a[3];b[2]=a[6];b[3]=a[1];b[4]=a[4];b[5]=a[7];b[6]=a[2];b[7]=a[5];b[8]=a[8];return b},toMat4:function(a,b){b||(b=x.create());b[15]=1;b[14]=0;b[13]=0;b[12]=0;b[11]=0;b[10]=a[8];b[9]=a[7];b[8]=a[6];b[7]=0;b[6]=a[5];b[5]=a[4];b[4]=a[3];b[3]=0;b[2]=a[2];b[1]=a[1];b[0]=a[0];return b},str:function(a){return\"[\"+a[0]+\", \"+a[1]+ \", \"+a[2]+\", \"+a[3]+\", \"+a[4]+\", \"+a[5]+\", \"+a[6]+\", \"+a[7]+\", \"+a[8]+\"]\"}},x={create:function(a){var b=new o(16);a&&(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3],b[4]=a[4],b[5]=a[5],b[6]=a[6],b[7]=a[7],b[8]=a[8],b[9]=a[9],b[10]=a[10],b[11]=a[11],b[12]=a[12],b[13]=a[13],b[14]=a[14],b[15]=a[15]);return b},createFrom:function(a,b,c,d,e,g,f,h,j,i,m,l,C,q,n,k){var p=new o(16);p[0]=a;p[1]=b;p[2]=c;p[3]=d;p[4]=e;p[5]=g;p[6]=f;p[7]=h;p[8]=j;p[9]=i;p[10]=m;p[11]=l;p[12]=C;p[13]=q;p[14]=n;p[15]=k;return p},set:function(a, b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return b},equal:function(a,b){return a===b||1.0E-6>Math.abs(a[0]-b[0])&&1.0E-6>Math.abs(a[1]-b[1])&&1.0E-6>Math.abs(a[2]-b[2])&&1.0E-6>Math.abs(a[3]-b[3])&&1.0E-6>Math.abs(a[4]-b[4])&&1.0E-6>Math.abs(a[5]-b[5])&&1.0E-6>Math.abs(a[6]-b[6])&&1.0E-6>Math.abs(a[7]-b[7])&&1.0E-6>Math.abs(a[8]-b[8])&&1.0E-6>Math.abs(a[9]-b[9])&&1.0E-6> Math.abs(a[10]-b[10])&&1.0E-6>Math.abs(a[11]-b[11])&&1.0E-6>Math.abs(a[12]-b[12])&&1.0E-6>Math.abs(a[13]-b[13])&&1.0E-6>Math.abs(a[14]-b[14])&&1.0E-6>Math.abs(a[15]-b[15])},identity:function(a){a||(a=x.create());a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a},transpose:function(a,b){if(!b||a===b){var c=a[1],d=a[2],e=a[3],g=a[6],f=a[7],h=a[11];a[1]=a[4];a[2]=a[8];a[3]=a[12];a[4]=c;a[6]=a[9];a[7]=a[13];a[8]=d;a[9]=g;a[11]= a[14];a[12]=e;a[13]=f;a[14]=h;return a}b[0]=a[0];b[1]=a[4];b[2]=a[8];b[3]=a[12];b[4]=a[1];b[5]=a[5];b[6]=a[9];b[7]=a[13];b[8]=a[2];b[9]=a[6];b[10]=a[10];b[11]=a[14];b[12]=a[3];b[13]=a[7];b[14]=a[11];b[15]=a[15];return b},determinant:function(a){var b=a[0],c=a[1],d=a[2],e=a[3],g=a[4],f=a[5],h=a[6],j=a[7],i=a[8],m=a[9],l=a[10],C=a[11],q=a[12],n=a[13],k=a[14],a=a[15];return q*m*h*e-i*n*h*e-q*f*l*e+g*n*l*e+i*f*k*e-g*m*k*e-q*m*d*j+i*n*d*j+q*c*l*j-b*n*l*j-i*c*k*j+b*m*k*j+q*f*d*C-g*n*d*C-q*c*h*C+b*n*h*C+ g*c*k*C-b*f*k*C-i*f*d*a+g*m*d*a+i*c*h*a-b*m*h*a-g*c*l*a+b*f*l*a},inverse:function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=a[4],h=a[5],j=a[6],i=a[7],m=a[8],l=a[9],k=a[10],q=a[11],n=a[12],o=a[13],p=a[14],r=a[15],s=c*h-d*f,v=c*j-e*f,t=c*i-g*f,u=d*j-e*h,w=d*i-g*h,x=e*i-g*j,y=m*o-l*n,z=m*p-k*n,F=m*r-q*n,A=l*p-k*o,D=l*r-q*o,E=k*r-q*p,B=s*E-v*D+t*A+u*F-w*z+x*y;if(!B)return null;B=1/B;b[0]=(h*E-j*D+i*A)*B;b[1]=(-d*E+e*D-g*A)*B;b[2]=(o*x-p*w+r*u)*B;b[3]=(-l*x+k*w-q*u)*B;b[4]=(-f*E+j*F-i*z)*B;b[5]= (c*E-e*F+g*z)*B;b[6]=(-n*x+p*t-r*v)*B;b[7]=(m*x-k*t+q*v)*B;b[8]=(f*D-h*F+i*y)*B;b[9]=(-c*D+d*F-g*y)*B;b[10]=(n*w-o*t+r*s)*B;b[11]=(-m*w+l*t-q*s)*B;b[12]=(-f*A+h*z-j*y)*B;b[13]=(c*A-d*z+e*y)*B;b[14]=(-n*u+o*v-p*s)*B;b[15]=(m*u-l*v+k*s)*B;return b},toRotationMat:function(a,b){b||(b=x.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b},toMat3:function(a,b){b||(b=A.create());b[0]= a[0];b[1]=a[1];b[2]=a[2];b[3]=a[4];b[4]=a[5];b[5]=a[6];b[6]=a[8];b[7]=a[9];b[8]=a[10];return b},toInverseMat3:function(a,b){var c=a[0],d=a[1],e=a[2],g=a[4],f=a[5],h=a[6],j=a[8],i=a[9],m=a[10],l=m*f-h*i,k=-m*g+h*j,q=i*g-f*j,n=c*l+d*k+e*q;if(!n)return null;n=1/n;b||(b=A.create());b[0]=l*n;b[1]=(-m*d+e*i)*n;b[2]=(h*d-e*f)*n;b[3]=k*n;b[4]=(m*c-e*j)*n;b[5]=(-h*c+e*g)*n;b[6]=q*n;b[7]=(-i*c+d*j)*n;b[8]=(f*c-d*g)*n;return b},multiply:function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],f=a[3],h=a[4],j=a[5], i=a[6],m=a[7],l=a[8],k=a[9],q=a[10],n=a[11],o=a[12],p=a[13],r=a[14],a=a[15],s=b[0],v=b[1],t=b[2],u=b[3];c[0]=s*d+v*h+t*l+u*o;c[1]=s*e+v*j+t*k+u*p;c[2]=s*g+v*i+t*q+u*r;c[3]=s*f+v*m+t*n+u*a;s=b[4];v=b[5];t=b[6];u=b[7];c[4]=s*d+v*h+t*l+u*o;c[5]=s*e+v*j+t*k+u*p;c[6]=s*g+v*i+t*q+u*r;c[7]=s*f+v*m+t*n+u*a;s=b[8];v=b[9];t=b[10];u=b[11];c[8]=s*d+v*h+t*l+u*o;c[9]=s*e+v*j+t*k+u*p;c[10]=s*g+v*i+t*q+u*r;c[11]=s*f+v*m+t*n+u*a;s=b[12];v=b[13];t=b[14];u=b[15];c[12]=s*d+v*h+t*l+u*o;c[13]=s*e+v*j+t*k+u*p;c[14]=s*g+ v*i+t*q+u*r;c[15]=s*f+v*m+t*n+u*a;return c},multiplyVec3:function(a,b,c){c||(c=b);var d=b[0],e=b[1],b=b[2];c[0]=a[0]*d+a[4]*e+a[8]*b+a[12];c[1]=a[1]*d+a[5]*e+a[9]*b+a[13];c[2]=a[2]*d+a[6]*e+a[10]*b+a[14];return c},multiplyVec4:function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2],b=b[3];c[0]=a[0]*d+a[4]*e+a[8]*g+a[12]*b;c[1]=a[1]*d+a[5]*e+a[9]*g+a[13]*b;c[2]=a[2]*d+a[6]*e+a[10]*g+a[14]*b;c[3]=a[3]*d+a[7]*e+a[11]*g+a[15]*b;return c},translate:function(a,b,c){var d=b[0],e=b[1],b=b[2],g,f,h,j,i,m,l,k,q, n,o,p;if(!c||a===c)return a[12]=a[0]*d+a[4]*e+a[8]*b+a[12],a[13]=a[1]*d+a[5]*e+a[9]*b+a[13],a[14]=a[2]*d+a[6]*e+a[10]*b+a[14],a[15]=a[3]*d+a[7]*e+a[11]*b+a[15],a;g=a[0];f=a[1];h=a[2];j=a[3];i=a[4];m=a[5];l=a[6];k=a[7];q=a[8];n=a[9];o=a[10];p=a[11];c[0]=g;c[1]=f;c[2]=h;c[3]=j;c[4]=i;c[5]=m;c[6]=l;c[7]=k;c[8]=q;c[9]=n;c[10]=o;c[11]=p;c[12]=g*d+i*e+q*b+a[12];c[13]=f*d+m*e+n*b+a[13];c[14]=h*d+l*e+o*b+a[14];c[15]=j*d+k*e+p*b+a[15];return c},scale:function(a,b,c){var d=b[0],e=b[1],b=b[2];if(!c||a===c)return a[0]*= d,a[1]*=d,a[2]*=d,a[3]*=d,a[4]*=e,a[5]*=e,a[6]*=e,a[7]*=e,a[8]*=b,a[9]*=b,a[10]*=b,a[11]*=b,a;c[0]=a[0]*d;c[1]=a[1]*d;c[2]=a[2]*d;c[3]=a[3]*d;c[4]=a[4]*e;c[5]=a[5]*e;c[6]=a[6]*e;c[7]=a[7]*e;c[8]=a[8]*b;c[9]=a[9]*b;c[10]=a[10]*b;c[11]=a[11]*b;c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15];return c},rotate:function(a,b,c,d){var e=c[0],g=c[1],c=c[2],f=Math.sqrt(e*e+g*g+c*c),h,j,i,m,l,k,q,n,o,p,r,s,v,t,u,w,x,y,z,A;if(!f)return null;1!==f&&(f=1/f,e*=f,g*=f,c*=f);h=Math.sin(b);j=Math.cos(b);i=1-j;b=a[0]; f=a[1];m=a[2];l=a[3];k=a[4];q=a[5];n=a[6];o=a[7];p=a[8];r=a[9];s=a[10];v=a[11];t=e*e*i+j;u=g*e*i+c*h;w=c*e*i-g*h;x=e*g*i-c*h;y=g*g*i+j;z=c*g*i+e*h;A=e*c*i+g*h;e=g*c*i-e*h;g=c*c*i+j;d?a!==d&&(d[12]=a[12],d[13]=a[13],d[14]=a[14],d[15]=a[15]):d=a;d[0]=b*t+k*u+p*w;d[1]=f*t+q*u+r*w;d[2]=m*t+n*u+s*w;d[3]=l*t+o*u+v*w;d[4]=b*x+k*y+p*z;d[5]=f*x+q*y+r*z;d[6]=m*x+n*y+s*z;d[7]=l*x+o*y+v*z;d[8]=b*A+k*e+p*g;d[9]=f*A+q*e+r*g;d[10]=m*A+n*e+s*g;d[11]=l*A+o*e+v*g;return d},rotateX:function(a,b,c){var d=Math.sin(b), b=Math.cos(b),e=a[4],g=a[5],f=a[6],h=a[7],j=a[8],i=a[9],m=a[10],l=a[11];c?a!==c&&(c[0]=a[0],c[1]=a[1],c[2]=a[2],c[3]=a[3],c[12]=a[12],c[13]=a[13],c[14]=a[14],c[15]=a[15]):c=a;c[4]=e*b+j*d;c[5]=g*b+i*d;c[6]=f*b+m*d;c[7]=h*b+l*d;c[8]=e*-d+j*b;c[9]=g*-d+i*b;c[10]=f*-d+m*b;c[11]=h*-d+l*b;return c},rotateY:function(a,b,c){var d=Math.sin(b),b=Math.cos(b),e=a[0],g=a[1],f=a[2],h=a[3],j=a[8],i=a[9],m=a[10],l=a[11];c?a!==c&&(c[4]=a[4],c[5]=a[5],c[6]=a[6],c[7]=a[7],c[12]=a[12],c[13]=a[13],c[14]=a[14],c[15]= a[15]):c=a;c[0]=e*b+j*-d;c[1]=g*b+i*-d;c[2]=f*b+m*-d;c[3]=h*b+l*-d;c[8]=e*d+j*b;c[9]=g*d+i*b;c[10]=f*d+m*b;c[11]=h*d+l*b;return c},rotateZ:function(a,b,c){var d=Math.sin(b),b=Math.cos(b),e=a[0],g=a[1],f=a[2],h=a[3],j=a[4],i=a[5],m=a[6],l=a[7];c?a!==c&&(c[8]=a[8],c[9]=a[9],c[10]=a[10],c[11]=a[11],c[12]=a[12],c[13]=a[13],c[14]=a[14],c[15]=a[15]):c=a;c[0]=e*b+j*d;c[1]=g*b+i*d;c[2]=f*b+m*d;c[3]=h*b+l*d;c[4]=e*-d+j*b;c[5]=g*-d+i*b;c[6]=f*-d+m*b;c[7]=h*-d+l*b;return c},frustum:function(a,b,c,d,e,g,f){f|| (f=x.create());var h=b-a,j=d-c,i=g-e;f[0]=2*e/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=2*e/j;f[6]=0;f[7]=0;f[8]=(b+a)/h;f[9]=(d+c)/j;f[10]=-(g+e)/i;f[11]=-1;f[12]=0;f[13]=0;f[14]=-(2*g*e)/i;f[15]=0;return f},perspective:function(a,b,c,d,e){a=c*Math.tan(a*Math.PI/360);b*=a;return x.frustum(-b,b,-a,a,c,d,e)},ortho:function(a,b,c,d,e,g,f){f||(f=x.create());var h=b-a,j=d-c,i=g-e;f[0]=2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=2/j;f[6]=0;f[7]=0;f[8]=0;f[9]=0;f[10]=-2/i;f[11]=0;f[12]=-(a+b)/h;f[13]=-(d+c)/j;f[14]= -(g+e)/i;f[15]=1;return f},lookAt:function(a,b,c,d){d||(d=x.create());var e,g,f,h,j,i,m,l,k=a[0],o=a[1],a=a[2];f=c[0];h=c[1];g=c[2];m=b[0];c=b[1];e=b[2];if(k===m&&o===c&&a===e)return x.identity(d);b=k-m;c=o-c;m=a-e;l=1/Math.sqrt(b*b+c*c+m*m);b*=l;c*=l;m*=l;e=h*m-g*c;g=g*b-f*m;f=f*c-h*b;(l=Math.sqrt(e*e+g*g+f*f))?(l=1/l,e*=l,g*=l,f*=l):f=g=e=0;h=c*f-m*g;j=m*e-b*f;i=b*g-c*e;(l=Math.sqrt(h*h+j*j+i*i))?(l=1/l,h*=l,j*=l,i*=l):i=j=h=0;d[0]=e;d[1]=h;d[2]=b;d[3]=0;d[4]=g;d[5]=j;d[6]=c;d[7]=0;d[8]=f;d[9]= i;d[10]=m;d[11]=0;d[12]=-(e*k+g*o+f*a);d[13]=-(h*k+j*o+i*a);d[14]=-(b*k+c*o+m*a);d[15]=1;return d},fromRotationTranslation:function(a,b,c){c||(c=x.create());var d=a[0],e=a[1],g=a[2],f=a[3],h=d+d,j=e+e,i=g+g,a=d*h,m=d*j,d=d*i,k=e*j,e=e*i,g=g*i,h=f*h,j=f*j,f=f*i;c[0]=1-(k+g);c[1]=m+f;c[2]=d-j;c[3]=0;c[4]=m-f;c[5]=1-(a+g);c[6]=e+h;c[7]=0;c[8]=d+j;c[9]=e-h;c[10]=1-(a+k);c[11]=0;c[12]=b[0];c[13]=b[1];c[14]=b[2];c[15]=1;return c},str:function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\", \"+a[3]+\", \"+a[4]+\", \"+ a[5]+\", \"+a[6]+\", \"+a[7]+\", \"+a[8]+\", \"+a[9]+\", \"+a[10]+\", \"+a[11]+\", \"+a[12]+\", \"+a[13]+\", \"+a[14]+\", \"+a[15]+\"]\"}},k={create:function(a){var b=new o(4);a?(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3]):b[0]=b[1]=b[2]=b[3]=0;return b},createFrom:function(a,b,c,d){var e=new o(4);e[0]=a;e[1]=b;e[2]=c;e[3]=d;return e},set:function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];return b},equal:function(a,b){return a===b||1.0E-6>Math.abs(a[0]-b[0])&&1.0E-6>Math.abs(a[1]-b[1])&&1.0E-6>Math.abs(a[2]-b[2])&&1.0E-6> Math.abs(a[3]-b[3])},identity:function(a){a||(a=k.create());a[0]=0;a[1]=0;a[2]=0;a[3]=1;return a}},O=k.identity();k.calculateW=function(a,b){var c=a[0],d=a[1],e=a[2];if(!b||a===b)return a[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e)),a;b[0]=c;b[1]=d;b[2]=e;b[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return b};k.dot=function(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3]};k.inverse=function(a,b){var c=a[0],d=a[1],e=a[2],g=a[3],c=(c=c*c+d*d+e*e+g*g)?1/c:0;if(!b||a===b)return a[0]*=-c,a[1]*=-c,a[2]*=-c,a[3]*= c,a;b[0]=-a[0]*c;b[1]=-a[1]*c;b[2]=-a[2]*c;b[3]=a[3]*c;return b};k.conjugate=function(a,b){if(!b||a===b)return a[0]*=-1,a[1]*=-1,a[2]*=-1,a;b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];b[3]=a[3];return b};k.length=function(a){var b=a[0],c=a[1],d=a[2],a=a[3];return Math.sqrt(b*b+c*c+d*d+a*a)};k.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=Math.sqrt(c*c+d*d+e*e+g*g);if(0===f)return b[0]=0,b[1]=0,b[2]=0,b[3]=0,b;f=1/f;b[0]=c*f;b[1]=d*f;b[2]=e*f;b[3]=g*f;return b};k.add=function(a,b,c){if(!c|| a===c)return a[0]+=b[0],a[1]+=b[1],a[2]+=b[2],a[3]+=b[3],a;c[0]=a[0]+b[0];c[1]=a[1]+b[1];c[2]=a[2]+b[2];c[3]=a[3]+b[3];return c};k.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],a=a[3],f=b[0],h=b[1],j=b[2],b=b[3];c[0]=d*b+a*f+e*j-g*h;c[1]=e*b+a*h+g*f-d*j;c[2]=g*b+a*j+d*h-e*f;c[3]=a*b-d*f-e*h-g*j;return c};k.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2],b=a[0],f=a[1],h=a[2],a=a[3],j=a*d+f*g-h*e,i=a*e+h*d-b*g,k=a*g+b*e-f*d,d=-b*d-f*e-h*g;c[0]=j*a+d*-b+i*-h-k*-f;c[1]=i*a+ d*-f+k*-b-j*-h;c[2]=k*a+d*-h+j*-f-i*-b;return c};k.scale=function(a,b,c){if(!c||a===c)return a[0]*=b,a[1]*=b,a[2]*=b,a[3]*=b,a;c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;c[3]=a[3]*b;return c};k.toMat3=function(a,b){b||(b=A.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,j=e+e,i=c*f,k=c*h,c=c*j,l=d*h,d=d*j,e=e*j,f=g*f,h=g*h,g=g*j;b[0]=1-(l+e);b[1]=k+g;b[2]=c-h;b[3]=k-g;b[4]=1-(i+e);b[5]=d+f;b[6]=c+h;b[7]=d-f;b[8]=1-(i+l);return b};k.toMat4=function(a,b){b||(b=x.create());var c=a[0],d=a[1],e=a[2],g= a[3],f=c+c,h=d+d,j=e+e,i=c*f,k=c*h,c=c*j,l=d*h,d=d*j,e=e*j,f=g*f,h=g*h,g=g*j;b[0]=1-(l+e);b[1]=k+g;b[2]=c-h;b[3]=0;b[4]=k-g;b[5]=1-(i+e);b[6]=d+f;b[7]=0;b[8]=c+h;b[9]=d-f;b[10]=1-(i+l);b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};k.slerp=function(a,b,c,d){d||(d=a);var e=a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3],g,f;if(1<=Math.abs(e))return d!==a&&(d[0]=a[0],d[1]=a[1],d[2]=a[2],d[3]=a[3]),d;g=Math.acos(e);f=Math.sqrt(1-e*e);if(0.001>Math.abs(f))return d[0]=0.5*a[0]+0.5*b[0],d[1]=0.5*a[1]+0.5*b[1], d[2]=0.5*a[2]+0.5*b[2],d[3]=0.5*a[3]+0.5*b[3],d;e=Math.sin((1-c)*g)/f;c=Math.sin(c*g)/f;d[0]=a[0]*e+b[0]*c;d[1]=a[1]*e+b[1]*c;d[2]=a[2]*e+b[2]*c;d[3]=a[3]*e+b[3]*c;return d};k.fromRotationMatrix=function(a,b){b||(b=k.create());var c=a[0]+a[4]+a[8],d;if(0<c)d=Math.sqrt(c+1),b[3]=0.5*d,d=0.5/d,b[0]=(a[7]-a[5])*d,b[1]=(a[2]-a[6])*d,b[2]=(a[3]-a[1])*d;else{d=k.fromRotationMatrix.s_iNext=k.fromRotationMatrix.s_iNext||[1,2,0];c=0;a[4]>a[0]&&(c=1);a[8]>a[3*c+c]&&(c=2);var e=d[c],g=d[e];d=Math.sqrt(a[3*c+ c]-a[3*e+e]-a[3*g+g]+1);b[c]=0.5*d;d=0.5/d;b[3]=(a[3*g+e]-a[3*e+g])*d;b[e]=(a[3*e+c]+a[3*c+e])*d;b[g]=(a[3*g+c]+a[3*c+g])*d}return b};A.toQuat4=k.fromRotationMatrix;(function(){var a=A.create();k.fromAxes=function(b,c,d,e){a[0]=c[0];a[3]=c[1];a[6]=c[2];a[1]=d[0];a[4]=d[1];a[7]=d[2];a[2]=b[0];a[5]=b[1];a[8]=b[2];return k.fromRotationMatrix(a,e)}})();k.identity=function(a){a||(a=k.create());a[0]=0;a[1]=0;a[2]=0;a[3]=1;return a};k.fromAngleAxis=function(a,b,c){c||(c=k.create());var a=0.5*a,d=Math.sin(a); c[3]=Math.cos(a);c[0]=d*b[0];c[1]=d*b[1];c[2]=d*b[2];return c};k.toAngleAxis=function(a,b){b||(b=a);var c=a[0]*a[0]+a[1]*a[1]+a[2]*a[2];0<c?(b[3]=2*Math.acos(a[3]),c=E.invsqrt(c),b[0]=a[0]*c,b[1]=a[1]*c,b[2]=a[2]*c):(b[3]=0,b[0]=1,b[1]=0,b[2]=0);return b};k.str=function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\", \"+a[3]+\"]\"};var J={create:function(a){var b=new o(2);a?(b[0]=a[0],b[1]=a[1]):(b[0]=0,b[1]=0);return b},createFrom:function(a,b){var c=new o(2);c[0]=a;c[1]=b;return c},add:function(a,b,c){c|| (c=b);c[0]=a[0]+b[0];c[1]=a[1]+b[1];return c},subtract:function(a,b,c){c||(c=b);c[0]=a[0]-b[0];c[1]=a[1]-b[1];return c},multiply:function(a,b,c){c||(c=b);c[0]=a[0]*b[0];c[1]=a[1]*b[1];return c},divide:function(a,b,c){c||(c=b);c[0]=a[0]/b[0];c[1]=a[1]/b[1];return c},scale:function(a,b,c){c||(c=a);c[0]=a[0]*b;c[1]=a[1]*b;return c},dist:function(a,b){var c=b[0]-a[0],d=b[1]-a[1];return Math.sqrt(c*c+d*d)},set:function(a,b){b[0]=a[0];b[1]=a[1];return b},equal:function(a,b){return a===b||1.0E-6>Math.abs(a[0]- b[0])&&1.0E-6>Math.abs(a[1]-b[1])},negate:function(a,b){b||(b=a);b[0]=-a[0];b[1]=-a[1];return b},normalize:function(a,b){b||(b=a);var c=a[0]*a[0]+a[1]*a[1];0<c?(c=Math.sqrt(c),b[0]=a[0]/c,b[1]=a[1]/c):b[0]=b[1]=0;return b},cross:function(a,b,c){a=a[0]*b[1]-a[1]*b[0];if(!c)return a;c[0]=c[1]=0;c[2]=a;return c},length:function(a){var b=a[0],a=a[1];return Math.sqrt(b*b+a*a)},squaredLength:function(a){var b=a[0],a=a[1];return b*b+a*a},dot:function(a,b){return a[0]*b[0]+a[1]*b[1]},direction:function(a, b,c){c||(c=a);var d=a[0]-b[0],a=a[1]-b[1],b=d*d+a*a;if(!b)return c[0]=0,c[1]=0,c[2]=0,c;b=1/Math.sqrt(b);c[0]=d*b;c[1]=a*b;return c},lerp:function(a,b,c,d){d||(d=a);d[0]=a[0]+c*(b[0]-a[0]);d[1]=a[1]+c*(b[1]-a[1]);return d},str:function(a){return\"[\"+a[0]+\", \"+a[1]+\"]\"}},I={create:function(a){var b=new o(4);a?(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3]):b[0]=b[1]=b[2]=b[3]=0;return b},createFrom:function(a,b,c,d){var e=new o(4);e[0]=a;e[1]=b;e[2]=c;e[3]=d;return e},set:function(a,b){b[0]=a[0];b[1]=a[1]; b[2]=a[2];b[3]=a[3];return b},equal:function(a,b){return a===b||1.0E-6>Math.abs(a[0]-b[0])&&1.0E-6>Math.abs(a[1]-b[1])&&1.0E-6>Math.abs(a[2]-b[2])&&1.0E-6>Math.abs(a[3]-b[3])},identity:function(a){a||(a=I.create());a[0]=1;a[1]=0;a[2]=0;a[3]=1;return a},transpose:function(a,b){if(!b||a===b){var c=a[1];a[1]=a[2];a[2]=c;return a}b[0]=a[0];b[1]=a[2];b[2]=a[1];b[3]=a[3];return b},determinant:function(a){return a[0]*a[3]-a[2]*a[1]},inverse:function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=c*g-e* d;if(!f)return null;f=1/f;b[0]=g*f;b[1]=-d*f;b[2]=-e*f;b[3]=c*f;return b},multiply:function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],a=a[3];c[0]=d*b[0]+e*b[2];c[1]=d*b[1]+e*b[3];c[2]=g*b[0]+a*b[2];c[3]=g*b[1]+a*b[3];return c},rotate:function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],a=a[3],f=Math.sin(b),b=Math.cos(b);c[0]=d*b+e*f;c[1]=d*-f+e*b;c[2]=g*b+a*f;c[3]=g*-f+a*b;return c},multiplyVec2:function(a,b,c){c||(c=b);var d=b[0],b=b[1];c[0]=d*a[0]+b*a[1];c[1]=d*a[2]+b*a[3];return c},scale:function(a, b,c){c||(c=a);var d=a[1],e=a[2],g=a[3],f=b[0],b=b[1];c[0]=a[0]*f;c[1]=d*b;c[2]=e*f;c[3]=g*b;return c},str:function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\", \"+a[3]+\"]\"}},K={create:function(a){var b=new o(4);a?(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3]):(b[0]=0,b[1]=0,b[2]=0,b[3]=0);return b},createFrom:function(a,b,c,d){var e=new o(4);e[0]=a;e[1]=b;e[2]=c;e[3]=d;return e},add:function(a,b,c){c||(c=b);c[0]=a[0]+b[0];c[1]=a[1]+b[1];c[2]=a[2]+b[2];c[3]=a[3]+b[3];return c},subtract:function(a,b,c){c||(c= b);c[0]=a[0]-b[0];c[1]=a[1]-b[1];c[2]=a[2]-b[2];c[3]=a[3]-b[3];return c},multiply:function(a,b,c){c||(c=b);c[0]=a[0]*b[0];c[1]=a[1]*b[1];c[2]=a[2]*b[2];c[3]=a[3]*b[3];return c},divide:function(a,b,c){c||(c=b);c[0]=a[0]/b[0];c[1]=a[1]/b[1];c[2]=a[2]/b[2];c[3]=a[3]/b[3];return c},scale:function(a,b,c){c||(c=a);c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;c[3]=a[3]*b;return c},set:function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];return b},equal:function(a,b){return a===b||1.0E-6>Math.abs(a[0]-b[0])&&1.0E-6> Math.abs(a[1]-b[1])&&1.0E-6>Math.abs(a[2]-b[2])&&1.0E-6>Math.abs(a[3]-b[3])},negate:function(a,b){b||(b=a);b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];b[3]=-a[3];return b},length:function(a){var b=a[0],c=a[1],d=a[2],a=a[3];return Math.sqrt(b*b+c*c+d*d+a*a)},squaredLength:function(a){var b=a[0],c=a[1],d=a[2],a=a[3];return b*b+c*c+d*d+a*a},lerp:function(a,b,c,d){d||(d=a);d[0]=a[0]+c*(b[0]-a[0]);d[1]=a[1]+c*(b[1]-a[1]);d[2]=a[2]+c*(b[2]-a[2]);d[3]=a[3]+c*(b[3]-a[3]);return d},str:function(a){return\"[\"+a[0]+\", \"+ a[1]+\", \"+a[2]+\", \"+a[3]+\"]\"}};w&&(w.glMatrixArrayType=o,w.MatrixArray=o,w.setMatrixArrayType=D,w.determineMatrixArrayType=G,w.glMath=E,w.vec2=J,w.vec3=r,w.vec4=K,w.mat2=I,w.mat3=A,w.mat4=x,w.quat4=k);return{glMatrixArrayType:o,MatrixArray:o,setMatrixArrayType:D,determineMatrixArrayType:G,glMath:E,vec2:J,vec3:r,vec4:K,mat2:I,mat3:A,mat4:x,quat4:k}});/* Javascript graphics utility library Helper functions, WebGL classes, Mouse input, Colours and Gradients UI Copyright (c) 2014, Owen Kaluza Released into public domain: This program is free software. It comes without any warranty, to the extent permitted by applicable law. You can redistribute it and/or modify it as long as this header remains intact */ var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.checkStringArgs=function(a,b,c){if(null==a)throw new TypeError(\"The 'this' value for String.prototype.\"+c+\" must not be null or undefined\");if(b instanceof RegExp)throw new TypeError(\"First argument to String.prototype.\"+c+\" must not be a regular expression\");return a+\"\"}; $jscomp.defineProperty=\"function\"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){if(c.get||c.set)throw new TypeError(\"ES3 does not support getters and setters.\");a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)};$jscomp.getGlobal=function(a){return\"undefined\"!=typeof window&&window===a?a:\"undefined\"!=typeof global&&null!=global?global:a};$jscomp.global=$jscomp.getGlobal(this); $jscomp.polyfill=function(a,b,c,d){if(b){c=$jscomp.global;a=a.split(\".\");for(d=0;d<a.length-1;d++){var e=a[d];e in c||(c[e]={});c=c[e]}a=a[a.length-1];d=c[a];b=b(d);b!=d&&null!=b&&$jscomp.defineProperty(c,a,{configurable:!0,writable:!0,value:b})}}; $jscomp.polyfill(\"String.prototype.repeat\",function(a){return a?a:function(a){var b=$jscomp.checkStringArgs(this,null,\"repeat\");if(0>a||1342177279<a)throw new RangeError(\"Invalid count value\");a|=0;for(var d=\"\";a;)if(a&1&&(d+=b),a>>>=1)b+=b;return d}},\"es6-impl\",\"es3\");$jscomp.stringPadding=function(a,b){var c=void 0!==a?String(a):\" \";return 0<b&&c?c.repeat(Math.ceil(b/c.length)).substring(0,b):\"\"}; $jscomp.polyfill(\"String.prototype.padStart\",function(a){return a?a:function(a,c){var b=$jscomp.checkStringArgs(this,null,\"padStart\");return $jscomp.stringPadding(c,a-b.length)+b}},\"es8\",\"es3\");var OK=function(){var a={debug_on:!1,debug:function(b){if(a.debug_on){var c=document.getElementById(\"console\");c?c.innerHTML=\"<div style=\\\"font-family: 'monospace'; font-size: 8pt;\\\">\"+b+\"</div>\"+c.innerHTML:console.log(b)}},clear:function(){var a=document.getElementById(\"console\");a&&(a.innerHTML=\"\")}};return a}(); function getSearchVariable(a,b){for(var c=window.location.search.substring(1).split(\"&\"),d=0;d<c.length;d++){var e=c[d].split(\"=\");if(unescape(e[0])==a)return unescape(e[1])}return b}function getImageDataURL(a){var b=document.createElement(\"canvas\");b.width=a.width;b.height=a.height;b.getContext(\"2d\").drawImage(a,0,0);return b.toDataURL(\"image/png\")} function toggle(a){var b=document.getElementById(a).style.display;\"none\"!=b&&b?document.getElementById(a).style.display=\"none\":document.getElementById(a).style.display=\"block\"}function setAll(a,b){for(var c=document.getElementsByClassName(b),d=0;d<c.length;d++)c[d].style.display=a}function getSourceFromElement(a){var b=document.getElementById(a);if(!b)return null;a=\"\";for(b=b.firstChild;b;)3==b.nodeType&&(a+=b.textContent),b=b.nextSibling;return a} function removeChildren(a){if(a.hasChildNodes())for(;0<a.childNodes.length;)a.removeChild(a.firstChild)}function requestFullScreen(a){a=document.getElementById(a);a.requestFullscreen?a.requestFullscreen():a.mozRequestFullScreen?a.mozRequestFullScreen():a.webkitRequestFullScreen&&a.webkitRequestFullScreen()}function typeOf(a){var b=typeof a;\"object\"===b&&(a?\"number\"!==typeof a.length||a.propertyIsEnumerable(\"length\")||\"function\"!==typeof a.splice||(b=\"array\"):b=\"null\");return b} function isEmpty(a){var b,c;if(\"object\"===typeOf(a))for(b in a)if(c=a[b],void 0!==c&&\"function\"!==typeOf(c))return!1;return!0} function ajaxReadFile(a,b,c,d,e){var f=new XMLHttpRequest,g=0;void 0!=d&&(\"number\"==typeof d?g=d:f.onprogress=d);f.onreadystatechange=function(){if(0<g&&2<f.readyState){var c=parseInt(f.responseText.length);d&&setProgress(c/g*100)}4==f.readyState&&(200==f.status?(d&&setProgress(100),OK.debug(\"RECEIVED: \"+a),b&&b(f.responseText,a)):b?b(\"Error: \"+f.status+\" : \"+a):OK.debug(\"Ajax Read File Error: returned status code \"+f.status+\" \"+f.statusText))};c?f.open(\"GET\",a+\"?d=\"+(new Date).getTime(),!0):f.open(\"GET\", a,!0);for(var h in e)f.setRequestHeader(h,e[h]);f.send(null)}function readURL(a,b,c){var d=new XMLHttpRequest,e=0;void 0!=c&&(\"number\"==typeof c?e=c:d.onprogress=c);d.onreadystatechange=function(){if(0<e&&2<d.readyState){var a=parseInt(d.responseText.length);c&&setProgress(a/e*100)}};b?d.open(\"GET\",a+\"?d=\"+(new Date).getTime(),!1):d.open(\"GET\",a,!1);d.overrideMimeType(\"text/plain; charset=x-user-defined\");d.send(null);if(200!=d.status)return\"\";c&&setProgress(100);return d.responseText} function updateProgress(a){a.lengthComputable&&(setProgress(a.loaded/a.total*100),OK.debug(a.loaded+\" / \"+a.total))}function setProgress(a){a=Math.round(a);document.getElementById(\"progressbar\").style.width=3*a+\"px\";document.getElementById(\"progressstatus\").innerHTML=a+\"%\"} function ajaxPost(a,b,c,d,e){var f=new XMLHttpRequest;void 0!=d&&(f.upload.onprogress=d);f.onreadystatechange=function(){4==f.readyState&&(200==f.status?(d&&setProgress(100),OK.debug(\"POST: \"+a),c&&c(f.responseText)):c?c(\"Error, status:\"+f.status):OK.debug(\"Ajax Post Error: returned status code \"+f.status+\" \"+f.statusText))};f.open(\"POST\",a,!0);\"string\"==typeof b&&f.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");if(e)for(key in e)f.setRequestHeader(key,e[key]);f.send(b)} var defaultMouse,dragMouse;function MouseEventHandler(a,b,c,d,e,f,g){this.click=a;this.wheel=b;this.move=c;this.down=d;this.up=e;this.leave=f;this.pinch=g} function Mouse(a,b,c){this.element=a;this.handler=b;this.isdown=this.disabled=!1;this.button=null;this.dragged=!1;this.lastY=this.lastX=this.absoluteY=this.absoluteX=this.x=this.x=0;this.slider=null;this.spin=0;this.moveUpdate=!1;this.enableContext=c?!0:!1;a.addEventListener(\"onwheel\"in document?\"wheel\":\"mousewheel\",handleMouseWheel,!1);a.onmousedown=handleMouseDown;a.onmouseout=handleMouseLeave;document.onmouseup=handleMouseUp;document.onmousemove=handleMouseMove;a.addEventListener(\"touchstart\", touchHandler,!0);a.addEventListener(\"touchmove\",touchHandler,!0);a.addEventListener(\"touchend\",touchHandler,!0);a.oncontextmenu=function(){return this.mouse.enableContext}}Mouse.prototype.setDefault=function(){defaultMouse=document.mouse=this}; Mouse.prototype.update=function(a){a||(a=window.event);this.x=a.clientX;this.y=a.clientY;this.absoluteX=this.x;this.absoluteY=this.y;var b=this.element.getBoundingClientRect(),b=[b.left,b.top];this.x-=b[0];this.y-=b[1];this.clientx=a.pageX-b[0];this.clienty=a.pageY-b[1]};function getMouse(a){a||(a=window.event);var b=a.target.mouse;if(b)return b;for(a=a.target;a!=document;)if(a=a.parentNode,a.mouse)return a.mouse;return null} function handleMouseDown(a){var b=getMouse(a);if(!b||b.disabled)return!0;b.target=(a||window.event).target;b.dragged=!1;b.update(a);b.isdown||(b.lastX=b.absoluteX,b.lastY=b.absoluteY);b.isdown=!0;dragMouse=b;b.button=a.button;document.mouse=b;var c=!0;b.handler.down&&(c=b.handler.down(a,b));!c&&a.preventDefault&&a.preventDefault();return c} function handleMouseUp(a){var b=document.mouse;if(!b||b.disabled)return!0;var c=!0;b.isdown&&(b.update(a),b.handler.click&&(c=b.handler.click(a,b)),b.isdown=!1,dragMouse=null,b.button=null,b.dragged=!1);b.handler.up&&(c=c&&b.handler.up(a,b));document.mouse=defaultMouse;!c&&a.preventDefault&&a.preventDefault();return c} function handleMouseMove(a){var b=dragMouse?dragMouse:getMouse(a);if(!b||b.disabled)return!0;b.update(a);b.deltaX=b.absoluteX-b.lastX;b.deltaY=b.absoluteY-b.lastY;var c=!0;!b.dragged&&b.isdown&&3<Math.abs(b.deltaX)+Math.abs(b.deltaY)&&(b.dragged=!0);b.handler.move&&(c=b.handler.move(a,b));b.moveUpdate&&(b.lastX=b.absoluteX,b.lastY=b.absoluteY);!c&&a.preventDefault&&a.preventDefault();return c} function handleMouseWheel(a){var b=getMouse(a);if(!b||b.disabled)return!0;b.update(a);var c=!1;a.spin=0<(a.deltaY?-a.deltaY:a.wheelDelta)?1:-1;b.handler.wheel&&(c=b.handler.wheel(a,b));!c&&a.preventDefault&&a.preventDefault();return c}function handleMouseLeave(a){var b=getMouse(a);if(!b||b.disabled)return!0;var c=!0;b.handler.leave&&(c=b.handler.leave(a,b));!c&&a.preventDefault&&a.preventDefault();return a.returnValue=c} function touchHandler(a){var b=a.changedTouches[0],c=null,d=getMouse(a);switch(a.type){case \"touchstart\":2==a.touches.length?(d.isdown=!1,d.scaling=0):c=\"mousedown\";break;case \"touchmove\":if(null!=d.scaling&&2==a.touches.length){var e=Math.sqrt((a.touches[0].pageX-a.touches[1].pageX)*(a.touches[0].pageX-a.touches[1].pageX)+(a.touches[0].pageY-a.touches[1].pageY)*(a.touches[0].pageY-a.touches[1].pageY));0<d.scaling?(a.distance=e-d.scaling,d.handler.pinch&&d.handler.pinch(a,d),a.returnValue=!0):d.scaling= e}else c=\"mousemove\";break;case \"touchend\":null!=d.scaling?d.scaling=0==d.scaling?null:0:c=\"mouseup\";break;default:return}1<a.touches.length&&(c=null);c&&(d=document.createEvent(\"MouseEvent\"),d.initMouseEvent(c,!0,!0,window,1,b.screenX,b.screenY,b.clientX,b.clientY,a.ctrlKey,a.altKey,a.shiftKey,a.metaKey,0,null),b.target.dispatchEvent(d),a.preventDefault())} function printMatrix(a){console.log(\"--------- --------- --------- ---------\");for(var b=0;4>b;b++){for(var c=\"\",d=0;4>d;d++)var e=\"\"+(4*d+b),f=\"\"+a[4*d+b].toFixed(5),c=c+(e.padStart(2)+\" \"+f.padStart(8)+\" \");console.log(c)}console.log(\"--------- --------- --------- ---------\")}function Viewport(a,b,c,d){this.x=a;this.y=b;this.width=c;this.height=d;this.array=new Float32Array([a,b,c,d])} function WebGL(a,b){this.program=null;this.modelView=new ViewMatrix;this.projection=new ViewMatrix;this.textures=[];this.timer=null;if(!window.WebGLRenderingContext)throw\"No browser WebGL support\";try{this.gl=a.getContext(\"webgl\",b)||a.getContext(\"experimental-webgl\",b)}catch(c){throw OK.debug(\"detectGL exception: \"+c),\"No context\";}this.viewport=new Viewport(0,0,a.width,a.height);if(!this.gl)throw\"Failed to get context\";} WebGL.prototype.setMatrices=function(){this.gl.uniformMatrix4fv(this.program.mvMatrixUniform,!1,this.modelView.matrix);this.gl.uniformMatrix4fv(this.program.pMatrixUniform,!1,this.projection.matrix);this.setNormalMatrix()};WebGL.prototype.setNormalMatrix=function(){this.program.nMatrixUniform&&(this.nMatrix=mat4.create(this.modelView.matrix),mat4.inverse(this.nMatrix),mat4.transpose(this.nMatrix),this.gl.uniformMatrix4fv(this.program.nMatrixUniform,!1,this.nMatrix))}; WebGL.prototype.initDraw2d=function(){this.gl.enableVertexAttribArray(this.program.attributes.aVertexPosition);this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vertexPositionBuffer);this.gl.vertexAttribPointer(this.program.attributes.aVertexPosition,this.vertexPositionBuffer.itemSize,this.gl.FLOAT,!1,0,0);this.program.attributes.aTextureCoord&&(this.gl.enableVertexAttribArray(this.program.attributes.aTextureCoord),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.textureCoordBuffer),this.gl.vertexAttribPointer(this.program.attributes.aTextureCoord, this.textureCoordBuffer.itemSize,this.gl.FLOAT,!1,0,0));this.setMatrices()};WebGL.prototype.updateTexture=function(a,b,c){void 0==c&&(c=this.gl.TEXTURE0);this.gl.activeTexture(c);this.gl.bindTexture(this.gl.TEXTURE_2D,a);this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,b);this.gl.bindTexture(this.gl.TEXTURE_2D,null)}; WebGL.prototype.init2dBuffers=function(a){void 0==a&&(a=this.gl.TEXTURE0);this.vertexPositionBuffer=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vertexPositionBuffer);this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array([1,1,-1,1,1,-1,-1,-1]),this.gl.STATIC_DRAW);this.vertexPositionBuffer.itemSize=2;this.vertexPositionBuffer.numItems=4;this.gl.activeTexture(a);this.gradientTexture=this.gl.createTexture();this.gl.bindTexture(this.gl.TEXTURE_2D,this.gradientTexture);this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST);this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST);this.textureCoordBuffer=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.textureCoordBuffer);this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array([1,1,0,1,1,0,0,0]),this.gl.STATIC_DRAW);this.textureCoordBuffer.itemSize=2;this.textureCoordBuffer.numItems=4}; WebGL.prototype.loadTexture=function(a,b,c,d){void 0==b&&(b=this.gl.NEAREST);void 0==c&&(c=this.gl.RGBA);this.texid=this.textures.length;this.textures.push(this.gl.createTexture());this.gl.bindTexture(this.gl.TEXTURE_2D,this.textures[this.texid]);d&&this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL,!0);this.gl.texImage2D(this.gl.TEXTURE_2D,0,c,c,this.gl.UNSIGNED_BYTE,a);this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,b);this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER, b);this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE);this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE);this.gl.bindTexture(this.gl.TEXTURE_2D,null);return this.textures[this.texid]};WebGL.prototype.setPerspective=function(a,b,c,d){void 0==a&&(a=45);void 0==b&&(b=1);void 0==c&&(c=.1);void 0==d&&(d=1E3);this.projection.matrix=mat4.perspective(a,b,c,d)};WebGL.prototype.use=function(a){this.program=a;this.program.program&&this.gl.useProgram(this.program.program)}; WebGL.prototype.view=function(a){this.gl&&(this.gl.viewport(this.viewport.x,this.viewport.y,this.viewport.width,this.viewport.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT),this.apply(a))}; WebGL.prototype.apply=function(a){if(this.gl){this.setPerspective(a.fov,this.viewport.width/this.viewport.height,a.near_clip,a.far_clip);this.modelView.identity();this.modelView.translate([a.translate[0],a.translate[1],a.translate[2]]);var b=[-(a.focus[0]-a.centre[0]),-(a.focus[1]-a.centre[1]),-(a.focus[2]-a.centre[2])];this.modelView.translate(b);this.modelView.mult(quat4.toMat4(a.rotate));this.modelView.scale(a.scale);this.modelView.translate([-b[0],-b[1],-b[2]]);this.modelView.translate([-a.focus[0], -a.focus[1],-a.focus[2]*a.orientation]);1==a.orientation?this.gl.frontFace(a.gl.CCW):(this.gl.frontFace(a.gl.CW),this.modelView.scale([1,1,-1]))}}; function WebGLProgram(a,b,c){this.program=null;0>b.indexOf(\"main\")&&(b=getSourceFromElement(b));0>c.indexOf(\"main\")&&(c=getSourceFromElement(c));this.gl=a;this.program&&this.gl.isProgram(this.program)&&(this.gl.isShader(this.vshader)&&(this.gl.detachShader(this.program,this.vshader),this.gl.deleteShader(this.vshader)),this.gl.isShader(this.fshader)&&(this.gl.detachShader(this.program,this.fshader),this.gl.deleteShader(this.fshader)),this.gl.deleteProgram(this.program));this.program=this.gl.createProgram(); this.vshader=this.compileShader(b,this.gl.VERTEX_SHADER);this.fshader=this.compileShader(c,this.gl.FRAGMENT_SHADER);this.gl.attachShader(this.program,this.vshader);this.gl.attachShader(this.program,this.fshader);this.gl.linkProgram(this.program);if(!this.gl.getProgramParameter(this.program,this.gl.LINK_STATUS))throw\"Could not initialise shaders: \"+this.gl.getProgramInfoLog(this.program);} WebGLProgram.prototype.compileShader=function(a,b){var c=this.gl.createShader(b);this.gl.shaderSource(c,a);this.gl.compileShader(c);if(!this.gl.getShaderParameter(c,this.gl.COMPILE_STATUS))throw this.gl.getShaderInfoLog(c);return c}; WebGLProgram.prototype.setup=function(a,b,c){if(this.program){if(void 0==a){a=[];for(var d=this.gl.getProgramParameter(this.program,this.gl.ACTIVE_ATTRIBUTES),e=0;e<d;++e){var f=this.gl.getActiveAttrib(this.program,e);a.push(f.name)}}if(void 0==b)for(b=[],d=this.gl.getProgramParameter(this.program,this.gl.ACTIVE_UNIFORMS),e=0;e<d;++e)f=this.gl.getActiveUniform(this.program,e),b.push(f.name);this.attributes={};for(e in a)this.attributes[a[e]]=this.gl.getAttribLocation(this.program,a[e]),c||this.gl.enableVertexAttribArray(this.attributes[a[e]]); this.uniforms={};for(e in b)this.uniforms[b[e]]=this.gl.getUniformLocation(this.program,b[e]);this.mvMatrixUniform=this.gl.getUniformLocation(this.program,\"uMVMatrix\");this.pMatrixUniform=this.gl.getUniformLocation(this.program,\"uPMatrix\");this.nMatrixUniform=this.gl.getUniformLocation(this.program,\"uNMatrix\")}};function ViewMatrix(){this.matrix=mat4.create();mat4.identity(this.matrix);this.stack=[]}ViewMatrix.prototype.toString=function(){return JSON.stringify(this.toArray())}; ViewMatrix.prototype.toArray=function(){return JSON.parse(mat4.str(this.matrix))};ViewMatrix.prototype.push=function(a){a?(this.stack.push(mat4.create(a)),this.matrix=mat4.create(a)):this.stack.push(mat4.create(this.matrix))};ViewMatrix.prototype.pop=function(){if(0==this.stack.length)throw\"Matrix stack underflow\";return this.matrix=this.stack.pop()};ViewMatrix.prototype.mult=function(a){mat4.multiply(this.matrix,a)};ViewMatrix.prototype.identity=function(){mat4.identity(this.matrix)}; ViewMatrix.prototype.scale=function(a){mat4.scale(this.matrix,a)};ViewMatrix.prototype.translate=function(a){mat4.translate(this.matrix,a)};ViewMatrix.prototype.rotate=function(a,b){mat4.rotate(this.matrix,a*Math.PI/180,b)}; function Palette(a,b){this.premultiply=b;this.background=new Colour(\"rgba(0,0,0,0)\");this.colours=[];this.slider=new Image;this.slider.src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAPCAYAAAA2yOUNAAAAj0lEQVQokWNIjHT8/+zZs//Pnj37/+TJk/9XLp/+f+bEwf9HDm79v2Prqv9aKrz/GUYVEaeoMDMQryJXayWIoi0bFmFV1NWS+z/E1/Q/AwMDA0NVcez/LRsWoSia2luOUAADVcWx/xfO6/1/5fLp/1N7y//HhlmhKoCBgoyA/w3Vyf8jgyyxK4CBUF8zDAUAAJRXY0G1eRgAAAAASUVORK5CYII=\";if(a){var c=!1;if(\"string\"==typeof a)for(var d=a.split(/[\\n;]/),e,f=0;f< d.length;f++){var g=d[f].trim();if(g){var h=g.split(\"=\");if(\"Background\"==h[0])this.background=new Colour(h[1]);else if(\"P\"==h[0][0])e=parseFloat(h[1]);else if(\"C\"==h[0][0]){if(this.colours.push(new ColourPos(h[1],e)),1==e)break}else 2==h.length?this.colours.push(new ColourPos(h[1],h[0])):(c=!0,this.colours.push(new ColourPos(g)))}}else{for(d=0;d<a.length;d++)void 0==a[d].position&&(c=!0),this.colours.push(new ColourPos(a[d].colour,a[d].position));a.background&&(this.background=new Colour(a.background))}if(c)for(d= 0;d<this.colours.length;d++)this.colours[d].position=1/(this.colours.length-1)*d;this.sort();c=!1;for(d=0;d<this.colours.length;d++)0<this.colours[d].colour.alpha&&(c=!0),1<this.colours[d].colour.alpha&&(this.colours[d].colour.alpha=1);if(!c)for(d=0;d<this.colours.length;d++)this.colours[d].colour.alpha=1}else this.colours.push(new ColourPos(\"rgba(255,255,255,1)\",0)),this.colours.push(new ColourPos(\"rgba(0,0,0,1)\",1))} Palette.prototype.sort=function(){this.colours.sort(function(a,b){return a.position-b.position})};Palette.prototype.newColour=function(a,b){var c=new ColourPos(b,a);this.colours.push(c);this.sort();for(c=1;c<this.colours.length-1;c++)if(this.colours[c].position==a)return c;return-1};Palette.prototype.inRange=function(a,b,c){for(var d=0;d<this.colours.length;d++){var e=this.colours[d].position*c;if(a==e||1<b&&a>=e-b/2&&a<=e+b/2)return d}return-1}; Palette.prototype.inDragRange=function(a,b,c){for(var d=1;d<this.colours.length-1;d++){var e=this.colours[d].position*c;if(a==e||1<b&&a>=e-b/2&&a<=e+b/2)return d}return 0};Palette.prototype.remove=function(a){this.colours.splice(a,1)};Palette.prototype.toString=function(){for(var a=\"Background=\"+this.background.html(),b=0;b<this.colours.length;b++)a+=\"\\n\"+this.colours[b].position.toFixed(6)+\"=\"+this.colours[b].colour.html();return a}; Palette.prototype.get=function(){var a={};a.background=this.background.html();a.colours=[];for(var b=0;b<this.colours.length;b++)a.colours.push({position:this.colours[b].position,colour:this.colours[b].colour.html()});return a};Palette.prototype.toJSON=function(){return JSON.stringify(this.get())}; Palette.prototype.draw=function(a,b){if(!this.slider.width&&b){var c=this;setTimeout(function(){c.draw(a,b)},150)}else if(a){var d=/webkit/.test(navigator.userAgent.toLowerCase());0==this.colours.length&&(this.background=new Colour(\"#ffffff\"),this.colours.push(new ColourPos(\"#000000\",0)),this.colours.push(new ColourPos(\"#ffffff\",1)));list=this.colours.slice(0);list.sort(function(a,b){return a.position-b.position});if(a.getContext){var e=a.width,f=a.height,g=a.getContext(\"2d\");g.clearRect(0,0,e,f); if(d)for(var h=0,d=1;d<list.length;d++){var k=Math.round(e*list[d].position);g.fillStyle=g.createLinearGradient(h,0,k,0);var l=list[d-1].colour,m=list[d].colour;this.premultiply&&!b&&(l=this.background.blend(l),m=this.background.blend(m));g.fillStyle.addColorStop(0,l.html());g.fillStyle.addColorStop(1,m.html());g.fillRect(h,0,k-h,f);h=k}else{g.fillStyle=g.createLinearGradient(0,0,e,0);for(d=0;d<list.length;d++)h=list[d].colour,this.premultiply&&!b&&(h=this.background.blend(h)),g.fillStyle.addColorStop(list[d].position, h.html());g.fillRect(0,0,e,f)}if(f=document.getElementById(\"backgroundCUR\"))f.style.background=this.background.html();if(b)for(d=1;d<list.length-1;d++)f=Math.floor(e*list[d].position)+.5,50<list[d].colour.HSV().V?g.strokeStyle=\"black\":g.strokeStyle=\"white\",g.beginPath(),g.moveTo(f,0),g.lineTo(f,a.height),g.closePath(),g.stroke(),f-=this.slider.width/2,g.drawImage(this.slider,f,0)}else alert(\"getContext failed!\")}else alert(\"Invalid canvas!\")}; function ColourPos(a,b){this.position=void 0==b?0:parseFloat(b);if(0<=this.position&&1>=this.position)this.colour=a?\"object\"==typeof a?a:new Colour(a):new Colour(\"#000000\");else throw\"Invalid Colour Position: \"+b;} function Colour(a){\"undefined\"==typeof a?this.set(\"#ffffff\"):\"string\"==typeof a?this.set(a):\"object\"==typeof a?\"undefined\"!=typeof a.H?this.setHSV(a):\"undefined\"!=typeof a.red?(this.red=a.red,this.green=a.green,this.blue=a.blue,this.alpha=a.alpha):a.R?(this.red=a.R,this.green=a.G,this.blue=a.B,this.alpha=\"undefined\"==typeof a.A?1:a.A):(this.red=a[0],this.green=a[1],this.blue=a[2],1>=this.red&&1>=this.green&&1>=this.blue&&(this.red=Math.round(255*this.red),this.green=Math.round(255*this.green),this.blue= Math.round(255*this.blue)),this.alpha=\"undefined\"==typeof a[3]?1:a[3]):this.fromInt(a);1<this.alpha&&(this.alpha/=255)} Colour.prototype.set=function(a){a||(a=\"#ffffff\");var b=/^rgba?\\((\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,?\\s*(\\d\\.?\\d*)?\\)$/.exec(a);b?(this.red=parseInt(b[1]),this.green=parseInt(b[2]),this.blue=parseInt(b[3]),this.alpha=\"undefined\"==typeof b[4]?1:parseFloat(b[4])):\"#\"==a.charAt(0)?(a=a.substring(1,7),this.alpha=1,this.red=parseInt(a.substring(0,2),16),this.green=parseInt(a.substring(2,4),16),this.blue=parseInt(a.substring(4,6),16)):this.fromInt(parseInt(a));1<this.alpha&&(this.alpha/=255)}; Colour.prototype.fromInt=function(a){this.red=a&255;this.green=(a&65280)>>>8;this.blue=(a&16711680)>>>16;this.alpha=((a&4278190080)>>>24)/255};Colour.prototype.toInt=function(){var a=this.red,a=a+(this.green<<8),a=a+(this.blue<<16);return a+=Math.round(255*this.alpha)<<24};Colour.prototype.toString=function(){return this.html()};Colour.prototype.html=function(){return\"rgba(\"+this.red+\",\"+this.green+\",\"+this.blue+\",\"+this.alpha.toFixed(2)+\")\"}; Colour.prototype.rgbaGL=function(){return new Float32Array([this.red/255,this.green/255,this.blue/255,this.alpha])};Colour.prototype.rgbaGLSL=function(){var a=this.rgbaGL();return\"rgba(\"+a[0].toFixed(4)+\",\"+a[1].toFixed(4)+\",\"+a[2].toFixed(4)+\",\"+a[3].toFixed(4)+\")\"};Colour.prototype.rgba=function(){return[this.red/255,this.green/255,this.blue/255,this.alpha]};Colour.prototype.rgbaObj=function(){return{R:this.red,G:this.green,B:this.blue,A:this.alpha}};Colour.prototype.print=function(){OK.debug(this.printString(!0))}; Colour.prototype.printString=function(a){return\"R:\"+this.red+\" G:\"+this.green+\" B:\"+this.blue+(a?\" A:\"+this.alpha:\"\")};Colour.prototype.HEX=function(a){a=Math.round(Math.min(Math.max(0,a),255));return\"0123456789ABCDEF\".charAt((a-a%16)/16)+\"0123456789ABCDEF\".charAt(a%16)};Colour.prototype.htmlHex=function(a){return\"#\"+this.HEX(this.red)+this.HEX(this.green)+this.HEX(this.blue)};Colour.prototype.hex=function(a){return this.HEX(this.red)+this.HEX(this.green)+this.HEX(this.blue)+this.HEX(255*this.alpha)}; Colour.prototype.hexGL=function(a){return this.HEX(255*this.alpha)+this.HEX(this.blue)+this.HEX(this.green)+this.HEX(this.red)}; Colour.prototype.setHSV=function(a){var b,c,d,e,f;f=a.S/100;var g=a.V/100,h=a.H/360;if(0<f){1<=h&&(h=0);h*=6;F=h-Math.floor(h);d=Math.round(255*g*(1-f));e=Math.round(255*g*(1-f*F));f=Math.round(255*g*(1-f*(1-F)));g=Math.round(255*g);switch(Math.floor(h)){case 0:b=g;c=f;e=d;break;case 1:b=e;c=g;e=d;break;case 2:b=d;c=g;e=f;break;case 3:b=d;c=e;e=g;break;case 4:b=f;c=d;e=g;break;case 5:b=g,c=d}this.red=b?b:0;this.green=c?c:0;this.blue=e?e:0}else this.blue=this.green=this.red=g=Math.round(255*g);this.alpha= \"undefined\"==typeof a.A?1:a.A};Colour.prototype.HSV=function(){var a=this.red/255,b=this.green/255,c=this.blue/255,d=Math.max(a,b,c);deltaMax=d-Math.min(a,b,c);var e,f,g,h,k;0==deltaMax?e=f=0:(e=deltaMax/d,g=((d-a)/6+deltaMax/2)/deltaMax,h=((d-b)/6+deltaMax/2)/deltaMax,k=((d-c)/6+deltaMax/2)/deltaMax,a==d?f=k-h:b==d?f=1/3+g-k:c==d&&(f=2/3+h-g),0>f&&(f+=1),1<f&&--f);return{H:360*f,S:100*e,V:100*d}};Colour.prototype.HSVA=function(){var a=this.HSV();a.A=this.alpha;return a}; Colour.prototype.interpolate=function(a,b){this.red=Math.round(this.red+b*(a.red-this.red));this.green=Math.round(this.green+b*(a.green-this.green));this.blue=Math.round(this.blue+b*(a.blue-this.blue));this.alpha=Math.round(this.alpha+b*(a.alpha-this.alpha))};Colour.prototype.blend=function(a){return new Colour([Math.round((1-a.alpha)*this.red+a.alpha*a.red),Math.round((1-a.alpha)*this.green+a.alpha*a.green),Math.round((1-a.alpha)*this.blue+a.alpha*a.blue),(1-a.alpha)*this.alpha+a.alpha*a.alpha])}; function MoveWindow(a){if(a){this.element=document.getElementById(a);if(!this.element)return alert(\"No such element: \"+a),null;this.mouse=new Mouse(this.element,this);this.mouse.moveUpdate=!0;this.element.mouse=this.mouse}} MoveWindow.prototype.open=function(a,b){var c=this.element.style;0>a&&(a=0);0>b&&(b=0);void 0!=a&&(c.left=a+\"px\");void 0!=b&&(c.top=b+\"px\");c.display=\"block\";var d=this.element.offsetWidth,e=this.element.offsetHeight;a+d>window.innerWidth-20&&(c.left=window.innerWidth-d-20+\"px\");b+e>window.innerHeight-20&&(c.top=window.innerHeight-e-20+\"px\")};MoveWindow.prototype.close=function(){this.element.style.display=\"none\"}; MoveWindow.prototype.move=function(a,b){if(b.isdown&&!(0<b.button)){var c=b.element.style;c.left=parseInt(c.left)+b.deltaX+\"px\";c.top=parseInt(c.top)+b.deltaY+\"px\"}};MoveWindow.prototype.down=function(a,b){return!1};function scale(a,b,c,d){return clamp(d*a/b,c,d)}function clamp(a,b,c){return Math.max(b,Math.min(c,a))} function ColourPicker(a,b){function c(a,b,c){var d=document.createElement(\"div\");d.id=a;b&&(d.innerHTML=b);c&&(d.style.cssText=c);return d}var d=document.getElementById(\"picker\");if(d&&d.picker)return d.picker.savefn=a,d.picker.abortfn=b,d.picker;d=document.body;this.element=c(\"picker\",null,\"display:none; top: 58px; z-index: 20; background: #0d0d0d; color: #aaa; cursor: move; font-family: arial; font-size: 11px; padding: 7px 10px 11px 10px; position: fixed; width: 232px; border-radius: 5px; border: 1px solid #444;\"); var e=c(\"pickCURBG\",null,'background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAIElEQVQ4jWP4TwAcOHAAL2YYNWBYGEBIASEwasCwMAAALvidroqDalkAAAAASUVORK5CYII=\"); float: left; width: 12px; height: 12px; margin-right: 3px;');e.appendChild(c(\"pickCUR\",null,\"float: left; width: 12px; height: 12px; background: #fff; margin-right: 3px;\"));this.element.appendChild(e);e=c(\"pickRGB\",\"R: 255 G: 255 B: 255\",\"float: left; position: relative; top: -1px;\");e.onclick=\"colours.picker.updateString()\"; this.element.appendChild(e);this.element.appendChild(c(\"pickCLOSE\",\"X\",\"float: right; cursor: pointer; margin: 0 8px 3px;\"));this.element.appendChild(c(\"pickOK\",\"OK\",\"float: right; cursor: pointer; margin: 0 8px 3px;\"));e=c(\"SV\",null,\"position: relative; cursor: crosshair; float: left; height: 170px; width: 170px; margin-right: 10px; background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAEG0lEQVQ4jQEQBO/7APz8/Pz7+/vx+/v75Pr6+tb6+vrF+Pj4tPf396H4+PiO9/f3e/X19Wfz8/NU8PDwQuvr6zLi4uIjzs7OFZmZmQoA8PDw/O/v7/Ht7e3l7Ozs2Ozs7Mjq6uq35ubmpeXl5ZLf39+A3NzcbtXV1VvMzMxLvr6+O6ioqCyEhIQfQEBAFADk5OT84eHh8uDg4Obe3t7Z3Nzcy9nZ2brV1dWq0NDQmcrKyofCwsJ2uLi4ZKqqqlSYmJhFfX19N1lZWSsnJychANPT0/zT09Pz0NDQ6c3NzdzKysrNx8fHv8DAwK+6urqfsrKyj6mpqX+cnJxvjIyMX3l5eVBeXl5EPz8/ORsbGy8Aw8PD/MHBwfS+vr7qurq63ra2ttKxsbHErKystaOjo6eampqXj4+PiYODg3lycnJrXl5eX0hISFIuLi5IEBAQPwCwsLD9r6+v9aysrOynp6fioqKi1p2dncmVlZW8jo6OroODg6F5eXmUa2trhl1dXXlLS0ttNzc3YiIiIlkNDQ1RAJ6env2bm5v2l5eX7pSUlOWPj4/aiIiIz4GBgcN5eXm3cHBwq2RkZJ5XV1eSSkpKhzk5OX0qKipzGBgYawgICGMAioqK/YeHh/eDg4PvgICA6Hp6et90dHTVbW1ty2VlZcBcXFy1UVFRqkZGRqA6OjqWLS0tjSEhIYQSEhJ9BgYGdwB2dnb+c3Nz+HFxcfJra2vrZmZm42JiYttaWlrRUlJSyUtLS79CQkK2Nzc3rS0tLaQiIiKdGBgYlQ4ODo8EBASKAGNjY/5gYGD5XV1d9FpaWu5VVVXnTk5O4UlJSdlCQkLRPDw8yTQ0NMEqKiq7IiIisxkZGa0RERGmCgoKoQMDA5wAUFBQ/k9PT/pKSkr3R0dH8kNDQ+w+Pj7mOTk54DMzM9otLS3TJycnzSAgIMgZGRnBExMTvA0NDbcHBweyAwMDrwA9PT3+PDw8+zo6Ovg2Njb0MzMz8DAwMOwqKirnJSUl4iEhId4cHBzYFxcX1BISEtAODg7KCQkJxwQEBMQBAQHBAC0tLf4rKyv9Kioq+iYmJvclJSX0ISEh8R4eHu4aGhrqFhYW5xMTE+MQEBDgDQ0N3AgICNkGBgbWBAQE0wAAANEAHh4e/h0dHf0bGxv7Ghoa+hgYGPcWFhb2FBQU8xEREfEPDw/uDAwM7AoKCuoICAjoBgYG5gMDA+MBAQHiAAAA4QARERH+EBAQ/g8PD/0NDQ38DQ0N+wsLC/kKCgr4CAgI9wcHB/YFBQX0BAQE8wICAvIBAQHwAQEB7wAAAO8AAADuAAUFBf4FBQX+BAQE/gQEBP4DAwP+AwMD/QMDA/0CAgL8AQEB/AEBAfsAAAD7AAAA+wAAAPoAAAD6AAAA+QAAAPmq2NbsCl2m4wAAAABJRU5ErkJggg==') no-repeat; background-size: 100%;\"); e.appendChild(c(\"SVslide\",null,\"background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAALUlEQVQYlWNgQAX/kTBW8B8ZYFMIk0ARQFaIoQCbQuopIspNRPsOrpABSzgBAFHzU61KjdKlAAAAAElFTkSuQmCC'); height: 9px; width: 9px; position: absolute; cursor: crosshair\"));this.element.appendChild(e);e=c(\"H\",null,'cursor: crosshair; float: left; height: 170px; position: relative; width: 19px; padding: 0;background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAIElEQVQ4jWP4TwAcOHAAL2YYNWBYGEBIASEwasCwMAAALvidroqDalkAAAAASUVORK5CYII=\");'); e.appendChild(c(\"Hmodel\",null,\"position: relative;\"));e.appendChild(c(\"Hslide\",null,'top: 0px; left: -5px; background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAFCAYAAAC5Fuf5AAAAKklEQVQokWP4////fwY6gv////9n+A8F9LIQxVJaW4xiz4D5lB4WIlsMAPjER7mTpG/OAAAAAElFTkSuQmCC\"); height: 5px; width: 29px; position: absolute; '));this.element.appendChild(e);e=c(\"O\",null,'cursor: crosshair; float: left; height: 170px; position: relative; width: 19px; padding: 0;background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAIElEQVQ4jWP4TwAcOHAAL2YYNWBYGEBIASEwasCwMAAALvidroqDalkAAAAASUVORK5CYII=\");border: 1px solid #888; left: 9px;'); e.appendChild(c(\"Omodel\",null,\"position: relative;\"));e.appendChild(c(\"Oslide\",null,'top: 0px; left: -5px; background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAFCAYAAAC5Fuf5AAAAKklEQVQokWP4////fwY6gv////9n+A8F9LIQxVJaW4xiz4D5lB4WIlsMAPjER7mTpG/OAAAAAElFTkSuQmCC\"); height: 5px; width: 29px; position: absolute; '));this.element.appendChild(e);d.appendChild(this.element);d=document.createElement(\"style\");d.styleSheet?d.styleSheet.cssText=\"#pickRGB:hover {color: #FFD000;} #pickCLOSE:hover {color: #FFD000;} #pickOK:hover {color: #FFD000;}\": d.appendChild(document.createTextNode(\"#pickRGB:hover {color: #FFD000;} #pickCLOSE:hover {color: #FFD000;} #pickOK:hover {color: #FFD000;}\"));document.getElementsByTagName(\"head\")[0].appendChild(d);MoveWindow.call(this,\"picker\");this.savefn=a;this.abortfn=b;this.size=170;this.sv=5;this.oh=2;this.picked={H:360,S:100,V:100,A:1};this.max={H:360,S:100,V:100,A:1};this.colour=new Colour;for(var e=\"\",f,d=0;d<=this.size;d++)f=new Colour({H:Math.round(360/this.size*d),S:100,V:100,A:1}),e+=\"<div class='hue' style='height: 1px; width: 19px; margin: 0; padding: 0; background: \"+ f.htmlHex()+\";'> </div>\";document.getElementById(\"Hmodel\").innerHTML=e;e=\"\";for(d=0;d<=this.size;d++)f=1-d/this.size,e+=\"<div class='opacity' style='height: 1px; width: 19px; margin: 0; padding: 0; background: #000;opacity: \"+f.toFixed(2)+\";'> </div>\";document.getElementById(\"Omodel\").innerHTML=e;this.element.picker=this}ColourPicker.prototype=new MoveWindow;ColourPicker.prototype.constructor=MoveWindow; ColourPicker.prototype.pick=function(a,b,c){this.update(a.HSVA());\"block\"!=this.element.style.display&&MoveWindow.prototype.open.call(this,b,c)};ColourPicker.prototype.select=function(a,b,c){if(!b||!c){var d=a.getBoundingClientRect();b=b?b:d.left+32;c=c?c:d.top+32}d=new Colour(a.style.backgroundColor);this.update(d.HSVA());\"block\"!=this.element.style.display&&(MoveWindow.prototype.open.call(this,b,c),this.target=a)}; ColourPicker.prototype.click=function(a,b){if(\"pickCLOSE\"==b.target.id)this.abortfn&&this.abortfn(),toggle(\"picker\");else if(\"pickOK\"==b.target.id){this.savefn&&this.savefn(this.picked);if(this.target){var c=new Colour(this.picked);this.target.style.backgroundColor=c.html()}toggle(\"picker\")}else\"SV\"==b.target.id?this.setSV(b):\"Hslide\"==b.target.id||\"hue\"==b.target.className?this.setHue(b):\"Oslide\"!=b.target.id&&\"opacity\"!=b.target.className||this.setOpacity(b)}; ColourPicker.prototype.move=function(a,b){b.isdown&&0==b.button&&(\"picker\"==b.target.id||\"pickCUR\"==b.target.id||\"pickRGB\"==b.target.id?MoveWindow.prototype.move.call(this,a,b):b.target&&this.click(a,b))};ColourPicker.prototype.wheel=function(a,b){this.incHue(-a.spin)}; ColourPicker.prototype.setSV=function(a){var b=document.getElementById(\"SV\").getBoundingClientRect(),c=a.absoluteX-parseInt(b.left);a=a.absoluteY-parseInt(b.top);this.picked.S=scale(c,this.size,0,this.max.S);this.picked.V=this.max.V-scale(a,this.size,0,this.max.V);this.update(this.picked)};ColourPicker.prototype.setHue=function(a){var b=document.getElementById(\"H\").getBoundingClientRect();parseInt(b.left);a=a.absoluteY-parseInt(b.top);this.picked.H=scale(a,this.size,0,this.max.H);this.update(this.picked)}; ColourPicker.prototype.incHue=function(a){this.picked.H+=a;this.picked.H=clamp(this.picked.H,0,this.max.H);this.update(this.picked)};ColourPicker.prototype.setOpacity=function(a){var b=document.getElementById(\"O\").getBoundingClientRect();parseInt(b.left);a=a.absoluteY-parseInt(b.top);this.picked.A=1-clamp(a/this.size,0,1);this.update(this.picked)};ColourPicker.prototype.updateString=function(a){a||(a=prompt(\"Edit colour:\",this.colour.html()));a&&(this.colour=new Colour(a),this.update(this.colour.HSV()))}; ColourPicker.prototype.update=function(a){this.picked=a;this.colour=new Colour(a);rgba=this.colour.rgbaObj();rgbaStr=this.colour.html();bgcol=new Colour({H:a.H,S:100,V:100,A:255});document.getElementById(\"pickRGB\").innerHTML=this.colour.printString();document.getElementById(\"pickCUR\").style.background=rgbaStr;document.getElementById(\"pickCUR\").style.backgroundColour=rgbaStr;document.getElementById(\"SV\").style.backgroundColor=bgcol.htmlHex();document.getElementById(\"Hslide\").style.top=a.H/360*this.size- this.oh+\"px\";document.getElementById(\"SVslide\").style.top=Math.round(this.size-a.V/100*this.size-this.sv)+\"px\";document.getElementById(\"SVslide\").style.left=Math.round(a.S/100*this.size-this.sv)+\"px\";document.getElementById(\"Oslide\").style.top=this.size*(1-a.A)-this.oh-1+\"px\"}; function GradientEditor(a,b,c,d,e){this.canvas=a;this.callback=b;this.premultiply=c;this.changed=!0;this.inserting=!1;this.element=this.editing=null;this.spin=0;this.scrollable=e;d||(this.picker=new ColourPicker(this.save.bind(this),this.cancel.bind(this)));this.palette=new Palette(null,c);this.canvas.mouse=new Mouse(this.canvas,this);this.canvas.oncontextmenu=\"return false;\";this.canvas.oncontextmenu=function(){return!1}} GradientEditor.prototype.read=function(a){this.palette=new Palette(a,this.premultiply);this.reset();this.update(!0)};GradientEditor.prototype.update=function(a){this.changed=!0;this.palette.draw(this.canvas,!0);!a&&this.callback&&this.callback(this)};GradientEditor.prototype.get=function(a,b){if(b&&!this.changed)return!1;this.changed=!1;this.palette.draw(a,!1);return!0}; GradientEditor.prototype.insert=function(a,b,c){this.inserting=!0;var d=new Colour;this.editing=this.palette.newColour(a,d);this.update();this.picker=new ColourPicker(this.save.bind(this),this.cancel.bind(this));this.picker.pick(d,b,c)};GradientEditor.prototype.editBackground=function(a){this.editing=-1;this.element=a;this.picker=new ColourPicker(this.save.bind(this),this.cancel.bind(this));a=a.getBoundingClientRect();this.picker.pick(this.palette.background,a.left+32,a.top+32)}; GradientEditor.prototype.edit=function(a,b,c){this.picker=new ColourPicker(this.save.bind(this),this.cancel.bind(this));\"number\"==typeof a?(this.editing=a,this.picker.pick(this.palette.colours[a].colour,b,c)):\"object\"==typeof a&&(this.cancel(),this.element=a,b=new Colour(a.style.backgroundColor),a=a.getBoundingClientRect(),this.picker.pick(b,a.left+32,a.top+32));this.update()}; GradientEditor.prototype.save=function(a){null!=this.editing&&(0<=this.editing?this.palette.colours[this.editing].colour.setHSV(a):this.palette.background.setHSV(a));if(this.element){var b=new Colour(0);b.setHSV(a);this.element.style.backgroundColor=b.html();if(this.element.onchange)this.element.onchange()}this.reset();this.update()};GradientEditor.prototype.cancel=function(){0<=this.editing&&this.inserting&&this.palette.remove(this.editing);this.reset();this.update()}; GradientEditor.prototype.reset=function(){this.inserting=!1;this.element=this.editing=null}; GradientEditor.prototype.click=function(a,b){if(a.ctrlKey){for(var c=0;c<this.palette.colours.length;c++)this.palette.colours[c].position=1-this.palette.colours[c].position;this.update();return!1}if(null!=b.slider)return b.slider=null,this.palette.sort(),this.update(),!1;var d=this.canvas;if(d.getContext){this.cancel();d.getContext(\"2d\");var e=d.getBoundingClientRect().top+30,c=this.palette.inRange(b.x,this.palette.slider.width,d.width);0<=c?0==a.button?this.edit(c,a.clientX-128,e):2==a.button&&(this.palette.remove(c), this.update()):this.insert(b.x/d.width,a.clientX-128,e)}return!1};GradientEditor.prototype.down=function(a,b){return!1};GradientEditor.prototype.move=function(a,b){if(!b.isdown)return!0;if(null==b.slider){var c=this.palette.inDragRange(b.x,this.palette.slider.width,this.canvas.width);0<c&&(b.slider=c)}null==b.slider?b.isdown=!1:(1>b.x&&(b.x=1),b.x>this.canvas.width-1&&(b.x=this.canvas.width-1),this.palette.colours[b.slider].position=b.x/this.canvas.width,this.update(!0))}; GradientEditor.prototype.wheel=function(a,b){this.timer?clearTimeout(this.timer):this.canvas.style.cursor=\"wait\";this.spin+=.01*a.spin;var c=this;this.timer=setTimeout(function(){c.cycle(c.spin);c.spin=0},150)};GradientEditor.prototype.leave=function(a,b){}; GradientEditor.prototype.cycle=function(a){this.canvas.style.cursor=\"default\";this.timer=null;for(var b=1;b<this.palette.colours.length-1;b++){var c=this.palette.colours[b].position,c=c+a;0>=c&&(c+=1);1<=c&&--c;this.palette.colours[b].position=c}this.palette.sort();this.update()}; //Bounding box only in WebGL //Urgent TODO: move shared code with draw.js into common file //maintaining two copies currently! function initBox(el, cmd_callback) { //console.log(\"INITBOX: \" + el.id); var canvas = document.createElement(\"canvas\"); if (!el) el = document.body.firstChild; canvas.id = \"canvas_\" + el.id; canvas.imgtarget = el el.parentElement.appendChild(canvas); canvas.style.cssText = \"position: absolute; width: 100%; height: 100%; margin: 0px; padding: 0px; top: 0; left: 0; bottom: 0; right: 0; z-index: 11; border: none;\" viewer = new BoxViewer(canvas); //Canvas event handling canvas.mouse = new Mouse(canvas, new MouseEventHandler(canvasBoxMouseClick, canvasBoxMouseWheel, canvasBoxMouseMove, canvasBoxMouseDown, null, null, canvasBoxMousePinch)); //Following two settings should probably be defaults? canvas.mouse.moveUpdate = true; //Continual update of deltaX/Y //canvas.mouse.setDefault(); canvas.mouse.wheelTimer = true; //Accumulate wheel scroll (prevents too many events backing up) defaultMouse = document.mouse = canvas.mouse; //Attach viewer object to canvas canvas.viewer = viewer; //Command callback function viewer.command = cmd_callback; return viewer; } function updateBox(viewer, loaderfn) { if (!viewer) return; //Loader callback loaderfn(function(data) {viewer.loadFile(data);}); } function canvasBoxMouseClick(event, mouse) { if (mouse.element.viewer.rotating) mouse.element.viewer.command('' + mouse.element.viewer.getRotationString()); else mouse.element.viewer.command('' + mouse.element.viewer.getTranslationString()); if (mouse.element.viewer.rotating) { mouse.element.viewer.rotating = false; //mouse.element.viewer.reload = true; } //Clear the webgl box mouse.element.viewer.clear(); return false; } function canvasBoxMouseDown(event, mouse) { return false; } var hideBoxTimer; function canvasBoxMouseMove(event, mouse) { if (mouse.element && mouse.element.imgtarget) { var rect = mouse.element.getBoundingClientRect(); x = event.clientX-rect.left; y = event.clientY-rect.top; if (x >= 0 && y >= 0 && x < rect.width && y < rect.height) { mouse.element.imgtarget.nextElementSibling.style.display = \"block\"; if (hideBoxTimer) clearTimeout(hideBoxTimer); hideBoxTimer = setTimeout(function () {mouse.element.imgtarget.nextElementSibling.style.display = \"none\";}, 1000 ); } } if (!mouse.isdown || !mouse.element.viewer) return true; mouse.element.viewer.rotating = false; //Switch buttons for translate/rotate var button = mouse.button; if (mouse.element.viewer.mode == \"Translate\") { //Swap rotate/translate buttons if (button == 0) button = 2 else if (button == 2) button = 0; } else if (button==0 && mouse.element.viewer.mode == \"Zoom\") { button = 100; } //console.log(mouse.deltaX + \",\" + mouse.deltaY); switch (button) { case 0: mouse.element.viewer.rotateY(mouse.deltaX/5); mouse.element.viewer.rotateX(mouse.deltaY/5); mouse.element.viewer.rotating = true; break; case 1: mouse.element.viewer.rotateZ(Math.sqrt(mouse.deltaX*mouse.deltaX + mouse.deltaY*mouse.deltaY)/5); mouse.element.viewer.rotating = true; break; case 2: var adjust = mouse.element.viewer.modelsize / 1000; //1/1000th of size mouse.element.viewer.translate[0] += mouse.deltaX * adjust; mouse.element.viewer.translate[1] -= mouse.deltaY * adjust; break; case 100: var adjust = mouse.element.viewer.modelsize / 1000; //1/1000th of size mouse.element.viewer.translate[2] += mouse.deltaX * adjust; break; } mouse.element.viewer.draw(); return false; } var zoomBoxTimer; var zoomBoxClipTimer; var zoomBoxSpin = 0; function canvasBoxMouseWheel(event, mouse) { if (event.shiftKey) { var factor = event.spin * 0.01; if (zoomBoxClipTimer) clearTimeout(zoomBoxClipTimer); zoomBoxClipTimer = setTimeout(function () {mouse.element.viewer.zoomClip(factor);}, 100 ); } else { if (zoomBoxTimer) clearTimeout(zoomBoxTimer); zoomBoxSpin += event.spin; zoomBoxTimer = setTimeout(function () {mouse.element.viewer.zoom(zoomBoxSpin*0.01); zoomBoxSpin = 0;}, 100 ); //Clear the box after a second setTimeout(function() {mouse.element.viewer.clear();}, 1000); } return false; //Prevent default } function canvasBoxMousePinch(event, mouse) { if (event.distance != 0) { var factor = event.distance * 0.0001; mouse.element.viewer.zoom(factor); //Clear the box after a second setTimeout(function() {mouse.element.viewer.clear();}, 1000); } return false; //Prevent default } //This object encapsulates a vertex buffer and shader set function BoxRenderer(gl, colour) { this.gl = gl; if (colour) this.colour = colour; //Line renderer this.attribSizes = [3 * Float32Array.BYTES_PER_ELEMENT]; this.elements = 0; this.elementSize = 0; for (var i=0; i<this.attribSizes.length; i++) this.elementSize += this.attribSizes[i]; } BoxRenderer.prototype.init = function() { //Compile the shaders this.program = new WebGLProgram(this.gl, \"line-vs\", \"line-fs\"); if (this.program.errors) console.log(this.program.errors); //Setup attribs/uniforms (flag set to skip enabling attribs) this.program.setup(undefined, undefined, true); return true; } BoxRenderer.prototype.updateBuffers = function(view) { //Create buffer if not yet allocated if (this.vertexBuffer == undefined) { //Init shaders etc... if (!this.init()) return; this.vertexBuffer = this.gl.createBuffer(); this.indexBuffer = this.gl.createBuffer(); } //Bind buffers this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer); this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); this.box(view.min, view.max); this.elements = 24; } BoxRenderer.prototype.box = function(min, max) { var vertices = new Float32Array( [ min[0], min[1], max[2], min[0], max[1], max[2], max[0], max[1], max[2], max[0], min[1], max[2], min[0], min[1], min[2], min[0], max[1], min[2], max[0], max[1], min[2], max[0], min[1], min[2] ]); var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 3, 7, 1, 5, 2, 6 ] ); this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW); this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indices, this.gl.STATIC_DRAW); } BoxRenderer.prototype.draw = function(webgl) { if (!this.elements) return; if (this.program.attributes[\"aVertexPosition\"] == undefined) return; //Require vertex buffer webgl.use(this.program); webgl.setMatrices(); //Bind buffers this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer); this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); //Enable attributes for (var key in this.program.attributes) this.gl.enableVertexAttribArray(this.program.attributes[key]); if (this.colour) this.gl.uniform4f(this.program.uniforms[\"uColour\"], this.colour[0], this.colour[1], this.colour[2], this.colour[3]); //Line box render this.gl.vertexAttribPointer(this.program.attributes[\"aVertexPosition\"], 3, this.gl.FLOAT, false, 0, 0); this.gl.drawElements(this.gl.LINES, this.elements, this.gl.UNSIGNED_SHORT, 0); //Disable attribs for (var key in this.program.attributes) this.gl.disableVertexAttribArray(this.program.attributes[key]); this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null); this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null); this.gl.useProgram(null); } //This object holds the viewer details and calls the renderers function BoxViewer(canvas) { this.canvas = canvas; if (!canvas) {alert(\"Invalid Canvas\"); return;} try { this.webgl = new WebGL(this.canvas, {antialias: true}); //, premultipliedAlpha: false}); this.gl = this.webgl.gl; canvas.addEventListener(\"webglcontextlost\", function(event) { event.preventDefault(); console.log(\"CONTEXT LOSS DETECTED\"); }, false); } catch(e) { //No WebGL console.log(\"No WebGL: \" + e); } this.vis = {}; this.view = 0; //Active view this.rotating = false; this.translate = [0,0,0]; this.rotate = quat4.create(); quat4.identity(this.rotate); this.fov = 45; this.focus = [0,0,0]; this.centre = [0,0,0]; this.near_clip = this.far_clip = 0.0; this.modelsize = 1; this.scale = [1, 1, 1]; this.orientation = 1.0; //1.0 for RH, -1.0 for LH if (!this.gl) return; //Create the renderers this.border = new BoxRenderer(this.gl, [0.5,0.5,0.5,1]); this.gl.enable(this.gl.DEPTH_TEST); this.gl.depthFunc(this.gl.LEQUAL); //this.gl.depthMask(this.gl.FALSE); this.gl.enable(this.gl.BLEND); //this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA); //this.gl.blendFuncSeparate(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ZERO, this.gl.ONE); this.gl.blendFuncSeparate(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA); } BoxViewer.prototype.checkPointMinMax = function(coord) { for (var i=0; i<3; i++) { this.vis.views[this.view].min[i] = Math.min(coord[i], this.vis.views[this.view].min[i]); this.vis.views[this.view].max[i] = Math.max(coord[i], this.vis.views[this.view].max[i]); } //console.log(JSON.stringify(this.vis.views[this.view].min) + \" -- \" + JSON.stringify(this.vis.views[this.view].max)); } BoxViewer.prototype.loadFile = function(source) { //Skip update to rotate/translate etc if in process of updating //if (document.mouse.isdown) return; //Replace data this.vis = JSON.parse(source); //Always set a bounding box, get from objects if not in view var objbb = false; if (!this.vis.views[this.view].min || !this.vis.views[this.view].max) { this.vis.views[this.view].min = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE]; this.vis.views[this.view].max = [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE]; objbb = true; } //console.log(JSON.stringify(this.vis.views[this.view],null, 2)); if (this.vis.views[this.view]) { this.fov = this.vis.views[this.view].aperture || 45; this.near_clip = this.vis.views[this.view].near || 0; this.far_clip = this.vis.views[this.view].far || 0; this.orientation = this.vis.views[this.view].orientation || 1; this.axes = this.vis.views[this.view].axis == undefined ? true : this.vis.views[this.view].axis; } if (this.vis.properties.resolution && this.vis.properties.resolution[0] && this.vis.properties.resolution[1]) { this.width = this.vis.properties.resolution[0]; this.height = this.vis.properties.resolution[1]; //this.canvas.style.width = \"\"; //this.canvas.style.height = \"\"; } else { //Autosize when img loaded this.width = 0; this.height = 0; } //Process object data for (var id in this.vis.objects) { //Apply object bounding box if (objbb && this.vis.objects[id].min) this.checkPointMinMax(this.vis.objects[id].min); if (objbb && this.vis.objects[id].max) this.checkPointMinMax(this.vis.objects[id].max); } this.updateDims(this.vis.views[this.view]); //Update display if (!this.gl) return; this.draw(); this.clear(); } BoxViewer.prototype.clear = function() { if (!this.gl) return; this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT); } BoxViewer.prototype.draw = function() { if (!this.canvas) return; //Get the dimensions from the current canvas if (this.width != this.canvas.offsetWidth || this.height != this.canvas.offsetHeight) { this.width = this.canvas.offsetWidth; this.height = this.canvas.offsetHeight; //Need to set this too for some reason this.canvas.width = this.width; this.canvas.height = this.height; if (this.gl) { this.gl.viewportWidth = this.width; this.gl.viewportHeight = this.height; this.webgl.viewport = new Viewport(0, 0, this.width, this.height); } } if (!this.gl) return; this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight); //this.gl.clearColor(1, 1, 1, 0); this.gl.clearColor(0, 0, 0, 0); this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT); this.webgl.view(this); //Render objects this.border.draw(this.webgl); } BoxViewer.prototype.rotateX = function(deg) { this.rotation(deg, [1,0,0]); } BoxViewer.prototype.rotateY = function(deg) { this.rotation(deg, [0,1,0]); } BoxViewer.prototype.rotateZ = function(deg) { this.rotation(deg, [0,0,1]); } BoxViewer.prototype.rotation = function(deg, axis) { //Quaterion rotate var arad = deg * Math.PI / 180.0; var rotation = quat4.fromAngleAxis(arad, axis); rotation = quat4.normalize(rotation); this.rotate = quat4.multiply(rotation, this.rotate); } BoxViewer.prototype.getRotation = function() { return [this.rotate[0], this.rotate[1], this.rotate[2], this.rotate[3]]; } BoxViewer.prototype.getRotationString = function() { //Return current rotation quaternion as string var q = this.getRotation(); return 'rotation ' + q[0] + ' ' + q[1] + ' ' + q[2] + ' ' + q[3]; } BoxViewer.prototype.getTranslationString = function() { return 'translation ' + this.translate[0] + ' ' + this.translate[1] + ' ' + this.translate[2]; } BoxViewer.prototype.reset = function() { if (this.gl) { this.updateDims(this.vis.views[this.view]); this.draw(); } this.command('reset'); } BoxViewer.prototype.zoom = function(factor) { if (this.gl) { this.translate[2] += factor * this.modelsize; this.draw(); } this.command('' + this.getTranslationString()); //this.command('zoom ' + factor); } BoxViewer.prototype.zoomClip = function(factor) { if (this.gl) { var near_clip = this.near_clip + factor * this.modelsize; if (near_clip >= this.modelsize * 0.001) this.near_clip = near_clip; this.draw(); } this.command('zoomclip ' + factor); } BoxViewer.prototype.updateDims = function(view) { if (!view) return; var oldsize = this.modelsize; this.dims = [view.max[0] - view.min[0], view.max[1] - view.min[1], view.max[2] - view.min[2]]; this.modelsize = Math.sqrt(this.dims[0]*this.dims[0] + this.dims[1]*this.dims[1] + this.dims[2]*this.dims[2]); this.focus = [view.min[0] + 0.5*this.dims[0], view.min[1] + 0.5*this.dims[1], view.min[2] + 0.5*this.dims[2]]; this.centre = [this.focus[0],this.focus[1],this.focus[2]]; this.translate = [0,0,0]; if (this.modelsize != oldsize) this.translate[2] = -this.modelsize*1.25; if (this.near_clip == 0.0) this.near_clip = this.modelsize / 10.0; if (this.far_clip == 0.0) this.far_clip = this.modelsize * 10.0; quat4.identity(this.rotate); if (view) { //Initial rotation if (view.rotate) { if (view.rotate.length == 3) { this.rotateZ(-view.rotate[2]); this.rotateY(-view.rotate[1]); this.rotateX(-view.rotate[0]); } else if (view.rotate.length == 4) { this.rotate = quat4.create(view.rotate); } } //Translate if (view.translate) { this.translate[0] = view.translate[0]; this.translate[1] = view.translate[1]; this.translate[2] = view.translate[2]; } //Scale if (view.scale) { this.scale[0] = view.scale[0]; this.scale[1] = view.scale[1]; this.scale[2] = view.scale[2]; } //Focal point if (view.focus) { this.focus[0] = this.centre[0] = view.focus[0]; this.focus[1] = this.centre[1] = view.focus[1]; this.focus[2] = this.centre[2] = view.focus[2]; } } //console.log(\"DIMS: \" + min[0] + \" to \" + max[0] + \",\" + min[1] + \" to \" + max[1] + \",\" + min[2] + \" to \" + max[2]); //console.log(\"New model size: \" + this.modelsize + \", Focal point: \" + this.focus[0] + \",\" + this.focus[1] + \",\" + this.focus[2]); //console.log(\"Translate: \" + this.translate[0] + \",\" + this.translate[1] + \",\" + this.translate[2]); if (!this.gl) return; //Create the bounding box vertex buffer this.border.updateBuffers(this.vis.views[this.view]); } //IPython kernel object var kernel; if (parent.IPython) { kernel = parent.IPython.notebook.kernel; } //Maintain a list of interactor instances opened by id //(check in case this script imported twice, don't overwrite previous) var _wi = window._wi ? window._wi : []; var delay = 0; var debug_mode = false; function exec_kernel(cmd) { //For debugging: //Run a python command in kernel and log output to console if (kernel) { if (debug_mode) { //Debug callback var callbacks = {'output' : function(out) { if (!out.content.data) {console.log(JSON.stringify(out)); return;} data = out.content.data['text/plain'] console.log(\"CMD: \" + cmd + \", RESULT: \" + data); } }; } kernel.execute(cmd, {iopub: callbacks}, {silent: false}); } } function getUrl() { var loc = window.location; var baseUrl = loc.protocol + \"//\" + loc.hostname + (loc.port ? \":\" + loc.port : \"\"); return baseUrl; } function WindowInteractor(id) { //Store self in list and save id this.id = id; console.log(\"New interactor: \" + this.id); //Interactor class, handles javascript side of window control //Takes viewer id // - set as active target for commands // - init webgl bounding box // - display initial image this.img = document.getElementById(\"imgtarget_\" + this.id); //No window if (!this.img) return; //Initial image //(Init WebGL bounding box interaction on load) var that = this; this.get_image(function() { //console.log('In image loaded callback ' + that.id); //Init on image load with callback function to execute commands that.box = initBox(that.img, function(cmd) {that.execute(cmd);}); //console.log(\"Box init on \" + that.id); //Update the box size by getting state updateBox(that.box, function(onget) {that.get_state(onget);}); //Clear onload that.img.onload = null; }); } //Load frame image and run command in single action (non-IPython mode only) var instant = true; WindowInteractor.prototype.execute = function(cmd, callback) { //console.log(\"execute: \" + cmd); if (kernel) { exec_kernel('lavavu.control.windows[' + this.id + '].commands(\"' + cmd + '\")'); //kernel.execute('lavavu.control.windows[' + this.id + '].commands(\"' + cmd + '\")'); this.get_image(callback); } else { //HTTP interface //Replace newlines with semi-colon first cmd = cmd.replace(/\\n/g,';'); if (instant && this.img) { var url = getUrl() + \"/icommand=\" + cmd + \"?\" + new Date().getTime(); this.img.onload = null; if (callback) this.img.onload = callback; this.img.src = url; } else { var url = getUrl() + \"/command=\" + cmd + \"?\" + new Date().getTime() x = new XMLHttpRequest(); x.open('GET', url, true); x.send(); this.get_image(callback); } } //Reload state if (this.img) { var that = this; updateBox(this.box, function(onget) {that.get_state(onget);}); } return false; } WindowInteractor.prototype.set_prop = function(obj, prop, val) { this.execute(\"select \" + obj + \"; \" + prop + \"=\" + val); this.get_image(); } WindowInteractor.prototype.do_action = function(id, val) { if (kernel) { //Non-numeric, add quotes and strip newlines if (typeof(val) == 'string' && (\"\" + parseFloat(val) !== val)) { val = val.replace(/\\n/g,';'); val = '\"' + val + '\"'; } //kernel.execute('cmds = lavavu.control.action(' + id + ',' + val + ')'); var cmd = 'cmds = lavavu.control.Action.do(' + id + ',' + val + ')'; exec_kernel(cmd); cmd = 'if cmds: lavavu.control.windows[' + this.id + '].commands(cmds)'; exec_kernel(cmd); this.get_image(); } else { //HTML control actions via http actions[id](val); } //Reload state if (this.img) { var that = this; updateBox(this.box, function(onget) {that.get_state(onget);}); } } WindowInteractor.prototype.redisplay = function() { //console.log(\"redisplay: \" + this.id); if (this.img) { //Call get_image this.get_image(); //Update the box size by getting state var that = this; updateBox(that.box, function(onget) {that.get_state(onget);}); } } WindowInteractor.prototype.get_image = function(onload) { if (!this.img) return; //console.log(\"get_img: \" + this.id); if (kernel) { var that = this; var callbacks = {'output' : function(out) { //Skip first message we get without data //if (!out.content.data) {console.log(JSON.stringify(out)); return;} if (!out.content.data) return; data = out.content.data['text/plain'] data = data.substring(1, data.length-1) //console.log(\"Got image: \" + data.length); if (that.img) { //Only set onload if provided if (onload) // && !that.img.onload) that.img.onload = onload; that.img.src = data; } } }; kernel.execute('lavavu.control.windows[' + this.id + '].frame()', {iopub: callbacks}, {silent: false}); } else { //if (!this.img) this.img = document.getElementById('imgtarget_0'); var url = getUrl() + \"/image?\" + new Date().getTime(); if (this.img) { this.img.onload = onload; this.img.src = url; } } } WindowInteractor.prototype.get_state = function(onget) { //console.log(\"get_state: \" + this.id); if (kernel) { var callbacks = {'output' : function(out) { //if (!out.content.data) {console.log(JSON.stringify(out)); return;} if (!out.content.data) return; data = out.content.data['text/plain'] data = data.replace(/(?:\\\\n)+/g, \"\"); data = data.substring(1, data.length-1) onget(data); } }; kernel.execute('lavavu.control.windows[' + this.id + '].app.getState()', {iopub: callbacks}, {silent: false}); } else { var url = getUrl() + \"/getstate\" x = new XMLHttpRequest(); x.onload = function() { if(x.status == 200) onget(x.response); else console.log(\"Ajax Request Error: \" + url + \", returned status code \" + x.status + \" \" + x.statusText); } x.open('GET', url, true); x.send(); } } //Update controls from JSON data function updateControlValues(controls) { for (var c in controls) { var control = controls[c]; var els = document.getElementsByClassName(control[0]); for(var i = 0; i < els.length; i++) { //console.log(els[i].id + \" : \" + els[i].value + \" ==> \" + control[1]); if (els[i].type == 'checkbox') els[i].checked = control[1]; else els[i].value = control[1]; }; } } function getAndUpdateControlValues(names) { //Get the updated values if (kernel) { var callbacks = {'output' : function(out) { if (!out.content.data) {console.log(JSON.stringify(out)); return;} data = out.content.data['text/plain'] data = data.substring(1, data.length-1) data = data.replace(/(?:\\\\n)+/g, \"\"); data = data.replace(/'/g, '\"'); //console.log(data); updateControlValues(JSON.parse(data)); } }; kernel.execute('import json; json.dumps(lavavu.control.getcontrolvalues(\"' + names + '\"))', {iopub: callbacks}, {silent: false}); } else { //TODO: http version, need to request updated values from web server } } Rotate Translate Zoom We can retrieve a list of objects from a viewer by inspecting the \"objects\" property. References to these objects can be used to modify the object appearance, either directly or using controls. \u0002wzxhzdk:24\u0003 ['ScalarField_0', 'VectorArrows_1'] Interactive controls can be created to adjust visualisation parameters, here we control the opacity of the previously retrieved \"surf\" object and the global vector scaling parameter, changes will be reflected in the viewer window above: \u0002wzxhzdk:25\u0003 Opacity: Scale Arrows:","title":"Visualisation"},{"location":"UserGuide/07_Visualisation.html#visualisation","text":"The glucifer module provides visualisation capabilities for Underworld modelling. This notebook demonstrates: setting up figure objects drawing meshes, surfaces, points and vector arrows saving figures to file publication ready figures interactive viewer Keywords: visualisation, glucifer, 3D plots, interactive plots Note All classes and functions have corresponding docstrings which are available via the python help() function. import underworld as uw import glucifer","title":"Visualisation"},{"location":"UserGuide/07_Visualisation.html#the-figure","text":"The Figure class is the base container object for your glucifer visualisations. It provides the canvas to which you will add the renderings from your drawing objects. newfigure = glucifer.Figure()","title":"The Figure"},{"location":"UserGuide/07_Visualisation.html#drawing-objects","text":"Drawing objects are the items that are rendered within a Figure . Available drawing objects (and associated documentation) may be found within the glucifer.objects Rendered API documentation for glucifer objects may be found at: http://underworld2.readthedocs.io/en/latest/glucifer.objects.html Mesh Render mesh geometry and node indices. Note, the append() method is used to attach this drawing object to a figure object lists of drawing objects. # create mesh and display it mesh = uw.mesh.FeMesh_Cartesian( 'Q1', (2,2), (0.,0.), (1.,1.) ) fig = glucifer.Figure ( edgecolour=\"black\") fig.Mesh( mesh, nodeNumbers=True ) fig.show() Surface This object will draw the desired faces of a scalar field. Check help(Surface) for the full options of the Surface drawing object. # create an object with a single value at each mesh point fevar = mesh.add_variable( 1 ) # give the variable some values fevar.data[:] = 0. fevar.data[0] = 10. fevar.data[4] = 30. fevar.data[8] = 10. fig = glucifer.Figure ( edgecolour=\"black\" ) fig.Surface( mesh, fevar, colours=\"red yellow green\", onMesh=False ) fig.show() VectorArrows This object will draw an array of vector arrows across the image using the provided vector field to determine their direction. Check help(VectorArrows) for the full options of the VectorArrows drawing object. # create a new meshvariable (note that it has 2 values at each mesh point) fevarVec = mesh.add_variable( 2 ) # initialise the vector field to something fevarVec.data[:] = [ 0., 0.] fevarVec.data[0] = [ 1., 1.] fevarVec.data[1] = [ 0., 1.] fevarVec.data[2] = [-1., 1.] fevarVec.data[3] = [ 1., 0.] fevarVec.data[5] = [-1., 0.] fevarVec.data[6] = [ 1.,-1.] fevarVec.data[7] = [ 0.,-1.] fevarVec.data[8] = [-1.,-1.] Create and show vector arrow figure. fig = glucifer.Figure( edgecolour=\"black\" ) fig.VectorArrows( mesh, fevarVec, scaling=0.1, arrowHead=0.2 ) fig.show() Points This object will draw a swarm of points using the provided Underworld swarm for the point locations and an Underworld swarm variable for the point colours (or size or opacity). Check help(Points) for the full options of the Points drawing object. Firstly, create a swarm over the whole mesh with 200 particles per cell. swarm = uw.swarm.Swarm( mesh=mesh ) layout = uw.swarm.layouts.PerCellSpaceFillerLayout( swarm=swarm, particlesPerCell=200 ) swarm.populate_using_layout( layout ) Plot the swarm particle distribution. fig = glucifer.Figure( edgecolour=\"blue\" ) fig.Points( swarm=swarm, pointSize=5, colourBar = False ) fig.show() Now add a swarm variable to define the colour. swarmVar = swarm.add_variable(\"double\",1) swarmVar.data[:] = 0. swarmVar.data[200:400] = 1. swarmVar.data[400:600] = 2. swarmVar.data[600:800] = 3. someFn = uw.function.coord()[0] Since there are 4 cells and 200 per cell we can divide the swarm up into 4 equal sections and give each a different colour. These will be randomly distributed around the figure. The fn_colour argument in the points object asigns colours to each swarm particle depending on the variable swarmVar . fn_colour accepts Function objects too and is a powerful tool to quickly visualise a model setup. fig = glucifer.Figure( edgecolour=\"black\" ) fig.Points(swarm=swarm, fn_colour=swarmVar, pointSize=10, colours='black red green blue') fig.show()","title":"Drawing Objects"},{"location":"UserGuide/07_Visualisation.html#image-layering","text":"Multiple drawing objects can, of course, be layered upon each other to build up complex images. This is achieved by making multiple calls append() fig = glucifer.Figure( edgecolour=\"black\" ) fig.VectorArrows( mesh, fevarVec, scaling=0.1, arrowHead=0.2, opacity=0.6 ) fig.Surface( mesh, fevar, colours=\"red yellow green\" ) fig.show()","title":"Image Layering"},{"location":"UserGuide/07_Visualisation.html#saving-results","text":"To output results to raster files (such as PNG), simply use the savefig() method. figfile = fig.save_image(\"savedfigure\") import glob import os if figfile: print(glob.glob( figfile )) ['savedfigure.png'] Let's clean up the directory by deleting this output figure file. if figfile: os.remove( figfile ) Likewise, for those who wish to utilise the native viewer, the database object can be saved using the saveDB() method: fig.save_database(\"dbFile.gldb\") print(glob.glob(\"dbFile.gldb\")) ['dbFile.gldb'] Again, let's clean up the local directory. os.remove( \"dbFile.gldb\" )","title":"Saving Results"},{"location":"UserGuide/07_Visualisation.html#publication-quality-figures","text":"With minor modifications gLucifer figures are easily made publication ready. Firstly, let's increase the image quality with the \"quality\" parameter. Values can be 1 (low) to 3 (high), but note that higher values can take longer to render, especially for large images. Here we also set the margin around the edges of the plot and apply rulers with tick labels. fig = glucifer.Figure(title=\"Test Plot\", quality=3, margin=0.078, rulers=True, rulerticks=5) Modifying surface plots Setup surface plot with colour gradient contrast bias towards more red (fix red as the colour for the value 25.0 by preceding the colour with this value in brackets) and some transparency (append a colon and the transparency value to the colour). surf = fig.Surface( mesh, fevar, colours=\"red (25.0)yellow:0.8 green:0.5\") Alter the properties of the colour bar associated with the surface plot. Here we set the number of tick marks to 3 and the values of the first and third ticks, modify the margin and width and set the alignment to right (available values: left/right [vertical], bottom/top [horizontal]). surf.colourBar[\"ticks\"] = 3 surf.colourBar[\"position\"] = 0.1 surf.colourBar[\"size\"] = [0.8,0.04] surf.colourBar[\"tickvalues\"] = [10, 25] surf.colourBar[\"align\"] = \"right\" Adding floating labels Labels can be added by specifying the label text and position. Font size can also be set with the \"scaling\" parameter. A single font size applies to all labels on an object, so changing the font scaling of the default object will change all labels already added - to add a different sized label we attach it to a the surface object instead. #Plot a label to the default figure object (fig.draw) fig.draw.label(\"Label1 @ Centre\", (0.2,0.7,0)) #Plot a lable to a previously added object surf.label(\"Label2 @ Centre\", (0.2,0.3,0), scaling=1.25) Plot final figure to screen. This can also be saved to PNG/JPEG or a WebGL visualisation. fig.show() Save a high resolution image The save image function takes an optional output width and height parameter (if width is provided without height, it will be calculated automatically) fig.save_image(\"highdef.png\", (1600,0)) 'highdef.png'","title":"Publication quality figures"},{"location":"UserGuide/07_Visualisation.html#interactivity-scripting","text":"An interactive viewer can be opened from inside the notebook by importing the \"lavavu\" module and using the figure's window() method: fig = glucifer.Figure( edgecolour=\"black\", quality=3 ) fig.Surface( mesh, fevar, colours=\"red yellow green\", colourBar = False ) fig.VectorArrows( mesh, fevarVec, scaling=0.1, arrowHead=0.2) <glucifer.objects.VectorArrows at 0x7f7c367bcdd0> Once this interactive viewer is open we can either shift the view using the mouse, or we can send commands to shift the view from inside the notebook. if not glucifer.lavavu: raise KeyboardInterrupt #Stop notebook here if no vis enabled lv = fig.window() lv.rotate('y', 45) lv.redisplay() .lvctrl input { display: inline; } .lvctrl input[type=range] { width: 200px; } .lvctrl input[type=button] { width: 100px; } .lvctrl input[type=number] { width: 120px; height: 28px; border-radius: 0; border: 1px dotted #999;} .lvctrl pre { display: inline; } .lvctrl p { color: gray; margin: 0px} /* Colour select */ .colourbg {display: inline-block; margin:5px 0px; width: 100px; height: 20px; border: 1px dotted #999; } .colour {display: inline-block; width: 100%; height: 100%; margin: 0px; padding: 0px; border: none;} .checkerboard {background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAIElEQVQ4jWP4TwAcOHAAL2YYNWBYGEBIASEwasCwMAAALvidroqDalkAAAAASUVORK5CYII=\");} .palette { margin: 3px; border:1px solid #000; border: 1px dotted #000;} .lvtab { border: 1px solid #999; padding: 5px; } .lvtabbar { width:100%; overflow:hidden; margin-top: 5px; } .lvtabbar .lvtabbar-item { padding:4px 8px; float:left; width:auto; border:none; outline:none; display:block; } .lvtabbar .dropdown-hover,.lvtabbar .dropdown-click { position:static; float:left; } .lvtabbar .lvbutton { white-space:normal; } .lvbutton:hover { color:#000!important; background-color:#ccc!important; border: 1px solid #999; border-bottom: 0; } .lvbutton { border: 1px solid #999; border-bottom: 0; border-radius: 5px 5px 0px 0px; margin-right: 3px; display:inline-block; outline:0; padding:4px 8px; vertical-align:middle; overflow:hidden; text-decoration:none; color:inherit; background-color:inherit; text-align:center; cursor:pointer; white-space:nowrap; } .lvseltab,.hover-lvseltab:hover { color:#fff!important; background-color:#555!important; } precision highp float; varying vec4 vColour; void main(void) { gl_FragColor = vColour; } precision highp float; //Line vertex shader attribute vec3 aVertexPosition; uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform vec4 uColour; varying vec4 vColour; void main(void) { vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0); gl_Position = uPMatrix * mvPosition; vColour = uColour; } // gl-matrix 1.3.7 - https://github.com/toji/gl-matrix/blob/master/LICENSE.md (function(w,D){\"object\"===typeof exports?module.exports=D(global):\"function\"===false/*OK: removed require.js support.. typeof define&&define.amd*/?define([],function(){return D(w)}):D(w)})(this,function(w){function D(a){return o=a}function G(){return o=\"undefined\"!==typeof Float32Array?Float32Array:Array}var E={};(function(){if(\"undefined\"!=typeof Float32Array){var a=new Float32Array(1),b=new Int32Array(a.buffer);E.invsqrt=function(c){a[0]=c;b[0]=1597463007-(b[0]>>1);var d=a[0];return d*(1.5-0.5*c*d*d)}}else E.invsqrt=function(a){return 1/ Math.sqrt(a)}})();var o=null;G();var r={create:function(a){var b=new o(3);a?(b[0]=a[0],b[1]=a[1],b[2]=a[2]):b[0]=b[1]=b[2]=0;return b},createFrom:function(a,b,c){var d=new o(3);d[0]=a;d[1]=b;d[2]=c;return d},set:function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];return b},equal:function(a,b){return a===b||1.0E-6>Math.abs(a[0]-b[0])&&1.0E-6>Math.abs(a[1]-b[1])&&1.0E-6>Math.abs(a[2]-b[2])},add:function(a,b,c){if(!c||a===c)return a[0]+=b[0],a[1]+=b[1],a[2]+=b[2],a;c[0]=a[0]+b[0];c[1]=a[1]+b[1];c[2]=a[2]+b[2]; return c},subtract:function(a,b,c){if(!c||a===c)return a[0]-=b[0],a[1]-=b[1],a[2]-=b[2],a;c[0]=a[0]-b[0];c[1]=a[1]-b[1];c[2]=a[2]-b[2];return c},multiply:function(a,b,c){if(!c||a===c)return a[0]*=b[0],a[1]*=b[1],a[2]*=b[2],a;c[0]=a[0]*b[0];c[1]=a[1]*b[1];c[2]=a[2]*b[2];return c},negate:function(a,b){b||(b=a);b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];return b},scale:function(a,b,c){if(!c||a===c)return a[0]*=b,a[1]*=b,a[2]*=b,a;c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;return c},normalize:function(a,b){b||(b=a);var c= a[0],d=a[1],e=a[2],g=Math.sqrt(c*c+d*d+e*e);if(!g)return b[0]=0,b[1]=0,b[2]=0,b;if(1===g)return b[0]=c,b[1]=d,b[2]=e,b;g=1/g;b[0]=c*g;b[1]=d*g;b[2]=e*g;return b},cross:function(a,b,c){c||(c=a);var d=a[0],e=a[1],a=a[2],g=b[0],f=b[1],b=b[2];c[0]=e*b-a*f;c[1]=a*g-d*b;c[2]=d*f-e*g;return c},length:function(a){var b=a[0],c=a[1],a=a[2];return Math.sqrt(b*b+c*c+a*a)},squaredLength:function(a){var b=a[0],c=a[1],a=a[2];return b*b+c*c+a*a},dot:function(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]},direction:function(a, b,c){c||(c=a);var d=a[0]-b[0],e=a[1]-b[1],a=a[2]-b[2],b=Math.sqrt(d*d+e*e+a*a);if(!b)return c[0]=0,c[1]=0,c[2]=0,c;b=1/b;c[0]=d*b;c[1]=e*b;c[2]=a*b;return c},lerp:function(a,b,c,d){d||(d=a);d[0]=a[0]+c*(b[0]-a[0]);d[1]=a[1]+c*(b[1]-a[1]);d[2]=a[2]+c*(b[2]-a[2]);return d},dist:function(a,b){var c=b[0]-a[0],d=b[1]-a[1],e=b[2]-a[2];return Math.sqrt(c*c+d*d+e*e)}},H=null,y=new o(4);r.unproject=function(a,b,c,d,e){e||(e=a);H||(H=x.create());var g=H;y[0]=2*(a[0]-d[0])/d[2]-1;y[1]=2*(a[1]-d[1])/d[3]-1;y[2]= 2*a[2]-1;y[3]=1;x.multiply(c,b,g);if(!x.inverse(g))return null;x.multiplyVec4(g,y);if(0===y[3])return null;e[0]=y[0]/y[3];e[1]=y[1]/y[3];e[2]=y[2]/y[3];return e};var L=r.createFrom(1,0,0),M=r.createFrom(0,1,0),N=r.createFrom(0,0,1),z=r.create();r.rotationTo=function(a,b,c){c||(c=k.create());var d=r.dot(a,b);if(1<=d)k.set(O,c);else if(-0.999999>d)r.cross(L,a,z),1.0E-6>r.length(z)&&r.cross(M,a,z),1.0E-6>r.length(z)&&r.cross(N,a,z),r.normalize(z),k.fromAngleAxis(Math.PI,z,c);else{var d=Math.sqrt(2*(1+ d)),e=1/d;r.cross(a,b,z);c[0]=z[0]*e;c[1]=z[1]*e;c[2]=z[2]*e;c[3]=0.5*d;k.normalize(c)}1<c[3]?c[3]=1:-1>c[3]&&(c[3]=-1);return c};r.str=function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\"]\"};var A={create:function(a){var b=new o(9);a?(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3],b[4]=a[4],b[5]=a[5],b[6]=a[6],b[7]=a[7],b[8]=a[8]):b[0]=b[1]=b[2]=b[3]=b[4]=b[5]=b[6]=b[7]=b[8]=0;return b},createFrom:function(a,b,c,d,e,g,f,h,j){var i=new o(9);i[0]=a;i[1]=b;i[2]=c;i[3]=d;i[4]=e;i[5]=g;i[6]=f;i[7]=h;i[8]=j;return i}, determinant:function(a){var b=a[3],c=a[4],d=a[5],e=a[6],g=a[7],f=a[8];return a[0]*(f*c-d*g)+a[1]*(-f*b+d*e)+a[2]*(g*b-c*e)},inverse:function(a,b){var c=a[0],d=a[1],e=a[2],g=a[3],f=a[4],h=a[5],j=a[6],i=a[7],m=a[8],l=m*f-h*i,C=-m*g+h*j,q=i*g-f*j,n=c*l+d*C+e*q;if(!n)return null;n=1/n;b||(b=A.create());b[0]=l*n;b[1]=(-m*d+e*i)*n;b[2]=(h*d-e*f)*n;b[3]=C*n;b[4]=(m*c-e*j)*n;b[5]=(-h*c+e*g)*n;b[6]=q*n;b[7]=(-i*c+d*j)*n;b[8]=(f*c-d*g)*n;return b},multiply:function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2], f=a[3],h=a[4],j=a[5],i=a[6],m=a[7],a=a[8],l=b[0],C=b[1],q=b[2],n=b[3],k=b[4],p=b[5],o=b[6],s=b[7],b=b[8];c[0]=l*d+C*f+q*i;c[1]=l*e+C*h+q*m;c[2]=l*g+C*j+q*a;c[3]=n*d+k*f+p*i;c[4]=n*e+k*h+p*m;c[5]=n*g+k*j+p*a;c[6]=o*d+s*f+b*i;c[7]=o*e+s*h+b*m;c[8]=o*g+s*j+b*a;return c},multiplyVec2:function(a,b,c){c||(c=b);var d=b[0],b=b[1];c[0]=d*a[0]+b*a[3]+a[6];c[1]=d*a[1]+b*a[4]+a[7];return c},multiplyVec3:function(a,b,c){c||(c=b);var d=b[0],e=b[1],b=b[2];c[0]=d*a[0]+e*a[3]+b*a[6];c[1]=d*a[1]+e*a[4]+b*a[7];c[2]= d*a[2]+e*a[5]+b*a[8];return c},set:function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];return b},equal:function(a,b){return a===b||1.0E-6>Math.abs(a[0]-b[0])&&1.0E-6>Math.abs(a[1]-b[1])&&1.0E-6>Math.abs(a[2]-b[2])&&1.0E-6>Math.abs(a[3]-b[3])&&1.0E-6>Math.abs(a[4]-b[4])&&1.0E-6>Math.abs(a[5]-b[5])&&1.0E-6>Math.abs(a[6]-b[6])&&1.0E-6>Math.abs(a[7]-b[7])&&1.0E-6>Math.abs(a[8]-b[8])},identity:function(a){a||(a=A.create());a[0]=1;a[1]=0;a[2]=0;a[3]=0; a[4]=1;a[5]=0;a[6]=0;a[7]=0;a[8]=1;return a},transpose:function(a,b){if(!b||a===b){var c=a[1],d=a[2],e=a[5];a[1]=a[3];a[2]=a[6];a[3]=c;a[5]=a[7];a[6]=d;a[7]=e;return a}b[0]=a[0];b[1]=a[3];b[2]=a[6];b[3]=a[1];b[4]=a[4];b[5]=a[7];b[6]=a[2];b[7]=a[5];b[8]=a[8];return b},toMat4:function(a,b){b||(b=x.create());b[15]=1;b[14]=0;b[13]=0;b[12]=0;b[11]=0;b[10]=a[8];b[9]=a[7];b[8]=a[6];b[7]=0;b[6]=a[5];b[5]=a[4];b[4]=a[3];b[3]=0;b[2]=a[2];b[1]=a[1];b[0]=a[0];return b},str:function(a){return\"[\"+a[0]+\", \"+a[1]+ \", \"+a[2]+\", \"+a[3]+\", \"+a[4]+\", \"+a[5]+\", \"+a[6]+\", \"+a[7]+\", \"+a[8]+\"]\"}},x={create:function(a){var b=new o(16);a&&(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3],b[4]=a[4],b[5]=a[5],b[6]=a[6],b[7]=a[7],b[8]=a[8],b[9]=a[9],b[10]=a[10],b[11]=a[11],b[12]=a[12],b[13]=a[13],b[14]=a[14],b[15]=a[15]);return b},createFrom:function(a,b,c,d,e,g,f,h,j,i,m,l,C,q,n,k){var p=new o(16);p[0]=a;p[1]=b;p[2]=c;p[3]=d;p[4]=e;p[5]=g;p[6]=f;p[7]=h;p[8]=j;p[9]=i;p[10]=m;p[11]=l;p[12]=C;p[13]=q;p[14]=n;p[15]=k;return p},set:function(a, b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return b},equal:function(a,b){return a===b||1.0E-6>Math.abs(a[0]-b[0])&&1.0E-6>Math.abs(a[1]-b[1])&&1.0E-6>Math.abs(a[2]-b[2])&&1.0E-6>Math.abs(a[3]-b[3])&&1.0E-6>Math.abs(a[4]-b[4])&&1.0E-6>Math.abs(a[5]-b[5])&&1.0E-6>Math.abs(a[6]-b[6])&&1.0E-6>Math.abs(a[7]-b[7])&&1.0E-6>Math.abs(a[8]-b[8])&&1.0E-6>Math.abs(a[9]-b[9])&&1.0E-6> Math.abs(a[10]-b[10])&&1.0E-6>Math.abs(a[11]-b[11])&&1.0E-6>Math.abs(a[12]-b[12])&&1.0E-6>Math.abs(a[13]-b[13])&&1.0E-6>Math.abs(a[14]-b[14])&&1.0E-6>Math.abs(a[15]-b[15])},identity:function(a){a||(a=x.create());a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a},transpose:function(a,b){if(!b||a===b){var c=a[1],d=a[2],e=a[3],g=a[6],f=a[7],h=a[11];a[1]=a[4];a[2]=a[8];a[3]=a[12];a[4]=c;a[6]=a[9];a[7]=a[13];a[8]=d;a[9]=g;a[11]= a[14];a[12]=e;a[13]=f;a[14]=h;return a}b[0]=a[0];b[1]=a[4];b[2]=a[8];b[3]=a[12];b[4]=a[1];b[5]=a[5];b[6]=a[9];b[7]=a[13];b[8]=a[2];b[9]=a[6];b[10]=a[10];b[11]=a[14];b[12]=a[3];b[13]=a[7];b[14]=a[11];b[15]=a[15];return b},determinant:function(a){var b=a[0],c=a[1],d=a[2],e=a[3],g=a[4],f=a[5],h=a[6],j=a[7],i=a[8],m=a[9],l=a[10],C=a[11],q=a[12],n=a[13],k=a[14],a=a[15];return q*m*h*e-i*n*h*e-q*f*l*e+g*n*l*e+i*f*k*e-g*m*k*e-q*m*d*j+i*n*d*j+q*c*l*j-b*n*l*j-i*c*k*j+b*m*k*j+q*f*d*C-g*n*d*C-q*c*h*C+b*n*h*C+ g*c*k*C-b*f*k*C-i*f*d*a+g*m*d*a+i*c*h*a-b*m*h*a-g*c*l*a+b*f*l*a},inverse:function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=a[4],h=a[5],j=a[6],i=a[7],m=a[8],l=a[9],k=a[10],q=a[11],n=a[12],o=a[13],p=a[14],r=a[15],s=c*h-d*f,v=c*j-e*f,t=c*i-g*f,u=d*j-e*h,w=d*i-g*h,x=e*i-g*j,y=m*o-l*n,z=m*p-k*n,F=m*r-q*n,A=l*p-k*o,D=l*r-q*o,E=k*r-q*p,B=s*E-v*D+t*A+u*F-w*z+x*y;if(!B)return null;B=1/B;b[0]=(h*E-j*D+i*A)*B;b[1]=(-d*E+e*D-g*A)*B;b[2]=(o*x-p*w+r*u)*B;b[3]=(-l*x+k*w-q*u)*B;b[4]=(-f*E+j*F-i*z)*B;b[5]= (c*E-e*F+g*z)*B;b[6]=(-n*x+p*t-r*v)*B;b[7]=(m*x-k*t+q*v)*B;b[8]=(f*D-h*F+i*y)*B;b[9]=(-c*D+d*F-g*y)*B;b[10]=(n*w-o*t+r*s)*B;b[11]=(-m*w+l*t-q*s)*B;b[12]=(-f*A+h*z-j*y)*B;b[13]=(c*A-d*z+e*y)*B;b[14]=(-n*u+o*v-p*s)*B;b[15]=(m*u-l*v+k*s)*B;return b},toRotationMat:function(a,b){b||(b=x.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b},toMat3:function(a,b){b||(b=A.create());b[0]= a[0];b[1]=a[1];b[2]=a[2];b[3]=a[4];b[4]=a[5];b[5]=a[6];b[6]=a[8];b[7]=a[9];b[8]=a[10];return b},toInverseMat3:function(a,b){var c=a[0],d=a[1],e=a[2],g=a[4],f=a[5],h=a[6],j=a[8],i=a[9],m=a[10],l=m*f-h*i,k=-m*g+h*j,q=i*g-f*j,n=c*l+d*k+e*q;if(!n)return null;n=1/n;b||(b=A.create());b[0]=l*n;b[1]=(-m*d+e*i)*n;b[2]=(h*d-e*f)*n;b[3]=k*n;b[4]=(m*c-e*j)*n;b[5]=(-h*c+e*g)*n;b[6]=q*n;b[7]=(-i*c+d*j)*n;b[8]=(f*c-d*g)*n;return b},multiply:function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],f=a[3],h=a[4],j=a[5], i=a[6],m=a[7],l=a[8],k=a[9],q=a[10],n=a[11],o=a[12],p=a[13],r=a[14],a=a[15],s=b[0],v=b[1],t=b[2],u=b[3];c[0]=s*d+v*h+t*l+u*o;c[1]=s*e+v*j+t*k+u*p;c[2]=s*g+v*i+t*q+u*r;c[3]=s*f+v*m+t*n+u*a;s=b[4];v=b[5];t=b[6];u=b[7];c[4]=s*d+v*h+t*l+u*o;c[5]=s*e+v*j+t*k+u*p;c[6]=s*g+v*i+t*q+u*r;c[7]=s*f+v*m+t*n+u*a;s=b[8];v=b[9];t=b[10];u=b[11];c[8]=s*d+v*h+t*l+u*o;c[9]=s*e+v*j+t*k+u*p;c[10]=s*g+v*i+t*q+u*r;c[11]=s*f+v*m+t*n+u*a;s=b[12];v=b[13];t=b[14];u=b[15];c[12]=s*d+v*h+t*l+u*o;c[13]=s*e+v*j+t*k+u*p;c[14]=s*g+ v*i+t*q+u*r;c[15]=s*f+v*m+t*n+u*a;return c},multiplyVec3:function(a,b,c){c||(c=b);var d=b[0],e=b[1],b=b[2];c[0]=a[0]*d+a[4]*e+a[8]*b+a[12];c[1]=a[1]*d+a[5]*e+a[9]*b+a[13];c[2]=a[2]*d+a[6]*e+a[10]*b+a[14];return c},multiplyVec4:function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2],b=b[3];c[0]=a[0]*d+a[4]*e+a[8]*g+a[12]*b;c[1]=a[1]*d+a[5]*e+a[9]*g+a[13]*b;c[2]=a[2]*d+a[6]*e+a[10]*g+a[14]*b;c[3]=a[3]*d+a[7]*e+a[11]*g+a[15]*b;return c},translate:function(a,b,c){var d=b[0],e=b[1],b=b[2],g,f,h,j,i,m,l,k,q, n,o,p;if(!c||a===c)return a[12]=a[0]*d+a[4]*e+a[8]*b+a[12],a[13]=a[1]*d+a[5]*e+a[9]*b+a[13],a[14]=a[2]*d+a[6]*e+a[10]*b+a[14],a[15]=a[3]*d+a[7]*e+a[11]*b+a[15],a;g=a[0];f=a[1];h=a[2];j=a[3];i=a[4];m=a[5];l=a[6];k=a[7];q=a[8];n=a[9];o=a[10];p=a[11];c[0]=g;c[1]=f;c[2]=h;c[3]=j;c[4]=i;c[5]=m;c[6]=l;c[7]=k;c[8]=q;c[9]=n;c[10]=o;c[11]=p;c[12]=g*d+i*e+q*b+a[12];c[13]=f*d+m*e+n*b+a[13];c[14]=h*d+l*e+o*b+a[14];c[15]=j*d+k*e+p*b+a[15];return c},scale:function(a,b,c){var d=b[0],e=b[1],b=b[2];if(!c||a===c)return a[0]*= d,a[1]*=d,a[2]*=d,a[3]*=d,a[4]*=e,a[5]*=e,a[6]*=e,a[7]*=e,a[8]*=b,a[9]*=b,a[10]*=b,a[11]*=b,a;c[0]=a[0]*d;c[1]=a[1]*d;c[2]=a[2]*d;c[3]=a[3]*d;c[4]=a[4]*e;c[5]=a[5]*e;c[6]=a[6]*e;c[7]=a[7]*e;c[8]=a[8]*b;c[9]=a[9]*b;c[10]=a[10]*b;c[11]=a[11]*b;c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15];return c},rotate:function(a,b,c,d){var e=c[0],g=c[1],c=c[2],f=Math.sqrt(e*e+g*g+c*c),h,j,i,m,l,k,q,n,o,p,r,s,v,t,u,w,x,y,z,A;if(!f)return null;1!==f&&(f=1/f,e*=f,g*=f,c*=f);h=Math.sin(b);j=Math.cos(b);i=1-j;b=a[0]; f=a[1];m=a[2];l=a[3];k=a[4];q=a[5];n=a[6];o=a[7];p=a[8];r=a[9];s=a[10];v=a[11];t=e*e*i+j;u=g*e*i+c*h;w=c*e*i-g*h;x=e*g*i-c*h;y=g*g*i+j;z=c*g*i+e*h;A=e*c*i+g*h;e=g*c*i-e*h;g=c*c*i+j;d?a!==d&&(d[12]=a[12],d[13]=a[13],d[14]=a[14],d[15]=a[15]):d=a;d[0]=b*t+k*u+p*w;d[1]=f*t+q*u+r*w;d[2]=m*t+n*u+s*w;d[3]=l*t+o*u+v*w;d[4]=b*x+k*y+p*z;d[5]=f*x+q*y+r*z;d[6]=m*x+n*y+s*z;d[7]=l*x+o*y+v*z;d[8]=b*A+k*e+p*g;d[9]=f*A+q*e+r*g;d[10]=m*A+n*e+s*g;d[11]=l*A+o*e+v*g;return d},rotateX:function(a,b,c){var d=Math.sin(b), b=Math.cos(b),e=a[4],g=a[5],f=a[6],h=a[7],j=a[8],i=a[9],m=a[10],l=a[11];c?a!==c&&(c[0]=a[0],c[1]=a[1],c[2]=a[2],c[3]=a[3],c[12]=a[12],c[13]=a[13],c[14]=a[14],c[15]=a[15]):c=a;c[4]=e*b+j*d;c[5]=g*b+i*d;c[6]=f*b+m*d;c[7]=h*b+l*d;c[8]=e*-d+j*b;c[9]=g*-d+i*b;c[10]=f*-d+m*b;c[11]=h*-d+l*b;return c},rotateY:function(a,b,c){var d=Math.sin(b),b=Math.cos(b),e=a[0],g=a[1],f=a[2],h=a[3],j=a[8],i=a[9],m=a[10],l=a[11];c?a!==c&&(c[4]=a[4],c[5]=a[5],c[6]=a[6],c[7]=a[7],c[12]=a[12],c[13]=a[13],c[14]=a[14],c[15]= a[15]):c=a;c[0]=e*b+j*-d;c[1]=g*b+i*-d;c[2]=f*b+m*-d;c[3]=h*b+l*-d;c[8]=e*d+j*b;c[9]=g*d+i*b;c[10]=f*d+m*b;c[11]=h*d+l*b;return c},rotateZ:function(a,b,c){var d=Math.sin(b),b=Math.cos(b),e=a[0],g=a[1],f=a[2],h=a[3],j=a[4],i=a[5],m=a[6],l=a[7];c?a!==c&&(c[8]=a[8],c[9]=a[9],c[10]=a[10],c[11]=a[11],c[12]=a[12],c[13]=a[13],c[14]=a[14],c[15]=a[15]):c=a;c[0]=e*b+j*d;c[1]=g*b+i*d;c[2]=f*b+m*d;c[3]=h*b+l*d;c[4]=e*-d+j*b;c[5]=g*-d+i*b;c[6]=f*-d+m*b;c[7]=h*-d+l*b;return c},frustum:function(a,b,c,d,e,g,f){f|| (f=x.create());var h=b-a,j=d-c,i=g-e;f[0]=2*e/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=2*e/j;f[6]=0;f[7]=0;f[8]=(b+a)/h;f[9]=(d+c)/j;f[10]=-(g+e)/i;f[11]=-1;f[12]=0;f[13]=0;f[14]=-(2*g*e)/i;f[15]=0;return f},perspective:function(a,b,c,d,e){a=c*Math.tan(a*Math.PI/360);b*=a;return x.frustum(-b,b,-a,a,c,d,e)},ortho:function(a,b,c,d,e,g,f){f||(f=x.create());var h=b-a,j=d-c,i=g-e;f[0]=2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=2/j;f[6]=0;f[7]=0;f[8]=0;f[9]=0;f[10]=-2/i;f[11]=0;f[12]=-(a+b)/h;f[13]=-(d+c)/j;f[14]= -(g+e)/i;f[15]=1;return f},lookAt:function(a,b,c,d){d||(d=x.create());var e,g,f,h,j,i,m,l,k=a[0],o=a[1],a=a[2];f=c[0];h=c[1];g=c[2];m=b[0];c=b[1];e=b[2];if(k===m&&o===c&&a===e)return x.identity(d);b=k-m;c=o-c;m=a-e;l=1/Math.sqrt(b*b+c*c+m*m);b*=l;c*=l;m*=l;e=h*m-g*c;g=g*b-f*m;f=f*c-h*b;(l=Math.sqrt(e*e+g*g+f*f))?(l=1/l,e*=l,g*=l,f*=l):f=g=e=0;h=c*f-m*g;j=m*e-b*f;i=b*g-c*e;(l=Math.sqrt(h*h+j*j+i*i))?(l=1/l,h*=l,j*=l,i*=l):i=j=h=0;d[0]=e;d[1]=h;d[2]=b;d[3]=0;d[4]=g;d[5]=j;d[6]=c;d[7]=0;d[8]=f;d[9]= i;d[10]=m;d[11]=0;d[12]=-(e*k+g*o+f*a);d[13]=-(h*k+j*o+i*a);d[14]=-(b*k+c*o+m*a);d[15]=1;return d},fromRotationTranslation:function(a,b,c){c||(c=x.create());var d=a[0],e=a[1],g=a[2],f=a[3],h=d+d,j=e+e,i=g+g,a=d*h,m=d*j,d=d*i,k=e*j,e=e*i,g=g*i,h=f*h,j=f*j,f=f*i;c[0]=1-(k+g);c[1]=m+f;c[2]=d-j;c[3]=0;c[4]=m-f;c[5]=1-(a+g);c[6]=e+h;c[7]=0;c[8]=d+j;c[9]=e-h;c[10]=1-(a+k);c[11]=0;c[12]=b[0];c[13]=b[1];c[14]=b[2];c[15]=1;return c},str:function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\", \"+a[3]+\", \"+a[4]+\", \"+ a[5]+\", \"+a[6]+\", \"+a[7]+\", \"+a[8]+\", \"+a[9]+\", \"+a[10]+\", \"+a[11]+\", \"+a[12]+\", \"+a[13]+\", \"+a[14]+\", \"+a[15]+\"]\"}},k={create:function(a){var b=new o(4);a?(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3]):b[0]=b[1]=b[2]=b[3]=0;return b},createFrom:function(a,b,c,d){var e=new o(4);e[0]=a;e[1]=b;e[2]=c;e[3]=d;return e},set:function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];return b},equal:function(a,b){return a===b||1.0E-6>Math.abs(a[0]-b[0])&&1.0E-6>Math.abs(a[1]-b[1])&&1.0E-6>Math.abs(a[2]-b[2])&&1.0E-6> Math.abs(a[3]-b[3])},identity:function(a){a||(a=k.create());a[0]=0;a[1]=0;a[2]=0;a[3]=1;return a}},O=k.identity();k.calculateW=function(a,b){var c=a[0],d=a[1],e=a[2];if(!b||a===b)return a[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e)),a;b[0]=c;b[1]=d;b[2]=e;b[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return b};k.dot=function(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3]};k.inverse=function(a,b){var c=a[0],d=a[1],e=a[2],g=a[3],c=(c=c*c+d*d+e*e+g*g)?1/c:0;if(!b||a===b)return a[0]*=-c,a[1]*=-c,a[2]*=-c,a[3]*= c,a;b[0]=-a[0]*c;b[1]=-a[1]*c;b[2]=-a[2]*c;b[3]=a[3]*c;return b};k.conjugate=function(a,b){if(!b||a===b)return a[0]*=-1,a[1]*=-1,a[2]*=-1,a;b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];b[3]=a[3];return b};k.length=function(a){var b=a[0],c=a[1],d=a[2],a=a[3];return Math.sqrt(b*b+c*c+d*d+a*a)};k.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=Math.sqrt(c*c+d*d+e*e+g*g);if(0===f)return b[0]=0,b[1]=0,b[2]=0,b[3]=0,b;f=1/f;b[0]=c*f;b[1]=d*f;b[2]=e*f;b[3]=g*f;return b};k.add=function(a,b,c){if(!c|| a===c)return a[0]+=b[0],a[1]+=b[1],a[2]+=b[2],a[3]+=b[3],a;c[0]=a[0]+b[0];c[1]=a[1]+b[1];c[2]=a[2]+b[2];c[3]=a[3]+b[3];return c};k.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],a=a[3],f=b[0],h=b[1],j=b[2],b=b[3];c[0]=d*b+a*f+e*j-g*h;c[1]=e*b+a*h+g*f-d*j;c[2]=g*b+a*j+d*h-e*f;c[3]=a*b-d*f-e*h-g*j;return c};k.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2],b=a[0],f=a[1],h=a[2],a=a[3],j=a*d+f*g-h*e,i=a*e+h*d-b*g,k=a*g+b*e-f*d,d=-b*d-f*e-h*g;c[0]=j*a+d*-b+i*-h-k*-f;c[1]=i*a+ d*-f+k*-b-j*-h;c[2]=k*a+d*-h+j*-f-i*-b;return c};k.scale=function(a,b,c){if(!c||a===c)return a[0]*=b,a[1]*=b,a[2]*=b,a[3]*=b,a;c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;c[3]=a[3]*b;return c};k.toMat3=function(a,b){b||(b=A.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,j=e+e,i=c*f,k=c*h,c=c*j,l=d*h,d=d*j,e=e*j,f=g*f,h=g*h,g=g*j;b[0]=1-(l+e);b[1]=k+g;b[2]=c-h;b[3]=k-g;b[4]=1-(i+e);b[5]=d+f;b[6]=c+h;b[7]=d-f;b[8]=1-(i+l);return b};k.toMat4=function(a,b){b||(b=x.create());var c=a[0],d=a[1],e=a[2],g= a[3],f=c+c,h=d+d,j=e+e,i=c*f,k=c*h,c=c*j,l=d*h,d=d*j,e=e*j,f=g*f,h=g*h,g=g*j;b[0]=1-(l+e);b[1]=k+g;b[2]=c-h;b[3]=0;b[4]=k-g;b[5]=1-(i+e);b[6]=d+f;b[7]=0;b[8]=c+h;b[9]=d-f;b[10]=1-(i+l);b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};k.slerp=function(a,b,c,d){d||(d=a);var e=a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3],g,f;if(1<=Math.abs(e))return d!==a&&(d[0]=a[0],d[1]=a[1],d[2]=a[2],d[3]=a[3]),d;g=Math.acos(e);f=Math.sqrt(1-e*e);if(0.001>Math.abs(f))return d[0]=0.5*a[0]+0.5*b[0],d[1]=0.5*a[1]+0.5*b[1], d[2]=0.5*a[2]+0.5*b[2],d[3]=0.5*a[3]+0.5*b[3],d;e=Math.sin((1-c)*g)/f;c=Math.sin(c*g)/f;d[0]=a[0]*e+b[0]*c;d[1]=a[1]*e+b[1]*c;d[2]=a[2]*e+b[2]*c;d[3]=a[3]*e+b[3]*c;return d};k.fromRotationMatrix=function(a,b){b||(b=k.create());var c=a[0]+a[4]+a[8],d;if(0<c)d=Math.sqrt(c+1),b[3]=0.5*d,d=0.5/d,b[0]=(a[7]-a[5])*d,b[1]=(a[2]-a[6])*d,b[2]=(a[3]-a[1])*d;else{d=k.fromRotationMatrix.s_iNext=k.fromRotationMatrix.s_iNext||[1,2,0];c=0;a[4]>a[0]&&(c=1);a[8]>a[3*c+c]&&(c=2);var e=d[c],g=d[e];d=Math.sqrt(a[3*c+ c]-a[3*e+e]-a[3*g+g]+1);b[c]=0.5*d;d=0.5/d;b[3]=(a[3*g+e]-a[3*e+g])*d;b[e]=(a[3*e+c]+a[3*c+e])*d;b[g]=(a[3*g+c]+a[3*c+g])*d}return b};A.toQuat4=k.fromRotationMatrix;(function(){var a=A.create();k.fromAxes=function(b,c,d,e){a[0]=c[0];a[3]=c[1];a[6]=c[2];a[1]=d[0];a[4]=d[1];a[7]=d[2];a[2]=b[0];a[5]=b[1];a[8]=b[2];return k.fromRotationMatrix(a,e)}})();k.identity=function(a){a||(a=k.create());a[0]=0;a[1]=0;a[2]=0;a[3]=1;return a};k.fromAngleAxis=function(a,b,c){c||(c=k.create());var a=0.5*a,d=Math.sin(a); c[3]=Math.cos(a);c[0]=d*b[0];c[1]=d*b[1];c[2]=d*b[2];return c};k.toAngleAxis=function(a,b){b||(b=a);var c=a[0]*a[0]+a[1]*a[1]+a[2]*a[2];0<c?(b[3]=2*Math.acos(a[3]),c=E.invsqrt(c),b[0]=a[0]*c,b[1]=a[1]*c,b[2]=a[2]*c):(b[3]=0,b[0]=1,b[1]=0,b[2]=0);return b};k.str=function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\", \"+a[3]+\"]\"};var J={create:function(a){var b=new o(2);a?(b[0]=a[0],b[1]=a[1]):(b[0]=0,b[1]=0);return b},createFrom:function(a,b){var c=new o(2);c[0]=a;c[1]=b;return c},add:function(a,b,c){c|| (c=b);c[0]=a[0]+b[0];c[1]=a[1]+b[1];return c},subtract:function(a,b,c){c||(c=b);c[0]=a[0]-b[0];c[1]=a[1]-b[1];return c},multiply:function(a,b,c){c||(c=b);c[0]=a[0]*b[0];c[1]=a[1]*b[1];return c},divide:function(a,b,c){c||(c=b);c[0]=a[0]/b[0];c[1]=a[1]/b[1];return c},scale:function(a,b,c){c||(c=a);c[0]=a[0]*b;c[1]=a[1]*b;return c},dist:function(a,b){var c=b[0]-a[0],d=b[1]-a[1];return Math.sqrt(c*c+d*d)},set:function(a,b){b[0]=a[0];b[1]=a[1];return b},equal:function(a,b){return a===b||1.0E-6>Math.abs(a[0]- b[0])&&1.0E-6>Math.abs(a[1]-b[1])},negate:function(a,b){b||(b=a);b[0]=-a[0];b[1]=-a[1];return b},normalize:function(a,b){b||(b=a);var c=a[0]*a[0]+a[1]*a[1];0<c?(c=Math.sqrt(c),b[0]=a[0]/c,b[1]=a[1]/c):b[0]=b[1]=0;return b},cross:function(a,b,c){a=a[0]*b[1]-a[1]*b[0];if(!c)return a;c[0]=c[1]=0;c[2]=a;return c},length:function(a){var b=a[0],a=a[1];return Math.sqrt(b*b+a*a)},squaredLength:function(a){var b=a[0],a=a[1];return b*b+a*a},dot:function(a,b){return a[0]*b[0]+a[1]*b[1]},direction:function(a, b,c){c||(c=a);var d=a[0]-b[0],a=a[1]-b[1],b=d*d+a*a;if(!b)return c[0]=0,c[1]=0,c[2]=0,c;b=1/Math.sqrt(b);c[0]=d*b;c[1]=a*b;return c},lerp:function(a,b,c,d){d||(d=a);d[0]=a[0]+c*(b[0]-a[0]);d[1]=a[1]+c*(b[1]-a[1]);return d},str:function(a){return\"[\"+a[0]+\", \"+a[1]+\"]\"}},I={create:function(a){var b=new o(4);a?(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3]):b[0]=b[1]=b[2]=b[3]=0;return b},createFrom:function(a,b,c,d){var e=new o(4);e[0]=a;e[1]=b;e[2]=c;e[3]=d;return e},set:function(a,b){b[0]=a[0];b[1]=a[1]; b[2]=a[2];b[3]=a[3];return b},equal:function(a,b){return a===b||1.0E-6>Math.abs(a[0]-b[0])&&1.0E-6>Math.abs(a[1]-b[1])&&1.0E-6>Math.abs(a[2]-b[2])&&1.0E-6>Math.abs(a[3]-b[3])},identity:function(a){a||(a=I.create());a[0]=1;a[1]=0;a[2]=0;a[3]=1;return a},transpose:function(a,b){if(!b||a===b){var c=a[1];a[1]=a[2];a[2]=c;return a}b[0]=a[0];b[1]=a[2];b[2]=a[1];b[3]=a[3];return b},determinant:function(a){return a[0]*a[3]-a[2]*a[1]},inverse:function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=c*g-e* d;if(!f)return null;f=1/f;b[0]=g*f;b[1]=-d*f;b[2]=-e*f;b[3]=c*f;return b},multiply:function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],a=a[3];c[0]=d*b[0]+e*b[2];c[1]=d*b[1]+e*b[3];c[2]=g*b[0]+a*b[2];c[3]=g*b[1]+a*b[3];return c},rotate:function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],a=a[3],f=Math.sin(b),b=Math.cos(b);c[0]=d*b+e*f;c[1]=d*-f+e*b;c[2]=g*b+a*f;c[3]=g*-f+a*b;return c},multiplyVec2:function(a,b,c){c||(c=b);var d=b[0],b=b[1];c[0]=d*a[0]+b*a[1];c[1]=d*a[2]+b*a[3];return c},scale:function(a, b,c){c||(c=a);var d=a[1],e=a[2],g=a[3],f=b[0],b=b[1];c[0]=a[0]*f;c[1]=d*b;c[2]=e*f;c[3]=g*b;return c},str:function(a){return\"[\"+a[0]+\", \"+a[1]+\", \"+a[2]+\", \"+a[3]+\"]\"}},K={create:function(a){var b=new o(4);a?(b[0]=a[0],b[1]=a[1],b[2]=a[2],b[3]=a[3]):(b[0]=0,b[1]=0,b[2]=0,b[3]=0);return b},createFrom:function(a,b,c,d){var e=new o(4);e[0]=a;e[1]=b;e[2]=c;e[3]=d;return e},add:function(a,b,c){c||(c=b);c[0]=a[0]+b[0];c[1]=a[1]+b[1];c[2]=a[2]+b[2];c[3]=a[3]+b[3];return c},subtract:function(a,b,c){c||(c= b);c[0]=a[0]-b[0];c[1]=a[1]-b[1];c[2]=a[2]-b[2];c[3]=a[3]-b[3];return c},multiply:function(a,b,c){c||(c=b);c[0]=a[0]*b[0];c[1]=a[1]*b[1];c[2]=a[2]*b[2];c[3]=a[3]*b[3];return c},divide:function(a,b,c){c||(c=b);c[0]=a[0]/b[0];c[1]=a[1]/b[1];c[2]=a[2]/b[2];c[3]=a[3]/b[3];return c},scale:function(a,b,c){c||(c=a);c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;c[3]=a[3]*b;return c},set:function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];return b},equal:function(a,b){return a===b||1.0E-6>Math.abs(a[0]-b[0])&&1.0E-6> Math.abs(a[1]-b[1])&&1.0E-6>Math.abs(a[2]-b[2])&&1.0E-6>Math.abs(a[3]-b[3])},negate:function(a,b){b||(b=a);b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];b[3]=-a[3];return b},length:function(a){var b=a[0],c=a[1],d=a[2],a=a[3];return Math.sqrt(b*b+c*c+d*d+a*a)},squaredLength:function(a){var b=a[0],c=a[1],d=a[2],a=a[3];return b*b+c*c+d*d+a*a},lerp:function(a,b,c,d){d||(d=a);d[0]=a[0]+c*(b[0]-a[0]);d[1]=a[1]+c*(b[1]-a[1]);d[2]=a[2]+c*(b[2]-a[2]);d[3]=a[3]+c*(b[3]-a[3]);return d},str:function(a){return\"[\"+a[0]+\", \"+ a[1]+\", \"+a[2]+\", \"+a[3]+\"]\"}};w&&(w.glMatrixArrayType=o,w.MatrixArray=o,w.setMatrixArrayType=D,w.determineMatrixArrayType=G,w.glMath=E,w.vec2=J,w.vec3=r,w.vec4=K,w.mat2=I,w.mat3=A,w.mat4=x,w.quat4=k);return{glMatrixArrayType:o,MatrixArray:o,setMatrixArrayType:D,determineMatrixArrayType:G,glMath:E,vec2:J,vec3:r,vec4:K,mat2:I,mat3:A,mat4:x,quat4:k}});/* Javascript graphics utility library Helper functions, WebGL classes, Mouse input, Colours and Gradients UI Copyright (c) 2014, Owen Kaluza Released into public domain: This program is free software. It comes without any warranty, to the extent permitted by applicable law. You can redistribute it and/or modify it as long as this header remains intact */ var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.checkStringArgs=function(a,b,c){if(null==a)throw new TypeError(\"The 'this' value for String.prototype.\"+c+\" must not be null or undefined\");if(b instanceof RegExp)throw new TypeError(\"First argument to String.prototype.\"+c+\" must not be a regular expression\");return a+\"\"}; $jscomp.defineProperty=\"function\"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){if(c.get||c.set)throw new TypeError(\"ES3 does not support getters and setters.\");a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)};$jscomp.getGlobal=function(a){return\"undefined\"!=typeof window&&window===a?a:\"undefined\"!=typeof global&&null!=global?global:a};$jscomp.global=$jscomp.getGlobal(this); $jscomp.polyfill=function(a,b,c,d){if(b){c=$jscomp.global;a=a.split(\".\");for(d=0;d<a.length-1;d++){var e=a[d];e in c||(c[e]={});c=c[e]}a=a[a.length-1];d=c[a];b=b(d);b!=d&&null!=b&&$jscomp.defineProperty(c,a,{configurable:!0,writable:!0,value:b})}}; $jscomp.polyfill(\"String.prototype.repeat\",function(a){return a?a:function(a){var b=$jscomp.checkStringArgs(this,null,\"repeat\");if(0>a||1342177279<a)throw new RangeError(\"Invalid count value\");a|=0;for(var d=\"\";a;)if(a&1&&(d+=b),a>>>=1)b+=b;return d}},\"es6-impl\",\"es3\");$jscomp.stringPadding=function(a,b){var c=void 0!==a?String(a):\" \";return 0<b&&c?c.repeat(Math.ceil(b/c.length)).substring(0,b):\"\"}; $jscomp.polyfill(\"String.prototype.padStart\",function(a){return a?a:function(a,c){var b=$jscomp.checkStringArgs(this,null,\"padStart\");return $jscomp.stringPadding(c,a-b.length)+b}},\"es8\",\"es3\");var OK=function(){var a={debug_on:!1,debug:function(b){if(a.debug_on){var c=document.getElementById(\"console\");c?c.innerHTML=\"<div style=\\\"font-family: 'monospace'; font-size: 8pt;\\\">\"+b+\"</div>\"+c.innerHTML:console.log(b)}},clear:function(){var a=document.getElementById(\"console\");a&&(a.innerHTML=\"\")}};return a}(); function getSearchVariable(a,b){for(var c=window.location.search.substring(1).split(\"&\"),d=0;d<c.length;d++){var e=c[d].split(\"=\");if(unescape(e[0])==a)return unescape(e[1])}return b}function getImageDataURL(a){var b=document.createElement(\"canvas\");b.width=a.width;b.height=a.height;b.getContext(\"2d\").drawImage(a,0,0);return b.toDataURL(\"image/png\")} function toggle(a){var b=document.getElementById(a).style.display;\"none\"!=b&&b?document.getElementById(a).style.display=\"none\":document.getElementById(a).style.display=\"block\"}function setAll(a,b){for(var c=document.getElementsByClassName(b),d=0;d<c.length;d++)c[d].style.display=a}function getSourceFromElement(a){var b=document.getElementById(a);if(!b)return null;a=\"\";for(b=b.firstChild;b;)3==b.nodeType&&(a+=b.textContent),b=b.nextSibling;return a} function removeChildren(a){if(a.hasChildNodes())for(;0<a.childNodes.length;)a.removeChild(a.firstChild)}function requestFullScreen(a){a=document.getElementById(a);a.requestFullscreen?a.requestFullscreen():a.mozRequestFullScreen?a.mozRequestFullScreen():a.webkitRequestFullScreen&&a.webkitRequestFullScreen()}function typeOf(a){var b=typeof a;\"object\"===b&&(a?\"number\"!==typeof a.length||a.propertyIsEnumerable(\"length\")||\"function\"!==typeof a.splice||(b=\"array\"):b=\"null\");return b} function isEmpty(a){var b,c;if(\"object\"===typeOf(a))for(b in a)if(c=a[b],void 0!==c&&\"function\"!==typeOf(c))return!1;return!0} function ajaxReadFile(a,b,c,d,e){var f=new XMLHttpRequest,g=0;void 0!=d&&(\"number\"==typeof d?g=d:f.onprogress=d);f.onreadystatechange=function(){if(0<g&&2<f.readyState){var c=parseInt(f.responseText.length);d&&setProgress(c/g*100)}4==f.readyState&&(200==f.status?(d&&setProgress(100),OK.debug(\"RECEIVED: \"+a),b&&b(f.responseText,a)):b?b(\"Error: \"+f.status+\" : \"+a):OK.debug(\"Ajax Read File Error: returned status code \"+f.status+\" \"+f.statusText))};c?f.open(\"GET\",a+\"?d=\"+(new Date).getTime(),!0):f.open(\"GET\", a,!0);for(var h in e)f.setRequestHeader(h,e[h]);f.send(null)}function readURL(a,b,c){var d=new XMLHttpRequest,e=0;void 0!=c&&(\"number\"==typeof c?e=c:d.onprogress=c);d.onreadystatechange=function(){if(0<e&&2<d.readyState){var a=parseInt(d.responseText.length);c&&setProgress(a/e*100)}};b?d.open(\"GET\",a+\"?d=\"+(new Date).getTime(),!1):d.open(\"GET\",a,!1);d.overrideMimeType(\"text/plain; charset=x-user-defined\");d.send(null);if(200!=d.status)return\"\";c&&setProgress(100);return d.responseText} function updateProgress(a){a.lengthComputable&&(setProgress(a.loaded/a.total*100),OK.debug(a.loaded+\" / \"+a.total))}function setProgress(a){a=Math.round(a);document.getElementById(\"progressbar\").style.width=3*a+\"px\";document.getElementById(\"progressstatus\").innerHTML=a+\"%\"} function ajaxPost(a,b,c,d,e){var f=new XMLHttpRequest;void 0!=d&&(f.upload.onprogress=d);f.onreadystatechange=function(){4==f.readyState&&(200==f.status?(d&&setProgress(100),OK.debug(\"POST: \"+a),c&&c(f.responseText)):c?c(\"Error, status:\"+f.status):OK.debug(\"Ajax Post Error: returned status code \"+f.status+\" \"+f.statusText))};f.open(\"POST\",a,!0);\"string\"==typeof b&&f.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");if(e)for(key in e)f.setRequestHeader(key,e[key]);f.send(b)} var defaultMouse,dragMouse;function MouseEventHandler(a,b,c,d,e,f,g){this.click=a;this.wheel=b;this.move=c;this.down=d;this.up=e;this.leave=f;this.pinch=g} function Mouse(a,b,c){this.element=a;this.handler=b;this.isdown=this.disabled=!1;this.button=null;this.dragged=!1;this.lastY=this.lastX=this.absoluteY=this.absoluteX=this.x=this.x=0;this.slider=null;this.spin=0;this.moveUpdate=!1;this.enableContext=c?!0:!1;a.addEventListener(\"onwheel\"in document?\"wheel\":\"mousewheel\",handleMouseWheel,!1);a.onmousedown=handleMouseDown;a.onmouseout=handleMouseLeave;document.onmouseup=handleMouseUp;document.onmousemove=handleMouseMove;a.addEventListener(\"touchstart\", touchHandler,!0);a.addEventListener(\"touchmove\",touchHandler,!0);a.addEventListener(\"touchend\",touchHandler,!0);a.oncontextmenu=function(){return this.mouse.enableContext}}Mouse.prototype.setDefault=function(){defaultMouse=document.mouse=this}; Mouse.prototype.update=function(a){a||(a=window.event);this.x=a.clientX;this.y=a.clientY;this.absoluteX=this.x;this.absoluteY=this.y;var b=this.element.getBoundingClientRect(),b=[b.left,b.top];this.x-=b[0];this.y-=b[1];this.clientx=a.pageX-b[0];this.clienty=a.pageY-b[1]};function getMouse(a){a||(a=window.event);var b=a.target.mouse;if(b)return b;for(a=a.target;a!=document;)if(a=a.parentNode,a.mouse)return a.mouse;return null} function handleMouseDown(a){var b=getMouse(a);if(!b||b.disabled)return!0;b.target=(a||window.event).target;b.dragged=!1;b.update(a);b.isdown||(b.lastX=b.absoluteX,b.lastY=b.absoluteY);b.isdown=!0;dragMouse=b;b.button=a.button;document.mouse=b;var c=!0;b.handler.down&&(c=b.handler.down(a,b));!c&&a.preventDefault&&a.preventDefault();return c} function handleMouseUp(a){var b=document.mouse;if(!b||b.disabled)return!0;var c=!0;b.isdown&&(b.update(a),b.handler.click&&(c=b.handler.click(a,b)),b.isdown=!1,dragMouse=null,b.button=null,b.dragged=!1);b.handler.up&&(c=c&&b.handler.up(a,b));document.mouse=defaultMouse;!c&&a.preventDefault&&a.preventDefault();return c} function handleMouseMove(a){var b=dragMouse?dragMouse:getMouse(a);if(!b||b.disabled)return!0;b.update(a);b.deltaX=b.absoluteX-b.lastX;b.deltaY=b.absoluteY-b.lastY;var c=!0;!b.dragged&&b.isdown&&3<Math.abs(b.deltaX)+Math.abs(b.deltaY)&&(b.dragged=!0);b.handler.move&&(c=b.handler.move(a,b));b.moveUpdate&&(b.lastX=b.absoluteX,b.lastY=b.absoluteY);!c&&a.preventDefault&&a.preventDefault();return c} function handleMouseWheel(a){var b=getMouse(a);if(!b||b.disabled)return!0;b.update(a);var c=!1;a.spin=0<(a.deltaY?-a.deltaY:a.wheelDelta)?1:-1;b.handler.wheel&&(c=b.handler.wheel(a,b));!c&&a.preventDefault&&a.preventDefault();return c}function handleMouseLeave(a){var b=getMouse(a);if(!b||b.disabled)return!0;var c=!0;b.handler.leave&&(c=b.handler.leave(a,b));!c&&a.preventDefault&&a.preventDefault();return a.returnValue=c} function touchHandler(a){var b=a.changedTouches[0],c=null,d=getMouse(a);switch(a.type){case \"touchstart\":2==a.touches.length?(d.isdown=!1,d.scaling=0):c=\"mousedown\";break;case \"touchmove\":if(null!=d.scaling&&2==a.touches.length){var e=Math.sqrt((a.touches[0].pageX-a.touches[1].pageX)*(a.touches[0].pageX-a.touches[1].pageX)+(a.touches[0].pageY-a.touches[1].pageY)*(a.touches[0].pageY-a.touches[1].pageY));0<d.scaling?(a.distance=e-d.scaling,d.handler.pinch&&d.handler.pinch(a,d),a.returnValue=!0):d.scaling= e}else c=\"mousemove\";break;case \"touchend\":null!=d.scaling?d.scaling=0==d.scaling?null:0:c=\"mouseup\";break;default:return}1<a.touches.length&&(c=null);c&&(d=document.createEvent(\"MouseEvent\"),d.initMouseEvent(c,!0,!0,window,1,b.screenX,b.screenY,b.clientX,b.clientY,a.ctrlKey,a.altKey,a.shiftKey,a.metaKey,0,null),b.target.dispatchEvent(d),a.preventDefault())} function printMatrix(a){console.log(\"--------- --------- --------- ---------\");for(var b=0;4>b;b++){for(var c=\"\",d=0;4>d;d++)var e=\"\"+(4*d+b),f=\"\"+a[4*d+b].toFixed(5),c=c+(e.padStart(2)+\" \"+f.padStart(8)+\" \");console.log(c)}console.log(\"--------- --------- --------- ---------\")}function Viewport(a,b,c,d){this.x=a;this.y=b;this.width=c;this.height=d;this.array=new Float32Array([a,b,c,d])} function WebGL(a,b){this.program=null;this.modelView=new ViewMatrix;this.projection=new ViewMatrix;this.textures=[];this.timer=null;if(!window.WebGLRenderingContext)throw\"No browser WebGL support\";try{this.gl=a.getContext(\"webgl\",b)||a.getContext(\"experimental-webgl\",b)}catch(c){throw OK.debug(\"detectGL exception: \"+c),\"No context\";}this.viewport=new Viewport(0,0,a.width,a.height);if(!this.gl)throw\"Failed to get context\";} WebGL.prototype.setMatrices=function(){this.gl.uniformMatrix4fv(this.program.mvMatrixUniform,!1,this.modelView.matrix);this.gl.uniformMatrix4fv(this.program.pMatrixUniform,!1,this.projection.matrix);this.setNormalMatrix()};WebGL.prototype.setNormalMatrix=function(){this.program.nMatrixUniform&&(this.nMatrix=mat4.create(this.modelView.matrix),mat4.inverse(this.nMatrix),mat4.transpose(this.nMatrix),this.gl.uniformMatrix4fv(this.program.nMatrixUniform,!1,this.nMatrix))}; WebGL.prototype.initDraw2d=function(){this.gl.enableVertexAttribArray(this.program.attributes.aVertexPosition);this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vertexPositionBuffer);this.gl.vertexAttribPointer(this.program.attributes.aVertexPosition,this.vertexPositionBuffer.itemSize,this.gl.FLOAT,!1,0,0);this.program.attributes.aTextureCoord&&(this.gl.enableVertexAttribArray(this.program.attributes.aTextureCoord),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.textureCoordBuffer),this.gl.vertexAttribPointer(this.program.attributes.aTextureCoord, this.textureCoordBuffer.itemSize,this.gl.FLOAT,!1,0,0));this.setMatrices()};WebGL.prototype.updateTexture=function(a,b,c){void 0==c&&(c=this.gl.TEXTURE0);this.gl.activeTexture(c);this.gl.bindTexture(this.gl.TEXTURE_2D,a);this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,b);this.gl.bindTexture(this.gl.TEXTURE_2D,null)}; WebGL.prototype.init2dBuffers=function(a){void 0==a&&(a=this.gl.TEXTURE0);this.vertexPositionBuffer=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vertexPositionBuffer);this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array([1,1,-1,1,1,-1,-1,-1]),this.gl.STATIC_DRAW);this.vertexPositionBuffer.itemSize=2;this.vertexPositionBuffer.numItems=4;this.gl.activeTexture(a);this.gradientTexture=this.gl.createTexture();this.gl.bindTexture(this.gl.TEXTURE_2D,this.gradientTexture);this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER,this.gl.NEAREST);this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.NEAREST);this.textureCoordBuffer=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.textureCoordBuffer);this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array([1,1,0,1,1,0,0,0]),this.gl.STATIC_DRAW);this.textureCoordBuffer.itemSize=2;this.textureCoordBuffer.numItems=4}; WebGL.prototype.loadTexture=function(a,b,c,d){void 0==b&&(b=this.gl.NEAREST);void 0==c&&(c=this.gl.RGBA);this.texid=this.textures.length;this.textures.push(this.gl.createTexture());this.gl.bindTexture(this.gl.TEXTURE_2D,this.textures[this.texid]);d&&this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL,!0);this.gl.texImage2D(this.gl.TEXTURE_2D,0,c,c,this.gl.UNSIGNED_BYTE,a);this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,b);this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER, b);this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE);this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE);this.gl.bindTexture(this.gl.TEXTURE_2D,null);return this.textures[this.texid]};WebGL.prototype.setPerspective=function(a,b,c,d){void 0==a&&(a=45);void 0==b&&(b=1);void 0==c&&(c=.1);void 0==d&&(d=1E3);this.projection.matrix=mat4.perspective(a,b,c,d)};WebGL.prototype.use=function(a){this.program=a;this.program.program&&this.gl.useProgram(this.program.program)}; WebGL.prototype.view=function(a){this.gl&&(this.gl.viewport(this.viewport.x,this.viewport.y,this.viewport.width,this.viewport.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT),this.apply(a))}; WebGL.prototype.apply=function(a){if(this.gl){this.setPerspective(a.fov,this.viewport.width/this.viewport.height,a.near_clip,a.far_clip);this.modelView.identity();this.modelView.translate([a.translate[0],a.translate[1],a.translate[2]]);var b=[-(a.focus[0]-a.centre[0]),-(a.focus[1]-a.centre[1]),-(a.focus[2]-a.centre[2])];this.modelView.translate(b);this.modelView.mult(quat4.toMat4(a.rotate));this.modelView.scale(a.scale);this.modelView.translate([-b[0],-b[1],-b[2]]);this.modelView.translate([-a.focus[0], -a.focus[1],-a.focus[2]*a.orientation]);1==a.orientation?this.gl.frontFace(a.gl.CCW):(this.gl.frontFace(a.gl.CW),this.modelView.scale([1,1,-1]))}}; function WebGLProgram(a,b,c){this.program=null;0>b.indexOf(\"main\")&&(b=getSourceFromElement(b));0>c.indexOf(\"main\")&&(c=getSourceFromElement(c));this.gl=a;this.program&&this.gl.isProgram(this.program)&&(this.gl.isShader(this.vshader)&&(this.gl.detachShader(this.program,this.vshader),this.gl.deleteShader(this.vshader)),this.gl.isShader(this.fshader)&&(this.gl.detachShader(this.program,this.fshader),this.gl.deleteShader(this.fshader)),this.gl.deleteProgram(this.program));this.program=this.gl.createProgram(); this.vshader=this.compileShader(b,this.gl.VERTEX_SHADER);this.fshader=this.compileShader(c,this.gl.FRAGMENT_SHADER);this.gl.attachShader(this.program,this.vshader);this.gl.attachShader(this.program,this.fshader);this.gl.linkProgram(this.program);if(!this.gl.getProgramParameter(this.program,this.gl.LINK_STATUS))throw\"Could not initialise shaders: \"+this.gl.getProgramInfoLog(this.program);} WebGLProgram.prototype.compileShader=function(a,b){var c=this.gl.createShader(b);this.gl.shaderSource(c,a);this.gl.compileShader(c);if(!this.gl.getShaderParameter(c,this.gl.COMPILE_STATUS))throw this.gl.getShaderInfoLog(c);return c}; WebGLProgram.prototype.setup=function(a,b,c){if(this.program){if(void 0==a){a=[];for(var d=this.gl.getProgramParameter(this.program,this.gl.ACTIVE_ATTRIBUTES),e=0;e<d;++e){var f=this.gl.getActiveAttrib(this.program,e);a.push(f.name)}}if(void 0==b)for(b=[],d=this.gl.getProgramParameter(this.program,this.gl.ACTIVE_UNIFORMS),e=0;e<d;++e)f=this.gl.getActiveUniform(this.program,e),b.push(f.name);this.attributes={};for(e in a)this.attributes[a[e]]=this.gl.getAttribLocation(this.program,a[e]),c||this.gl.enableVertexAttribArray(this.attributes[a[e]]); this.uniforms={};for(e in b)this.uniforms[b[e]]=this.gl.getUniformLocation(this.program,b[e]);this.mvMatrixUniform=this.gl.getUniformLocation(this.program,\"uMVMatrix\");this.pMatrixUniform=this.gl.getUniformLocation(this.program,\"uPMatrix\");this.nMatrixUniform=this.gl.getUniformLocation(this.program,\"uNMatrix\")}};function ViewMatrix(){this.matrix=mat4.create();mat4.identity(this.matrix);this.stack=[]}ViewMatrix.prototype.toString=function(){return JSON.stringify(this.toArray())}; ViewMatrix.prototype.toArray=function(){return JSON.parse(mat4.str(this.matrix))};ViewMatrix.prototype.push=function(a){a?(this.stack.push(mat4.create(a)),this.matrix=mat4.create(a)):this.stack.push(mat4.create(this.matrix))};ViewMatrix.prototype.pop=function(){if(0==this.stack.length)throw\"Matrix stack underflow\";return this.matrix=this.stack.pop()};ViewMatrix.prototype.mult=function(a){mat4.multiply(this.matrix,a)};ViewMatrix.prototype.identity=function(){mat4.identity(this.matrix)}; ViewMatrix.prototype.scale=function(a){mat4.scale(this.matrix,a)};ViewMatrix.prototype.translate=function(a){mat4.translate(this.matrix,a)};ViewMatrix.prototype.rotate=function(a,b){mat4.rotate(this.matrix,a*Math.PI/180,b)}; function Palette(a,b){this.premultiply=b;this.background=new Colour(\"rgba(0,0,0,0)\");this.colours=[];this.slider=new Image;this.slider.src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAPCAYAAAA2yOUNAAAAj0lEQVQokWNIjHT8/+zZs//Pnj37/+TJk/9XLp/+f+bEwf9HDm79v2Prqv9aKrz/GUYVEaeoMDMQryJXayWIoi0bFmFV1NWS+z/E1/Q/AwMDA0NVcez/LRsWoSia2luOUAADVcWx/xfO6/1/5fLp/1N7y//HhlmhKoCBgoyA/w3Vyf8jgyyxK4CBUF8zDAUAAJRXY0G1eRgAAAAASUVORK5CYII=\";if(a){var c=!1;if(\"string\"==typeof a)for(var d=a.split(/[\\n;]/),e,f=0;f< d.length;f++){var g=d[f].trim();if(g){var h=g.split(\"=\");if(\"Background\"==h[0])this.background=new Colour(h[1]);else if(\"P\"==h[0][0])e=parseFloat(h[1]);else if(\"C\"==h[0][0]){if(this.colours.push(new ColourPos(h[1],e)),1==e)break}else 2==h.length?this.colours.push(new ColourPos(h[1],h[0])):(c=!0,this.colours.push(new ColourPos(g)))}}else{for(d=0;d<a.length;d++)void 0==a[d].position&&(c=!0),this.colours.push(new ColourPos(a[d].colour,a[d].position));a.background&&(this.background=new Colour(a.background))}if(c)for(d= 0;d<this.colours.length;d++)this.colours[d].position=1/(this.colours.length-1)*d;this.sort();c=!1;for(d=0;d<this.colours.length;d++)0<this.colours[d].colour.alpha&&(c=!0),1<this.colours[d].colour.alpha&&(this.colours[d].colour.alpha=1);if(!c)for(d=0;d<this.colours.length;d++)this.colours[d].colour.alpha=1}else this.colours.push(new ColourPos(\"rgba(255,255,255,1)\",0)),this.colours.push(new ColourPos(\"rgba(0,0,0,1)\",1))} Palette.prototype.sort=function(){this.colours.sort(function(a,b){return a.position-b.position})};Palette.prototype.newColour=function(a,b){var c=new ColourPos(b,a);this.colours.push(c);this.sort();for(c=1;c<this.colours.length-1;c++)if(this.colours[c].position==a)return c;return-1};Palette.prototype.inRange=function(a,b,c){for(var d=0;d<this.colours.length;d++){var e=this.colours[d].position*c;if(a==e||1<b&&a>=e-b/2&&a<=e+b/2)return d}return-1}; Palette.prototype.inDragRange=function(a,b,c){for(var d=1;d<this.colours.length-1;d++){var e=this.colours[d].position*c;if(a==e||1<b&&a>=e-b/2&&a<=e+b/2)return d}return 0};Palette.prototype.remove=function(a){this.colours.splice(a,1)};Palette.prototype.toString=function(){for(var a=\"Background=\"+this.background.html(),b=0;b<this.colours.length;b++)a+=\"\\n\"+this.colours[b].position.toFixed(6)+\"=\"+this.colours[b].colour.html();return a}; Palette.prototype.get=function(){var a={};a.background=this.background.html();a.colours=[];for(var b=0;b<this.colours.length;b++)a.colours.push({position:this.colours[b].position,colour:this.colours[b].colour.html()});return a};Palette.prototype.toJSON=function(){return JSON.stringify(this.get())}; Palette.prototype.draw=function(a,b){if(!this.slider.width&&b){var c=this;setTimeout(function(){c.draw(a,b)},150)}else if(a){var d=/webkit/.test(navigator.userAgent.toLowerCase());0==this.colours.length&&(this.background=new Colour(\"#ffffff\"),this.colours.push(new ColourPos(\"#000000\",0)),this.colours.push(new ColourPos(\"#ffffff\",1)));list=this.colours.slice(0);list.sort(function(a,b){return a.position-b.position});if(a.getContext){var e=a.width,f=a.height,g=a.getContext(\"2d\");g.clearRect(0,0,e,f); if(d)for(var h=0,d=1;d<list.length;d++){var k=Math.round(e*list[d].position);g.fillStyle=g.createLinearGradient(h,0,k,0);var l=list[d-1].colour,m=list[d].colour;this.premultiply&&!b&&(l=this.background.blend(l),m=this.background.blend(m));g.fillStyle.addColorStop(0,l.html());g.fillStyle.addColorStop(1,m.html());g.fillRect(h,0,k-h,f);h=k}else{g.fillStyle=g.createLinearGradient(0,0,e,0);for(d=0;d<list.length;d++)h=list[d].colour,this.premultiply&&!b&&(h=this.background.blend(h)),g.fillStyle.addColorStop(list[d].position, h.html());g.fillRect(0,0,e,f)}if(f=document.getElementById(\"backgroundCUR\"))f.style.background=this.background.html();if(b)for(d=1;d<list.length-1;d++)f=Math.floor(e*list[d].position)+.5,50<list[d].colour.HSV().V?g.strokeStyle=\"black\":g.strokeStyle=\"white\",g.beginPath(),g.moveTo(f,0),g.lineTo(f,a.height),g.closePath(),g.stroke(),f-=this.slider.width/2,g.drawImage(this.slider,f,0)}else alert(\"getContext failed!\")}else alert(\"Invalid canvas!\")}; function ColourPos(a,b){this.position=void 0==b?0:parseFloat(b);if(0<=this.position&&1>=this.position)this.colour=a?\"object\"==typeof a?a:new Colour(a):new Colour(\"#000000\");else throw\"Invalid Colour Position: \"+b;} function Colour(a){\"undefined\"==typeof a?this.set(\"#ffffff\"):\"string\"==typeof a?this.set(a):\"object\"==typeof a?\"undefined\"!=typeof a.H?this.setHSV(a):\"undefined\"!=typeof a.red?(this.red=a.red,this.green=a.green,this.blue=a.blue,this.alpha=a.alpha):a.R?(this.red=a.R,this.green=a.G,this.blue=a.B,this.alpha=\"undefined\"==typeof a.A?1:a.A):(this.red=a[0],this.green=a[1],this.blue=a[2],1>=this.red&&1>=this.green&&1>=this.blue&&(this.red=Math.round(255*this.red),this.green=Math.round(255*this.green),this.blue= Math.round(255*this.blue)),this.alpha=\"undefined\"==typeof a[3]?1:a[3]):this.fromInt(a);1<this.alpha&&(this.alpha/=255)} Colour.prototype.set=function(a){a||(a=\"#ffffff\");var b=/^rgba?\\((\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,?\\s*(\\d\\.?\\d*)?\\)$/.exec(a);b?(this.red=parseInt(b[1]),this.green=parseInt(b[2]),this.blue=parseInt(b[3]),this.alpha=\"undefined\"==typeof b[4]?1:parseFloat(b[4])):\"#\"==a.charAt(0)?(a=a.substring(1,7),this.alpha=1,this.red=parseInt(a.substring(0,2),16),this.green=parseInt(a.substring(2,4),16),this.blue=parseInt(a.substring(4,6),16)):this.fromInt(parseInt(a));1<this.alpha&&(this.alpha/=255)}; Colour.prototype.fromInt=function(a){this.red=a&255;this.green=(a&65280)>>>8;this.blue=(a&16711680)>>>16;this.alpha=((a&4278190080)>>>24)/255};Colour.prototype.toInt=function(){var a=this.red,a=a+(this.green<<8),a=a+(this.blue<<16);return a+=Math.round(255*this.alpha)<<24};Colour.prototype.toString=function(){return this.html()};Colour.prototype.html=function(){return\"rgba(\"+this.red+\",\"+this.green+\",\"+this.blue+\",\"+this.alpha.toFixed(2)+\")\"}; Colour.prototype.rgbaGL=function(){return new Float32Array([this.red/255,this.green/255,this.blue/255,this.alpha])};Colour.prototype.rgbaGLSL=function(){var a=this.rgbaGL();return\"rgba(\"+a[0].toFixed(4)+\",\"+a[1].toFixed(4)+\",\"+a[2].toFixed(4)+\",\"+a[3].toFixed(4)+\")\"};Colour.prototype.rgba=function(){return[this.red/255,this.green/255,this.blue/255,this.alpha]};Colour.prototype.rgbaObj=function(){return{R:this.red,G:this.green,B:this.blue,A:this.alpha}};Colour.prototype.print=function(){OK.debug(this.printString(!0))}; Colour.prototype.printString=function(a){return\"R:\"+this.red+\" G:\"+this.green+\" B:\"+this.blue+(a?\" A:\"+this.alpha:\"\")};Colour.prototype.HEX=function(a){a=Math.round(Math.min(Math.max(0,a),255));return\"0123456789ABCDEF\".charAt((a-a%16)/16)+\"0123456789ABCDEF\".charAt(a%16)};Colour.prototype.htmlHex=function(a){return\"#\"+this.HEX(this.red)+this.HEX(this.green)+this.HEX(this.blue)};Colour.prototype.hex=function(a){return this.HEX(this.red)+this.HEX(this.green)+this.HEX(this.blue)+this.HEX(255*this.alpha)}; Colour.prototype.hexGL=function(a){return this.HEX(255*this.alpha)+this.HEX(this.blue)+this.HEX(this.green)+this.HEX(this.red)}; Colour.prototype.setHSV=function(a){var b,c,d,e,f;f=a.S/100;var g=a.V/100,h=a.H/360;if(0<f){1<=h&&(h=0);h*=6;F=h-Math.floor(h);d=Math.round(255*g*(1-f));e=Math.round(255*g*(1-f*F));f=Math.round(255*g*(1-f*(1-F)));g=Math.round(255*g);switch(Math.floor(h)){case 0:b=g;c=f;e=d;break;case 1:b=e;c=g;e=d;break;case 2:b=d;c=g;e=f;break;case 3:b=d;c=e;e=g;break;case 4:b=f;c=d;e=g;break;case 5:b=g,c=d}this.red=b?b:0;this.green=c?c:0;this.blue=e?e:0}else this.blue=this.green=this.red=g=Math.round(255*g);this.alpha= \"undefined\"==typeof a.A?1:a.A};Colour.prototype.HSV=function(){var a=this.red/255,b=this.green/255,c=this.blue/255,d=Math.max(a,b,c);deltaMax=d-Math.min(a,b,c);var e,f,g,h,k;0==deltaMax?e=f=0:(e=deltaMax/d,g=((d-a)/6+deltaMax/2)/deltaMax,h=((d-b)/6+deltaMax/2)/deltaMax,k=((d-c)/6+deltaMax/2)/deltaMax,a==d?f=k-h:b==d?f=1/3+g-k:c==d&&(f=2/3+h-g),0>f&&(f+=1),1<f&&--f);return{H:360*f,S:100*e,V:100*d}};Colour.prototype.HSVA=function(){var a=this.HSV();a.A=this.alpha;return a}; Colour.prototype.interpolate=function(a,b){this.red=Math.round(this.red+b*(a.red-this.red));this.green=Math.round(this.green+b*(a.green-this.green));this.blue=Math.round(this.blue+b*(a.blue-this.blue));this.alpha=Math.round(this.alpha+b*(a.alpha-this.alpha))};Colour.prototype.blend=function(a){return new Colour([Math.round((1-a.alpha)*this.red+a.alpha*a.red),Math.round((1-a.alpha)*this.green+a.alpha*a.green),Math.round((1-a.alpha)*this.blue+a.alpha*a.blue),(1-a.alpha)*this.alpha+a.alpha*a.alpha])}; function MoveWindow(a){if(a){this.element=document.getElementById(a);if(!this.element)return alert(\"No such element: \"+a),null;this.mouse=new Mouse(this.element,this);this.mouse.moveUpdate=!0;this.element.mouse=this.mouse}} MoveWindow.prototype.open=function(a,b){var c=this.element.style;0>a&&(a=0);0>b&&(b=0);void 0!=a&&(c.left=a+\"px\");void 0!=b&&(c.top=b+\"px\");c.display=\"block\";var d=this.element.offsetWidth,e=this.element.offsetHeight;a+d>window.innerWidth-20&&(c.left=window.innerWidth-d-20+\"px\");b+e>window.innerHeight-20&&(c.top=window.innerHeight-e-20+\"px\")};MoveWindow.prototype.close=function(){this.element.style.display=\"none\"}; MoveWindow.prototype.move=function(a,b){if(b.isdown&&!(0<b.button)){var c=b.element.style;c.left=parseInt(c.left)+b.deltaX+\"px\";c.top=parseInt(c.top)+b.deltaY+\"px\"}};MoveWindow.prototype.down=function(a,b){return!1};function scale(a,b,c,d){return clamp(d*a/b,c,d)}function clamp(a,b,c){return Math.max(b,Math.min(c,a))} function ColourPicker(a,b){function c(a,b,c){var d=document.createElement(\"div\");d.id=a;b&&(d.innerHTML=b);c&&(d.style.cssText=c);return d}var d=document.getElementById(\"picker\");if(d&&d.picker)return d.picker.savefn=a,d.picker.abortfn=b,d.picker;d=document.body;this.element=c(\"picker\",null,\"display:none; top: 58px; z-index: 20; background: #0d0d0d; color: #aaa; cursor: move; font-family: arial; font-size: 11px; padding: 7px 10px 11px 10px; position: fixed; width: 232px; border-radius: 5px; border: 1px solid #444;\"); var e=c(\"pickCURBG\",null,'background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAIElEQVQ4jWP4TwAcOHAAL2YYNWBYGEBIASEwasCwMAAALvidroqDalkAAAAASUVORK5CYII=\"); float: left; width: 12px; height: 12px; margin-right: 3px;');e.appendChild(c(\"pickCUR\",null,\"float: left; width: 12px; height: 12px; background: #fff; margin-right: 3px;\"));this.element.appendChild(e);e=c(\"pickRGB\",\"R: 255 G: 255 B: 255\",\"float: left; position: relative; top: -1px;\");e.onclick=\"colours.picker.updateString()\"; this.element.appendChild(e);this.element.appendChild(c(\"pickCLOSE\",\"X\",\"float: right; cursor: pointer; margin: 0 8px 3px;\"));this.element.appendChild(c(\"pickOK\",\"OK\",\"float: right; cursor: pointer; margin: 0 8px 3px;\"));e=c(\"SV\",null,\"position: relative; cursor: crosshair; float: left; height: 170px; width: 170px; margin-right: 10px; background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAEG0lEQVQ4jQEQBO/7APz8/Pz7+/vx+/v75Pr6+tb6+vrF+Pj4tPf396H4+PiO9/f3e/X19Wfz8/NU8PDwQuvr6zLi4uIjzs7OFZmZmQoA8PDw/O/v7/Ht7e3l7Ozs2Ozs7Mjq6uq35ubmpeXl5ZLf39+A3NzcbtXV1VvMzMxLvr6+O6ioqCyEhIQfQEBAFADk5OT84eHh8uDg4Obe3t7Z3Nzcy9nZ2brV1dWq0NDQmcrKyofCwsJ2uLi4ZKqqqlSYmJhFfX19N1lZWSsnJychANPT0/zT09Pz0NDQ6c3NzdzKysrNx8fHv8DAwK+6urqfsrKyj6mpqX+cnJxvjIyMX3l5eVBeXl5EPz8/ORsbGy8Aw8PD/MHBwfS+vr7qurq63ra2ttKxsbHErKystaOjo6eampqXj4+PiYODg3lycnJrXl5eX0hISFIuLi5IEBAQPwCwsLD9r6+v9aysrOynp6fioqKi1p2dncmVlZW8jo6OroODg6F5eXmUa2trhl1dXXlLS0ttNzc3YiIiIlkNDQ1RAJ6env2bm5v2l5eX7pSUlOWPj4/aiIiIz4GBgcN5eXm3cHBwq2RkZJ5XV1eSSkpKhzk5OX0qKipzGBgYawgICGMAioqK/YeHh/eDg4PvgICA6Hp6et90dHTVbW1ty2VlZcBcXFy1UVFRqkZGRqA6OjqWLS0tjSEhIYQSEhJ9BgYGdwB2dnb+c3Nz+HFxcfJra2vrZmZm42JiYttaWlrRUlJSyUtLS79CQkK2Nzc3rS0tLaQiIiKdGBgYlQ4ODo8EBASKAGNjY/5gYGD5XV1d9FpaWu5VVVXnTk5O4UlJSdlCQkLRPDw8yTQ0NMEqKiq7IiIisxkZGa0RERGmCgoKoQMDA5wAUFBQ/k9PT/pKSkr3R0dH8kNDQ+w+Pj7mOTk54DMzM9otLS3TJycnzSAgIMgZGRnBExMTvA0NDbcHBweyAwMDrwA9PT3+PDw8+zo6Ovg2Njb0MzMz8DAwMOwqKirnJSUl4iEhId4cHBzYFxcX1BISEtAODg7KCQkJxwQEBMQBAQHBAC0tLf4rKyv9Kioq+iYmJvclJSX0ISEh8R4eHu4aGhrqFhYW5xMTE+MQEBDgDQ0N3AgICNkGBgbWBAQE0wAAANEAHh4e/h0dHf0bGxv7Ghoa+hgYGPcWFhb2FBQU8xEREfEPDw/uDAwM7AoKCuoICAjoBgYG5gMDA+MBAQHiAAAA4QARERH+EBAQ/g8PD/0NDQ38DQ0N+wsLC/kKCgr4CAgI9wcHB/YFBQX0BAQE8wICAvIBAQHwAQEB7wAAAO8AAADuAAUFBf4FBQX+BAQE/gQEBP4DAwP+AwMD/QMDA/0CAgL8AQEB/AEBAfsAAAD7AAAA+wAAAPoAAAD6AAAA+QAAAPmq2NbsCl2m4wAAAABJRU5ErkJggg==') no-repeat; background-size: 100%;\"); e.appendChild(c(\"SVslide\",null,\"background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAALUlEQVQYlWNgQAX/kTBW8B8ZYFMIk0ARQFaIoQCbQuopIspNRPsOrpABSzgBAFHzU61KjdKlAAAAAElFTkSuQmCC'); height: 9px; width: 9px; position: absolute; cursor: crosshair\"));this.element.appendChild(e);e=c(\"H\",null,'cursor: crosshair; float: left; height: 170px; position: relative; width: 19px; padding: 0;background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAIElEQVQ4jWP4TwAcOHAAL2YYNWBYGEBIASEwasCwMAAALvidroqDalkAAAAASUVORK5CYII=\");'); e.appendChild(c(\"Hmodel\",null,\"position: relative;\"));e.appendChild(c(\"Hslide\",null,'top: 0px; left: -5px; background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAFCAYAAAC5Fuf5AAAAKklEQVQokWP4////fwY6gv////9n+A8F9LIQxVJaW4xiz4D5lB4WIlsMAPjER7mTpG/OAAAAAElFTkSuQmCC\"); height: 5px; width: 29px; position: absolute; '));this.element.appendChild(e);e=c(\"O\",null,'cursor: crosshair; float: left; height: 170px; position: relative; width: 19px; padding: 0;background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAIElEQVQ4jWP4TwAcOHAAL2YYNWBYGEBIASEwasCwMAAALvidroqDalkAAAAASUVORK5CYII=\");border: 1px solid #888; left: 9px;'); e.appendChild(c(\"Omodel\",null,\"position: relative;\"));e.appendChild(c(\"Oslide\",null,'top: 0px; left: -5px; background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAFCAYAAAC5Fuf5AAAAKklEQVQokWP4////fwY6gv////9n+A8F9LIQxVJaW4xiz4D5lB4WIlsMAPjER7mTpG/OAAAAAElFTkSuQmCC\"); height: 5px; width: 29px; position: absolute; '));this.element.appendChild(e);d.appendChild(this.element);d=document.createElement(\"style\");d.styleSheet?d.styleSheet.cssText=\"#pickRGB:hover {color: #FFD000;} #pickCLOSE:hover {color: #FFD000;} #pickOK:hover {color: #FFD000;}\": d.appendChild(document.createTextNode(\"#pickRGB:hover {color: #FFD000;} #pickCLOSE:hover {color: #FFD000;} #pickOK:hover {color: #FFD000;}\"));document.getElementsByTagName(\"head\")[0].appendChild(d);MoveWindow.call(this,\"picker\");this.savefn=a;this.abortfn=b;this.size=170;this.sv=5;this.oh=2;this.picked={H:360,S:100,V:100,A:1};this.max={H:360,S:100,V:100,A:1};this.colour=new Colour;for(var e=\"\",f,d=0;d<=this.size;d++)f=new Colour({H:Math.round(360/this.size*d),S:100,V:100,A:1}),e+=\"<div class='hue' style='height: 1px; width: 19px; margin: 0; padding: 0; background: \"+ f.htmlHex()+\";'> </div>\";document.getElementById(\"Hmodel\").innerHTML=e;e=\"\";for(d=0;d<=this.size;d++)f=1-d/this.size,e+=\"<div class='opacity' style='height: 1px; width: 19px; margin: 0; padding: 0; background: #000;opacity: \"+f.toFixed(2)+\";'> </div>\";document.getElementById(\"Omodel\").innerHTML=e;this.element.picker=this}ColourPicker.prototype=new MoveWindow;ColourPicker.prototype.constructor=MoveWindow; ColourPicker.prototype.pick=function(a,b,c){this.update(a.HSVA());\"block\"!=this.element.style.display&&MoveWindow.prototype.open.call(this,b,c)};ColourPicker.prototype.select=function(a,b,c){if(!b||!c){var d=a.getBoundingClientRect();b=b?b:d.left+32;c=c?c:d.top+32}d=new Colour(a.style.backgroundColor);this.update(d.HSVA());\"block\"!=this.element.style.display&&(MoveWindow.prototype.open.call(this,b,c),this.target=a)}; ColourPicker.prototype.click=function(a,b){if(\"pickCLOSE\"==b.target.id)this.abortfn&&this.abortfn(),toggle(\"picker\");else if(\"pickOK\"==b.target.id){this.savefn&&this.savefn(this.picked);if(this.target){var c=new Colour(this.picked);this.target.style.backgroundColor=c.html()}toggle(\"picker\")}else\"SV\"==b.target.id?this.setSV(b):\"Hslide\"==b.target.id||\"hue\"==b.target.className?this.setHue(b):\"Oslide\"!=b.target.id&&\"opacity\"!=b.target.className||this.setOpacity(b)}; ColourPicker.prototype.move=function(a,b){b.isdown&&0==b.button&&(\"picker\"==b.target.id||\"pickCUR\"==b.target.id||\"pickRGB\"==b.target.id?MoveWindow.prototype.move.call(this,a,b):b.target&&this.click(a,b))};ColourPicker.prototype.wheel=function(a,b){this.incHue(-a.spin)}; ColourPicker.prototype.setSV=function(a){var b=document.getElementById(\"SV\").getBoundingClientRect(),c=a.absoluteX-parseInt(b.left);a=a.absoluteY-parseInt(b.top);this.picked.S=scale(c,this.size,0,this.max.S);this.picked.V=this.max.V-scale(a,this.size,0,this.max.V);this.update(this.picked)};ColourPicker.prototype.setHue=function(a){var b=document.getElementById(\"H\").getBoundingClientRect();parseInt(b.left);a=a.absoluteY-parseInt(b.top);this.picked.H=scale(a,this.size,0,this.max.H);this.update(this.picked)}; ColourPicker.prototype.incHue=function(a){this.picked.H+=a;this.picked.H=clamp(this.picked.H,0,this.max.H);this.update(this.picked)};ColourPicker.prototype.setOpacity=function(a){var b=document.getElementById(\"O\").getBoundingClientRect();parseInt(b.left);a=a.absoluteY-parseInt(b.top);this.picked.A=1-clamp(a/this.size,0,1);this.update(this.picked)};ColourPicker.prototype.updateString=function(a){a||(a=prompt(\"Edit colour:\",this.colour.html()));a&&(this.colour=new Colour(a),this.update(this.colour.HSV()))}; ColourPicker.prototype.update=function(a){this.picked=a;this.colour=new Colour(a);rgba=this.colour.rgbaObj();rgbaStr=this.colour.html();bgcol=new Colour({H:a.H,S:100,V:100,A:255});document.getElementById(\"pickRGB\").innerHTML=this.colour.printString();document.getElementById(\"pickCUR\").style.background=rgbaStr;document.getElementById(\"pickCUR\").style.backgroundColour=rgbaStr;document.getElementById(\"SV\").style.backgroundColor=bgcol.htmlHex();document.getElementById(\"Hslide\").style.top=a.H/360*this.size- this.oh+\"px\";document.getElementById(\"SVslide\").style.top=Math.round(this.size-a.V/100*this.size-this.sv)+\"px\";document.getElementById(\"SVslide\").style.left=Math.round(a.S/100*this.size-this.sv)+\"px\";document.getElementById(\"Oslide\").style.top=this.size*(1-a.A)-this.oh-1+\"px\"}; function GradientEditor(a,b,c,d,e){this.canvas=a;this.callback=b;this.premultiply=c;this.changed=!0;this.inserting=!1;this.element=this.editing=null;this.spin=0;this.scrollable=e;d||(this.picker=new ColourPicker(this.save.bind(this),this.cancel.bind(this)));this.palette=new Palette(null,c);this.canvas.mouse=new Mouse(this.canvas,this);this.canvas.oncontextmenu=\"return false;\";this.canvas.oncontextmenu=function(){return!1}} GradientEditor.prototype.read=function(a){this.palette=new Palette(a,this.premultiply);this.reset();this.update(!0)};GradientEditor.prototype.update=function(a){this.changed=!0;this.palette.draw(this.canvas,!0);!a&&this.callback&&this.callback(this)};GradientEditor.prototype.get=function(a,b){if(b&&!this.changed)return!1;this.changed=!1;this.palette.draw(a,!1);return!0}; GradientEditor.prototype.insert=function(a,b,c){this.inserting=!0;var d=new Colour;this.editing=this.palette.newColour(a,d);this.update();this.picker=new ColourPicker(this.save.bind(this),this.cancel.bind(this));this.picker.pick(d,b,c)};GradientEditor.prototype.editBackground=function(a){this.editing=-1;this.element=a;this.picker=new ColourPicker(this.save.bind(this),this.cancel.bind(this));a=a.getBoundingClientRect();this.picker.pick(this.palette.background,a.left+32,a.top+32)}; GradientEditor.prototype.edit=function(a,b,c){this.picker=new ColourPicker(this.save.bind(this),this.cancel.bind(this));\"number\"==typeof a?(this.editing=a,this.picker.pick(this.palette.colours[a].colour,b,c)):\"object\"==typeof a&&(this.cancel(),this.element=a,b=new Colour(a.style.backgroundColor),a=a.getBoundingClientRect(),this.picker.pick(b,a.left+32,a.top+32));this.update()}; GradientEditor.prototype.save=function(a){null!=this.editing&&(0<=this.editing?this.palette.colours[this.editing].colour.setHSV(a):this.palette.background.setHSV(a));if(this.element){var b=new Colour(0);b.setHSV(a);this.element.style.backgroundColor=b.html();if(this.element.onchange)this.element.onchange()}this.reset();this.update()};GradientEditor.prototype.cancel=function(){0<=this.editing&&this.inserting&&this.palette.remove(this.editing);this.reset();this.update()}; GradientEditor.prototype.reset=function(){this.inserting=!1;this.element=this.editing=null}; GradientEditor.prototype.click=function(a,b){if(a.ctrlKey){for(var c=0;c<this.palette.colours.length;c++)this.palette.colours[c].position=1-this.palette.colours[c].position;this.update();return!1}if(null!=b.slider)return b.slider=null,this.palette.sort(),this.update(),!1;var d=this.canvas;if(d.getContext){this.cancel();d.getContext(\"2d\");var e=d.getBoundingClientRect().top+30,c=this.palette.inRange(b.x,this.palette.slider.width,d.width);0<=c?0==a.button?this.edit(c,a.clientX-128,e):2==a.button&&(this.palette.remove(c), this.update()):this.insert(b.x/d.width,a.clientX-128,e)}return!1};GradientEditor.prototype.down=function(a,b){return!1};GradientEditor.prototype.move=function(a,b){if(!b.isdown)return!0;if(null==b.slider){var c=this.palette.inDragRange(b.x,this.palette.slider.width,this.canvas.width);0<c&&(b.slider=c)}null==b.slider?b.isdown=!1:(1>b.x&&(b.x=1),b.x>this.canvas.width-1&&(b.x=this.canvas.width-1),this.palette.colours[b.slider].position=b.x/this.canvas.width,this.update(!0))}; GradientEditor.prototype.wheel=function(a,b){this.timer?clearTimeout(this.timer):this.canvas.style.cursor=\"wait\";this.spin+=.01*a.spin;var c=this;this.timer=setTimeout(function(){c.cycle(c.spin);c.spin=0},150)};GradientEditor.prototype.leave=function(a,b){}; GradientEditor.prototype.cycle=function(a){this.canvas.style.cursor=\"default\";this.timer=null;for(var b=1;b<this.palette.colours.length-1;b++){var c=this.palette.colours[b].position,c=c+a;0>=c&&(c+=1);1<=c&&--c;this.palette.colours[b].position=c}this.palette.sort();this.update()}; //Bounding box only in WebGL //Urgent TODO: move shared code with draw.js into common file //maintaining two copies currently! function initBox(el, cmd_callback) { //console.log(\"INITBOX: \" + el.id); var canvas = document.createElement(\"canvas\"); if (!el) el = document.body.firstChild; canvas.id = \"canvas_\" + el.id; canvas.imgtarget = el el.parentElement.appendChild(canvas); canvas.style.cssText = \"position: absolute; width: 100%; height: 100%; margin: 0px; padding: 0px; top: 0; left: 0; bottom: 0; right: 0; z-index: 11; border: none;\" viewer = new BoxViewer(canvas); //Canvas event handling canvas.mouse = new Mouse(canvas, new MouseEventHandler(canvasBoxMouseClick, canvasBoxMouseWheel, canvasBoxMouseMove, canvasBoxMouseDown, null, null, canvasBoxMousePinch)); //Following two settings should probably be defaults? canvas.mouse.moveUpdate = true; //Continual update of deltaX/Y //canvas.mouse.setDefault(); canvas.mouse.wheelTimer = true; //Accumulate wheel scroll (prevents too many events backing up) defaultMouse = document.mouse = canvas.mouse; //Attach viewer object to canvas canvas.viewer = viewer; //Command callback function viewer.command = cmd_callback; return viewer; } function updateBox(viewer, loaderfn) { if (!viewer) return; //Loader callback loaderfn(function(data) {viewer.loadFile(data);}); } function canvasBoxMouseClick(event, mouse) { if (mouse.element.viewer.rotating) mouse.element.viewer.command('' + mouse.element.viewer.getRotationString()); else mouse.element.viewer.command('' + mouse.element.viewer.getTranslationString()); if (mouse.element.viewer.rotating) { mouse.element.viewer.rotating = false; //mouse.element.viewer.reload = true; } //Clear the webgl box mouse.element.viewer.clear(); return false; } function canvasBoxMouseDown(event, mouse) { return false; } var hideBoxTimer; function canvasBoxMouseMove(event, mouse) { if (mouse.element && mouse.element.imgtarget) { var rect = mouse.element.getBoundingClientRect(); x = event.clientX-rect.left; y = event.clientY-rect.top; if (x >= 0 && y >= 0 && x < rect.width && y < rect.height) { mouse.element.imgtarget.nextElementSibling.style.display = \"block\"; if (hideBoxTimer) clearTimeout(hideBoxTimer); hideBoxTimer = setTimeout(function () {mouse.element.imgtarget.nextElementSibling.style.display = \"none\";}, 1000 ); } } if (!mouse.isdown || !mouse.element.viewer) return true; mouse.element.viewer.rotating = false; //Switch buttons for translate/rotate var button = mouse.button; if (mouse.element.viewer.mode == \"Translate\") { //Swap rotate/translate buttons if (button == 0) button = 2 else if (button == 2) button = 0; } else if (button==0 && mouse.element.viewer.mode == \"Zoom\") { button = 100; } //console.log(mouse.deltaX + \",\" + mouse.deltaY); switch (button) { case 0: mouse.element.viewer.rotateY(mouse.deltaX/5); mouse.element.viewer.rotateX(mouse.deltaY/5); mouse.element.viewer.rotating = true; break; case 1: mouse.element.viewer.rotateZ(Math.sqrt(mouse.deltaX*mouse.deltaX + mouse.deltaY*mouse.deltaY)/5); mouse.element.viewer.rotating = true; break; case 2: var adjust = mouse.element.viewer.modelsize / 1000; //1/1000th of size mouse.element.viewer.translate[0] += mouse.deltaX * adjust; mouse.element.viewer.translate[1] -= mouse.deltaY * adjust; break; case 100: var adjust = mouse.element.viewer.modelsize / 1000; //1/1000th of size mouse.element.viewer.translate[2] += mouse.deltaX * adjust; break; } mouse.element.viewer.draw(); return false; } var zoomBoxTimer; var zoomBoxClipTimer; var zoomBoxSpin = 0; function canvasBoxMouseWheel(event, mouse) { if (event.shiftKey) { var factor = event.spin * 0.01; if (zoomBoxClipTimer) clearTimeout(zoomBoxClipTimer); zoomBoxClipTimer = setTimeout(function () {mouse.element.viewer.zoomClip(factor);}, 100 ); } else { if (zoomBoxTimer) clearTimeout(zoomBoxTimer); zoomBoxSpin += event.spin; zoomBoxTimer = setTimeout(function () {mouse.element.viewer.zoom(zoomBoxSpin*0.01); zoomBoxSpin = 0;}, 100 ); //Clear the box after a second setTimeout(function() {mouse.element.viewer.clear();}, 1000); } return false; //Prevent default } function canvasBoxMousePinch(event, mouse) { if (event.distance != 0) { var factor = event.distance * 0.0001; mouse.element.viewer.zoom(factor); //Clear the box after a second setTimeout(function() {mouse.element.viewer.clear();}, 1000); } return false; //Prevent default } //This object encapsulates a vertex buffer and shader set function BoxRenderer(gl, colour) { this.gl = gl; if (colour) this.colour = colour; //Line renderer this.attribSizes = [3 * Float32Array.BYTES_PER_ELEMENT]; this.elements = 0; this.elementSize = 0; for (var i=0; i<this.attribSizes.length; i++) this.elementSize += this.attribSizes[i]; } BoxRenderer.prototype.init = function() { //Compile the shaders this.program = new WebGLProgram(this.gl, \"line-vs\", \"line-fs\"); if (this.program.errors) console.log(this.program.errors); //Setup attribs/uniforms (flag set to skip enabling attribs) this.program.setup(undefined, undefined, true); return true; } BoxRenderer.prototype.updateBuffers = function(view) { //Create buffer if not yet allocated if (this.vertexBuffer == undefined) { //Init shaders etc... if (!this.init()) return; this.vertexBuffer = this.gl.createBuffer(); this.indexBuffer = this.gl.createBuffer(); } //Bind buffers this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer); this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); this.box(view.min, view.max); this.elements = 24; } BoxRenderer.prototype.box = function(min, max) { var vertices = new Float32Array( [ min[0], min[1], max[2], min[0], max[1], max[2], max[0], max[1], max[2], max[0], min[1], max[2], min[0], min[1], min[2], min[0], max[1], min[2], max[0], max[1], min[2], max[0], min[1], min[2] ]); var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 3, 7, 1, 5, 2, 6 ] ); this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW); this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indices, this.gl.STATIC_DRAW); } BoxRenderer.prototype.draw = function(webgl) { if (!this.elements) return; if (this.program.attributes[\"aVertexPosition\"] == undefined) return; //Require vertex buffer webgl.use(this.program); webgl.setMatrices(); //Bind buffers this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer); this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); //Enable attributes for (var key in this.program.attributes) this.gl.enableVertexAttribArray(this.program.attributes[key]); if (this.colour) this.gl.uniform4f(this.program.uniforms[\"uColour\"], this.colour[0], this.colour[1], this.colour[2], this.colour[3]); //Line box render this.gl.vertexAttribPointer(this.program.attributes[\"aVertexPosition\"], 3, this.gl.FLOAT, false, 0, 0); this.gl.drawElements(this.gl.LINES, this.elements, this.gl.UNSIGNED_SHORT, 0); //Disable attribs for (var key in this.program.attributes) this.gl.disableVertexAttribArray(this.program.attributes[key]); this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null); this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null); this.gl.useProgram(null); } //This object holds the viewer details and calls the renderers function BoxViewer(canvas) { this.canvas = canvas; if (!canvas) {alert(\"Invalid Canvas\"); return;} try { this.webgl = new WebGL(this.canvas, {antialias: true}); //, premultipliedAlpha: false}); this.gl = this.webgl.gl; canvas.addEventListener(\"webglcontextlost\", function(event) { event.preventDefault(); console.log(\"CONTEXT LOSS DETECTED\"); }, false); } catch(e) { //No WebGL console.log(\"No WebGL: \" + e); } this.vis = {}; this.view = 0; //Active view this.rotating = false; this.translate = [0,0,0]; this.rotate = quat4.create(); quat4.identity(this.rotate); this.fov = 45; this.focus = [0,0,0]; this.centre = [0,0,0]; this.near_clip = this.far_clip = 0.0; this.modelsize = 1; this.scale = [1, 1, 1]; this.orientation = 1.0; //1.0 for RH, -1.0 for LH if (!this.gl) return; //Create the renderers this.border = new BoxRenderer(this.gl, [0.5,0.5,0.5,1]); this.gl.enable(this.gl.DEPTH_TEST); this.gl.depthFunc(this.gl.LEQUAL); //this.gl.depthMask(this.gl.FALSE); this.gl.enable(this.gl.BLEND); //this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA); //this.gl.blendFuncSeparate(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ZERO, this.gl.ONE); this.gl.blendFuncSeparate(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA); } BoxViewer.prototype.checkPointMinMax = function(coord) { for (var i=0; i<3; i++) { this.vis.views[this.view].min[i] = Math.min(coord[i], this.vis.views[this.view].min[i]); this.vis.views[this.view].max[i] = Math.max(coord[i], this.vis.views[this.view].max[i]); } //console.log(JSON.stringify(this.vis.views[this.view].min) + \" -- \" + JSON.stringify(this.vis.views[this.view].max)); } BoxViewer.prototype.loadFile = function(source) { //Skip update to rotate/translate etc if in process of updating //if (document.mouse.isdown) return; //Replace data this.vis = JSON.parse(source); //Always set a bounding box, get from objects if not in view var objbb = false; if (!this.vis.views[this.view].min || !this.vis.views[this.view].max) { this.vis.views[this.view].min = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE]; this.vis.views[this.view].max = [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE]; objbb = true; } //console.log(JSON.stringify(this.vis.views[this.view],null, 2)); if (this.vis.views[this.view]) { this.fov = this.vis.views[this.view].aperture || 45; this.near_clip = this.vis.views[this.view].near || 0; this.far_clip = this.vis.views[this.view].far || 0; this.orientation = this.vis.views[this.view].orientation || 1; this.axes = this.vis.views[this.view].axis == undefined ? true : this.vis.views[this.view].axis; } if (this.vis.properties.resolution && this.vis.properties.resolution[0] && this.vis.properties.resolution[1]) { this.width = this.vis.properties.resolution[0]; this.height = this.vis.properties.resolution[1]; //this.canvas.style.width = \"\"; //this.canvas.style.height = \"\"; } else { //Autosize when img loaded this.width = 0; this.height = 0; } //Process object data for (var id in this.vis.objects) { //Apply object bounding box if (objbb && this.vis.objects[id].min) this.checkPointMinMax(this.vis.objects[id].min); if (objbb && this.vis.objects[id].max) this.checkPointMinMax(this.vis.objects[id].max); } this.updateDims(this.vis.views[this.view]); //Update display if (!this.gl) return; this.draw(); this.clear(); } BoxViewer.prototype.clear = function() { if (!this.gl) return; this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT); } BoxViewer.prototype.draw = function() { if (!this.canvas) return; //Get the dimensions from the current canvas if (this.width != this.canvas.offsetWidth || this.height != this.canvas.offsetHeight) { this.width = this.canvas.offsetWidth; this.height = this.canvas.offsetHeight; //Need to set this too for some reason this.canvas.width = this.width; this.canvas.height = this.height; if (this.gl) { this.gl.viewportWidth = this.width; this.gl.viewportHeight = this.height; this.webgl.viewport = new Viewport(0, 0, this.width, this.height); } } if (!this.gl) return; this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight); //this.gl.clearColor(1, 1, 1, 0); this.gl.clearColor(0, 0, 0, 0); this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT); this.webgl.view(this); //Render objects this.border.draw(this.webgl); } BoxViewer.prototype.rotateX = function(deg) { this.rotation(deg, [1,0,0]); } BoxViewer.prototype.rotateY = function(deg) { this.rotation(deg, [0,1,0]); } BoxViewer.prototype.rotateZ = function(deg) { this.rotation(deg, [0,0,1]); } BoxViewer.prototype.rotation = function(deg, axis) { //Quaterion rotate var arad = deg * Math.PI / 180.0; var rotation = quat4.fromAngleAxis(arad, axis); rotation = quat4.normalize(rotation); this.rotate = quat4.multiply(rotation, this.rotate); } BoxViewer.prototype.getRotation = function() { return [this.rotate[0], this.rotate[1], this.rotate[2], this.rotate[3]]; } BoxViewer.prototype.getRotationString = function() { //Return current rotation quaternion as string var q = this.getRotation(); return 'rotation ' + q[0] + ' ' + q[1] + ' ' + q[2] + ' ' + q[3]; } BoxViewer.prototype.getTranslationString = function() { return 'translation ' + this.translate[0] + ' ' + this.translate[1] + ' ' + this.translate[2]; } BoxViewer.prototype.reset = function() { if (this.gl) { this.updateDims(this.vis.views[this.view]); this.draw(); } this.command('reset'); } BoxViewer.prototype.zoom = function(factor) { if (this.gl) { this.translate[2] += factor * this.modelsize; this.draw(); } this.command('' + this.getTranslationString()); //this.command('zoom ' + factor); } BoxViewer.prototype.zoomClip = function(factor) { if (this.gl) { var near_clip = this.near_clip + factor * this.modelsize; if (near_clip >= this.modelsize * 0.001) this.near_clip = near_clip; this.draw(); } this.command('zoomclip ' + factor); } BoxViewer.prototype.updateDims = function(view) { if (!view) return; var oldsize = this.modelsize; this.dims = [view.max[0] - view.min[0], view.max[1] - view.min[1], view.max[2] - view.min[2]]; this.modelsize = Math.sqrt(this.dims[0]*this.dims[0] + this.dims[1]*this.dims[1] + this.dims[2]*this.dims[2]); this.focus = [view.min[0] + 0.5*this.dims[0], view.min[1] + 0.5*this.dims[1], view.min[2] + 0.5*this.dims[2]]; this.centre = [this.focus[0],this.focus[1],this.focus[2]]; this.translate = [0,0,0]; if (this.modelsize != oldsize) this.translate[2] = -this.modelsize*1.25; if (this.near_clip == 0.0) this.near_clip = this.modelsize / 10.0; if (this.far_clip == 0.0) this.far_clip = this.modelsize * 10.0; quat4.identity(this.rotate); if (view) { //Initial rotation if (view.rotate) { if (view.rotate.length == 3) { this.rotateZ(-view.rotate[2]); this.rotateY(-view.rotate[1]); this.rotateX(-view.rotate[0]); } else if (view.rotate.length == 4) { this.rotate = quat4.create(view.rotate); } } //Translate if (view.translate) { this.translate[0] = view.translate[0]; this.translate[1] = view.translate[1]; this.translate[2] = view.translate[2]; } //Scale if (view.scale) { this.scale[0] = view.scale[0]; this.scale[1] = view.scale[1]; this.scale[2] = view.scale[2]; } //Focal point if (view.focus) { this.focus[0] = this.centre[0] = view.focus[0]; this.focus[1] = this.centre[1] = view.focus[1]; this.focus[2] = this.centre[2] = view.focus[2]; } } //console.log(\"DIMS: \" + min[0] + \" to \" + max[0] + \",\" + min[1] + \" to \" + max[1] + \",\" + min[2] + \" to \" + max[2]); //console.log(\"New model size: \" + this.modelsize + \", Focal point: \" + this.focus[0] + \",\" + this.focus[1] + \",\" + this.focus[2]); //console.log(\"Translate: \" + this.translate[0] + \",\" + this.translate[1] + \",\" + this.translate[2]); if (!this.gl) return; //Create the bounding box vertex buffer this.border.updateBuffers(this.vis.views[this.view]); } //IPython kernel object var kernel; if (parent.IPython) { kernel = parent.IPython.notebook.kernel; } //Maintain a list of interactor instances opened by id //(check in case this script imported twice, don't overwrite previous) var _wi = window._wi ? window._wi : []; var delay = 0; var debug_mode = false; function exec_kernel(cmd) { //For debugging: //Run a python command in kernel and log output to console if (kernel) { if (debug_mode) { //Debug callback var callbacks = {'output' : function(out) { if (!out.content.data) {console.log(JSON.stringify(out)); return;} data = out.content.data['text/plain'] console.log(\"CMD: \" + cmd + \", RESULT: \" + data); } }; } kernel.execute(cmd, {iopub: callbacks}, {silent: false}); } } function getUrl() { var loc = window.location; var baseUrl = loc.protocol + \"//\" + loc.hostname + (loc.port ? \":\" + loc.port : \"\"); return baseUrl; } function WindowInteractor(id) { //Store self in list and save id this.id = id; console.log(\"New interactor: \" + this.id); //Interactor class, handles javascript side of window control //Takes viewer id // - set as active target for commands // - init webgl bounding box // - display initial image this.img = document.getElementById(\"imgtarget_\" + this.id); //No window if (!this.img) return; //Initial image //(Init WebGL bounding box interaction on load) var that = this; this.get_image(function() { //console.log('In image loaded callback ' + that.id); //Init on image load with callback function to execute commands that.box = initBox(that.img, function(cmd) {that.execute(cmd);}); //console.log(\"Box init on \" + that.id); //Update the box size by getting state updateBox(that.box, function(onget) {that.get_state(onget);}); //Clear onload that.img.onload = null; }); } //Load frame image and run command in single action (non-IPython mode only) var instant = true; WindowInteractor.prototype.execute = function(cmd, callback) { //console.log(\"execute: \" + cmd); if (kernel) { exec_kernel('lavavu.control.windows[' + this.id + '].commands(\"' + cmd + '\")'); //kernel.execute('lavavu.control.windows[' + this.id + '].commands(\"' + cmd + '\")'); this.get_image(callback); } else { //HTTP interface //Replace newlines with semi-colon first cmd = cmd.replace(/\\n/g,';'); if (instant && this.img) { var url = getUrl() + \"/icommand=\" + cmd + \"?\" + new Date().getTime(); this.img.onload = null; if (callback) this.img.onload = callback; this.img.src = url; } else { var url = getUrl() + \"/command=\" + cmd + \"?\" + new Date().getTime() x = new XMLHttpRequest(); x.open('GET', url, true); x.send(); this.get_image(callback); } } //Reload state if (this.img) { var that = this; updateBox(this.box, function(onget) {that.get_state(onget);}); } return false; } WindowInteractor.prototype.set_prop = function(obj, prop, val) { this.execute(\"select \" + obj + \"; \" + prop + \"=\" + val); this.get_image(); } WindowInteractor.prototype.do_action = function(id, val) { if (kernel) { //Non-numeric, add quotes and strip newlines if (typeof(val) == 'string' && (\"\" + parseFloat(val) !== val)) { val = val.replace(/\\n/g,';'); val = '\"' + val + '\"'; } //kernel.execute('cmds = lavavu.control.action(' + id + ',' + val + ')'); var cmd = 'cmds = lavavu.control.Action.do(' + id + ',' + val + ')'; exec_kernel(cmd); cmd = 'if cmds: lavavu.control.windows[' + this.id + '].commands(cmds)'; exec_kernel(cmd); this.get_image(); } else { //HTML control actions via http actions[id](val); } //Reload state if (this.img) { var that = this; updateBox(this.box, function(onget) {that.get_state(onget);}); } } WindowInteractor.prototype.redisplay = function() { //console.log(\"redisplay: \" + this.id); if (this.img) { //Call get_image this.get_image(); //Update the box size by getting state var that = this; updateBox(that.box, function(onget) {that.get_state(onget);}); } } WindowInteractor.prototype.get_image = function(onload) { if (!this.img) return; //console.log(\"get_img: \" + this.id); if (kernel) { var that = this; var callbacks = {'output' : function(out) { //Skip first message we get without data //if (!out.content.data) {console.log(JSON.stringify(out)); return;} if (!out.content.data) return; data = out.content.data['text/plain'] data = data.substring(1, data.length-1) //console.log(\"Got image: \" + data.length); if (that.img) { //Only set onload if provided if (onload) // && !that.img.onload) that.img.onload = onload; that.img.src = data; } } }; kernel.execute('lavavu.control.windows[' + this.id + '].frame()', {iopub: callbacks}, {silent: false}); } else { //if (!this.img) this.img = document.getElementById('imgtarget_0'); var url = getUrl() + \"/image?\" + new Date().getTime(); if (this.img) { this.img.onload = onload; this.img.src = url; } } } WindowInteractor.prototype.get_state = function(onget) { //console.log(\"get_state: \" + this.id); if (kernel) { var callbacks = {'output' : function(out) { //if (!out.content.data) {console.log(JSON.stringify(out)); return;} if (!out.content.data) return; data = out.content.data['text/plain'] data = data.replace(/(?:\\\\n)+/g, \"\"); data = data.substring(1, data.length-1) onget(data); } }; kernel.execute('lavavu.control.windows[' + this.id + '].app.getState()', {iopub: callbacks}, {silent: false}); } else { var url = getUrl() + \"/getstate\" x = new XMLHttpRequest(); x.onload = function() { if(x.status == 200) onget(x.response); else console.log(\"Ajax Request Error: \" + url + \", returned status code \" + x.status + \" \" + x.statusText); } x.open('GET', url, true); x.send(); } } //Update controls from JSON data function updateControlValues(controls) { for (var c in controls) { var control = controls[c]; var els = document.getElementsByClassName(control[0]); for(var i = 0; i < els.length; i++) { //console.log(els[i].id + \" : \" + els[i].value + \" ==> \" + control[1]); if (els[i].type == 'checkbox') els[i].checked = control[1]; else els[i].value = control[1]; }; } } function getAndUpdateControlValues(names) { //Get the updated values if (kernel) { var callbacks = {'output' : function(out) { if (!out.content.data) {console.log(JSON.stringify(out)); return;} data = out.content.data['text/plain'] data = data.substring(1, data.length-1) data = data.replace(/(?:\\\\n)+/g, \"\"); data = data.replace(/'/g, '\"'); //console.log(data); updateControlValues(JSON.parse(data)); } }; kernel.execute('import json; json.dumps(lavavu.control.getcontrolvalues(\"' + names + '\"))', {iopub: callbacks}, {silent: false}); } else { //TODO: http version, need to request updated values from web server } } Rotate Translate Zoom We can retrieve a list of objects from a viewer by inspecting the \"objects\" property. References to these objects can be used to modify the object appearance, either directly or using controls. \u0002wzxhzdk:24\u0003 ['ScalarField_0', 'VectorArrows_1'] Interactive controls can be created to adjust visualisation parameters, here we control the opacity of the previously retrieved \"surf\" object and the global vector scaling parameter, changes will be reflected in the viewer window above: \u0002wzxhzdk:25\u0003 Opacity: Scale Arrows:","title":"Interactivity &amp; Scripting"},{"location":"UserGuide/08_StokesSolver.html","text":"Stokes Solver We want to solve the following Stokes block system. \\[ \\begin{bmatrix} K & G \\ G^T & C \\end{bmatrix} \\begin{bmatrix} u\\ p \\end{bmatrix} = \\begin{bmatrix} f\\ h \\end{bmatrix}. \\] If we apply Gaussian elimination to the above as a 2x2 block matrix system we can write this as: \\[ \\begin{bmatrix} K & G\\ 0 & S \\end{bmatrix} \\begin{bmatrix} u\\ p \\end{bmatrix} = \\begin{bmatrix} f\\ \\hat{h} \\end{bmatrix}, \\] where S=G^{T}K^{-1}G-C S=G^{T}K^{-1}G-C is the Schur complement and \\hat{h}=G^{T}K^{-1}f -h \\hat{h}=G^{T}K^{-1}f -h . This system is now solved first for the pressure using the Schur complement matrix, S S . Then a backsolve for the velocity gives the complete solution. Note that wherever K^{-1} K^{-1} appears, the inverse is never explicitly calculated but is achieved via a PETSc solve method. While solving for the pressure, there are necessarily solves using K K inside of the matrix S S . We often refer to these as 'inner' solves. Basic usage of the Stokes solver class involves being able to easily set up the inner solves in a few different ways (Setting up the pressure solve is more advanced). To illustrate some basic usage let's set up a simple problem to solve. import underworld as uw import math from underworld import function as fn res=128 mesh = uw.mesh.FeMesh_Cartesian(\"Q1/DQ0\", (res,res), (0.,0.), (1.,1.)) velocityField = mesh.add_variable(2) velocityField.data[:] = (0.,0.) pressureField = mesh.subMesh.add_variable(1) pressureField.data[:] = 0. # Freeslip bc's IWalls = mesh.specialSets[\"MinI_VertexSet\"] + mesh.specialSets[\"MaxI_VertexSet\"] JWalls = mesh.specialSets[\"MinJ_VertexSet\"] + mesh.specialSets[\"MaxJ_VertexSet\"] freeslip = uw.conditions.DirichletCondition(velocityField, (IWalls, JWalls)) # We are going to make use of one of the existing analytic solutions so that we may easily # obtain functions for a viscosity profile and forcing terms. # Exact solution solCx with defaults sol = fn.analytic.SolCx() stokesSystem = uw.systems.Stokes(velocityField,pressureField,sol.fn_viscosity,sol.fn_bodyforce,conditions=freeslip) Now we create a solver. The Solver class will automatically return a Stokes solver given a Stokes system. solver=uw.systems.Solver(stokesSystem) The Stokes solver will use multigrid as a preconditioner along with PETSc's 'fgmres' Krylov method by default for the 'inner' solve. Let's run the solver now. solver.solve() Now let's set up the inner solve to do a direct solve (this will not work in parallel). solver.set_inner_method(\"lu\") solver.solve() Let's run underworld's help function on the solver.configure function. help(solver.set_inner_method) Help on method set_inner_method in module underworld.systems._bsscr: set_inner_method(self, solve_type='mg') method of underworld.systems._bsscr.StokesSolver instance Configure velocity/inner solver (A11 PETSc prefix). solve_type can be one of: mg : Geometric multigrid (default). mumps : MUMPS parallel direct solver. superludist : SuperLU parallel direct solver. superlu : SuperLU direct solver (serial only). lu : LU direct solver (serial only). We can see all the of the options that are configured in the solver using the list() functions for each component of the solver. These are the most useful ones. solver.options.main.list() # System level options print( \"---\" ) solver.options.scr.list() # Specifics for the schur complement solve print( \"---\" ) solver.options.A11.list() # Specifics for the inner (velocity) solve print( \"---\" ) solver.options.mg.list() # Options relevant to multigrid (if chosen) ('remove_constant_pressure_null_space', False) ('ksp_k2_type', 'NULL') ('change_backsolve', False) ('penalty', 0.0) ('pc_type', 'none') ('force_correction', True) ('k_scale_only', True) ('Q22_pc_type', 'uw') ('change_A11rhspresolve', False) ('ksp_type', 'bsscr') ('rescale_equations', False) ('restore_K', True) --- ('ksp_type', 'fgmres') ('ksp_rtol', 1e-05) --- ('pc_type', 'lu') ('_mg_active', False) ('ksp_type', 'preonly') --- ('active', False) ('levels', 8) To learn more about the possible options, you can first take a look at uw.help(solver.options.A11) # for example The options are cryptic because they follow the conventions established by PETSc which we use for the linear algebra and we allow you to pass any valid option through to that system. To understand this better, you will have to look at the Petsc documentation . To begin with, the examples in this notebook should be ok to get going. help(solver.options.A11) Help on Options in module underworld.systems._options object: class Options(__builtin__.object) | Set PETSc options on this to pass along to PETSc KSPs | | ksp_type = <fgmres> : Krylov method | ksp_rtol = <1e-05> : Relative decrease in residual norm | pc_type = <sor> : Preconditioner type | ksp_view = 'ascii' : Print the ksp data structure at the end of the system solution | ksp_converged_reason = 'ascii' : Print reason for converged or diverged solve | ksp_monitor = <stdout> : Monitor preconditioned residual norm | | for further options see PETSc manual or set help on \"options.main\" | | Methods defined here: | | __init__(self) | | help(self) | | list(self) | List options. | | reset(self) | Reset values to initial defaults. | | set_lu(self) | Set up options for LU serial solve. | | set_mumps(self, pc_type='lu') | Set up options for MUMPS parallel solve. | pc_type = \"lu\" or \"cholesky\" | | Use ./configure --download-mumps --download-scalapack --download-parmetis --download-metis --download-ptscotch | to have PETSc installed with MUMPS | | set_superlu(self) | Set up options for SuperLU serial solve. | Use ./configure --download-superlu to have PETSc installed with SuperLU | | set_superludist(self) | Set up options for SuperLU parallel solve. | Use ./configure --download-superlu_dist --download-parmetis --download-metis --download-ptscotch | to have PETSc installed with SuperLU_DIST | | ---------------------------------------------------------------------- | Data descriptors defined here: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) A useful trick is to be able to imitate the classic \"penalty method\" which can be very efficient with modest-sized (2D) problems. In the penalty method, we add a term to the weak form of the Stokes equation which penalises \\lambda | \\nabla \\cdot \\mathbf{u}| > 0 \\lambda | \\nabla \\cdot \\mathbf{u}| > 0 and where \\lambda \\lambda is a sufficiently large constant to enforce the constraint. Typically 10^7 10^7 is considered sufficient. The problem with this method is that the condition number of the system is severely compromised by adding the penalty term and standard iterative methods do not work well. Our solvers have been configured with the penalty term and, for sufficiently robust choices of the inner solver, this can help solve problems faster (by improving pressure convergence). An indestructible solver like lu or mumps (Mumps is a direct solve that will work in parallel) can use very large penalties. Hence we can recreate the penalty method as follows (though it still follows the pattern of the Schur complement solver, while the classical method takes some shortcuts). solver.set_inner_method(\"mumps\") solver.options.scr.ksp_type=\"cg\" solver.set_penalty(1.0e7) solver.solve() solver.print_stats() \u001b[1;35m Pressure iterations: 0 Velocity iterations: 0 (presolve) Velocity iterations: 0 (pressure solve) Velocity iterations: 0 (backsolve) Velocity iterations: 0 (total solve) SCR RHS solve time: 9.3489e-03 Pressure solve time: 3.6509e-03 Velocity solve time: 7.2331e-03 (backsolve) Total solve time : 9.9900e-02 Velocity solution min/max: 0.0000e+00/0.0000e+00 Pressure solution min/max: 0.0000e+00/0.0000e+00 \u001b[00m Now let's go back to using multigrid. We can use a penalty here too, but the gigantic numbers won't work. solver.set_inner_method(\"mg\") solver.set_penalty(1.0) solver.solve() solver.print_stats() \u001b[1;35m Pressure iterations: 6 Velocity iterations: 6 (presolve) Velocity iterations: 30 (pressure solve) Velocity iterations: 5 (backsolve) Velocity iterations: 41 (total solve) SCR RHS solve time: 7.7661e-02 Pressure solve time: 1.7966e-01 Velocity solve time: 6.2589e-02 (backsolve) Total solve time : 4.1504e-01 Velocity solution min/max: 0.0000e+00/0.0000e+00 Pressure solution min/max: 0.0000e+00/0.0000e+00 \u001b[00m Let's run help on the solver itself. The whole thing is reasonably well documented and help works for all the subcomponents. help(solver) Help on StokesSolver in module underworld.systems._bsscr object: class StokesSolver(underworld._stgermain.StgCompoundComponent) | The Block Stokes Schur Complement Solver: | This solves the saddle-point system | | .. math:: | \\begin{bmatrix} K & G \\\\ G^T & C \\end{bmatrix} \\begin{bmatrix} u \\\\ p \\end{bmatrix} = \\begin{bmatrix}f \\\\ h \\end{bmatrix} | | via a Schur complement method. | | We first solve: | | .. math:: | S p= G^T K^{-1} f - h, | :label: a | | where :math:`S = G^T K^{-1} G-C` | | Then we backsolve for the velocity: | | .. math:: | K u = f - G p. | :label: b | | The effect of :math:`K^{-1}` in :eq:`a` is obtained via a KSPSolve in PETSc. | This has the prefix 'A11' (often called the 'inner' solve) | | The solve in :eq:`a` for the pressure has prefix 'scr'. | | Assuming the returned solver is called 'solver', it is possible to configure | these solves individually via the `solver.options.A11` and | `solver.options.scr` dictionaries. | | Try uw.help(solver.options.A11) for some details. | | Common configurations are provided via the | solver.set_inner_method() function. | | solver.set_inner_method(\"mg\") sets up a multigrid solve for the inner solve. This is the default. | solver.set_inner_method(\"mumps\") will set up a parallel direct solve on the inner solve. | solver.set_inner_method(\"lu\") will set up a serial direct solve on the inner solve. | | uw.help(solver.set_inner_method) for more. | | For more advanced configurations use the | solver.options.A11/scr dictionaries directly. | | uw.help(solver.options) to see more. | | Method resolution order: | StokesSolver | underworld._stgermain.StgCompoundComponent | underworld._stgermain.StgClass | underworld._stgermain.LeftOverParamsChecker | __builtin__.object | | Methods defined here: | | __init__(self, stokesSLE, **kwargs) | | get_nonLinearStats(self) | | get_stats(self) | | print_stats(self) | | set_inner_method(self, solve_type='mg') | Configure velocity/inner solver (A11 PETSc prefix). | | solve_type can be one of: | | mg : Geometric multigrid (default). | mumps : MUMPS parallel direct solver. | superludist : SuperLU parallel direct solver. | superlu : SuperLU direct solver (serial only). | lu : LU direct solver (serial only). | | set_inner_rtol(self, rtol) | | set_mg_levels(self, levels) | Set the number of multigrid levels manually. | It is set automatically by default. | | set_outer_rtol(self, rtol) | | set_penalty(self, penalty) | By setting the penalty, the Augmented Lagrangian Method is used as the solve. | This method is not recommended for normal use as there is additional memory and cpu overhead. | This method can often help improve convergence issues for problems with large viscosity | contrasts that are having trouble converging. | | A penalty of roughly 0.1 of the maximum viscosity contrast is not a bad place to start as a guess. (check notes/paper) | | solve(self, nonLinearIterate=None, nonLinearTolerance=0.01, nonLinearKillNonConvergent=False, nonLinearMaxIterations=500, callback_post_solve=None, print_stats=False, reinitialise=True, fpwarning=True, petscwarning=True, **kwargs) | Solve the stokes system | | Parameters | ---------- | nonLinearIterate: bool | True will perform non linear iterations iterations, False (or 0) will not | | nonLinearTolerance: float, Default=1.0e-2 | Relative tolerance criterion for the change in the velocity field | | nonLinearMaxIterations: int, Default=500 | Maximum number of non linear iteration to perform | | callback_post_sovle: func, Default=None | Optional callback function to be performed at the end of a linear solve iteration. | Commonly this will be used to perform operations between non linear iterations, for example, | calibrating the pressure solution or removing the system null space. | | print_stats: bool, Default=False | Print out solver iteration and timing counts per solver | | reinitialise: bool, Default=True, | Rebuild the system discretisation storage (location matrix/petsc mats & vecs) and repopulate, if available, | the stokes voronio swarm before the system is solved. | | ---------------------------------------------------------------------- | Data and other attributes defined here: | | __abstractmethods__ = frozenset([]) | | ---------------------------------------------------------------------- | Static methods inherited from underworld._stgermain.StgCompoundComponent: | | __new__(cls, *args, **kwargs) | Creates stgermain instances of underlying objects. | | The list of required instances is provided as a dictionary ('_objectsDict') on the class, | with the entry key being the object name, and entry value being the object type. | | A second class data member ('_selfObjectName') provides the object name | which should be considered the object 'self'. | | For example: | class Drawing(_stgermain.StgCompoundComponent): | _selfObjectName = \"_dr\" # child should set this | _objectsDict = { \"_cm\": \"lucColourMap\", | \"_dr\": None } | | Note that this example is for an abstract class ('Drawing'), so it does not define | a type for '_dr', but instead defers to child classes to define the type of '_dr'. | | Args: | objectsDictOverrule (dict): If provided, this will overwrite any objects | in the class level _objectDicts. Useful for | programatically modifying behaviour. | | | Returns: | New created instance of child class. | | ---------------------------------------------------------------------- | Data and other attributes inherited from underworld._stgermain.StgCompoundComponent: | | __metaclass__ = <class 'underworld._stgermain._SetupClass'> | This metaclass allows us to invoke a _setup method after the __init__ method. | Borrowed from: | http://stackoverflow.com/questions/22261763/in-python-is-it-possible-to-write-a-method-that-will-be-automatically-called-aft | | ---------------------------------------------------------------------- | Methods inherited from underworld._stgermain.StgClass: | | __del__(self) | | ---------------------------------------------------------------------- | Data descriptors inherited from underworld._stgermain.LeftOverParamsChecker: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined)","title":"StokesSolver"},{"location":"UserGuide/08_StokesSolver.html#stokes-solver","text":"We want to solve the following Stokes block system. \\[ \\begin{bmatrix} K & G \\ G^T & C \\end{bmatrix} \\begin{bmatrix} u\\ p \\end{bmatrix} = \\begin{bmatrix} f\\ h \\end{bmatrix}. \\] If we apply Gaussian elimination to the above as a 2x2 block matrix system we can write this as: \\[ \\begin{bmatrix} K & G\\ 0 & S \\end{bmatrix} \\begin{bmatrix} u\\ p \\end{bmatrix} = \\begin{bmatrix} f\\ \\hat{h} \\end{bmatrix}, \\] where S=G^{T}K^{-1}G-C S=G^{T}K^{-1}G-C is the Schur complement and \\hat{h}=G^{T}K^{-1}f -h \\hat{h}=G^{T}K^{-1}f -h . This system is now solved first for the pressure using the Schur complement matrix, S S . Then a backsolve for the velocity gives the complete solution. Note that wherever K^{-1} K^{-1} appears, the inverse is never explicitly calculated but is achieved via a PETSc solve method. While solving for the pressure, there are necessarily solves using K K inside of the matrix S S . We often refer to these as 'inner' solves. Basic usage of the Stokes solver class involves being able to easily set up the inner solves in a few different ways (Setting up the pressure solve is more advanced). To illustrate some basic usage let's set up a simple problem to solve. import underworld as uw import math from underworld import function as fn res=128 mesh = uw.mesh.FeMesh_Cartesian(\"Q1/DQ0\", (res,res), (0.,0.), (1.,1.)) velocityField = mesh.add_variable(2) velocityField.data[:] = (0.,0.) pressureField = mesh.subMesh.add_variable(1) pressureField.data[:] = 0. # Freeslip bc's IWalls = mesh.specialSets[\"MinI_VertexSet\"] + mesh.specialSets[\"MaxI_VertexSet\"] JWalls = mesh.specialSets[\"MinJ_VertexSet\"] + mesh.specialSets[\"MaxJ_VertexSet\"] freeslip = uw.conditions.DirichletCondition(velocityField, (IWalls, JWalls)) # We are going to make use of one of the existing analytic solutions so that we may easily # obtain functions for a viscosity profile and forcing terms. # Exact solution solCx with defaults sol = fn.analytic.SolCx() stokesSystem = uw.systems.Stokes(velocityField,pressureField,sol.fn_viscosity,sol.fn_bodyforce,conditions=freeslip) Now we create a solver. The Solver class will automatically return a Stokes solver given a Stokes system. solver=uw.systems.Solver(stokesSystem) The Stokes solver will use multigrid as a preconditioner along with PETSc's 'fgmres' Krylov method by default for the 'inner' solve. Let's run the solver now. solver.solve() Now let's set up the inner solve to do a direct solve (this will not work in parallel). solver.set_inner_method(\"lu\") solver.solve() Let's run underworld's help function on the solver.configure function. help(solver.set_inner_method) Help on method set_inner_method in module underworld.systems._bsscr: set_inner_method(self, solve_type='mg') method of underworld.systems._bsscr.StokesSolver instance Configure velocity/inner solver (A11 PETSc prefix). solve_type can be one of: mg : Geometric multigrid (default). mumps : MUMPS parallel direct solver. superludist : SuperLU parallel direct solver. superlu : SuperLU direct solver (serial only). lu : LU direct solver (serial only). We can see all the of the options that are configured in the solver using the list() functions for each component of the solver. These are the most useful ones. solver.options.main.list() # System level options print( \"---\" ) solver.options.scr.list() # Specifics for the schur complement solve print( \"---\" ) solver.options.A11.list() # Specifics for the inner (velocity) solve print( \"---\" ) solver.options.mg.list() # Options relevant to multigrid (if chosen) ('remove_constant_pressure_null_space', False) ('ksp_k2_type', 'NULL') ('change_backsolve', False) ('penalty', 0.0) ('pc_type', 'none') ('force_correction', True) ('k_scale_only', True) ('Q22_pc_type', 'uw') ('change_A11rhspresolve', False) ('ksp_type', 'bsscr') ('rescale_equations', False) ('restore_K', True) --- ('ksp_type', 'fgmres') ('ksp_rtol', 1e-05) --- ('pc_type', 'lu') ('_mg_active', False) ('ksp_type', 'preonly') --- ('active', False) ('levels', 8) To learn more about the possible options, you can first take a look at uw.help(solver.options.A11) # for example The options are cryptic because they follow the conventions established by PETSc which we use for the linear algebra and we allow you to pass any valid option through to that system. To understand this better, you will have to look at the Petsc documentation . To begin with, the examples in this notebook should be ok to get going. help(solver.options.A11) Help on Options in module underworld.systems._options object: class Options(__builtin__.object) | Set PETSc options on this to pass along to PETSc KSPs | | ksp_type = <fgmres> : Krylov method | ksp_rtol = <1e-05> : Relative decrease in residual norm | pc_type = <sor> : Preconditioner type | ksp_view = 'ascii' : Print the ksp data structure at the end of the system solution | ksp_converged_reason = 'ascii' : Print reason for converged or diverged solve | ksp_monitor = <stdout> : Monitor preconditioned residual norm | | for further options see PETSc manual or set help on \"options.main\" | | Methods defined here: | | __init__(self) | | help(self) | | list(self) | List options. | | reset(self) | Reset values to initial defaults. | | set_lu(self) | Set up options for LU serial solve. | | set_mumps(self, pc_type='lu') | Set up options for MUMPS parallel solve. | pc_type = \"lu\" or \"cholesky\" | | Use ./configure --download-mumps --download-scalapack --download-parmetis --download-metis --download-ptscotch | to have PETSc installed with MUMPS | | set_superlu(self) | Set up options for SuperLU serial solve. | Use ./configure --download-superlu to have PETSc installed with SuperLU | | set_superludist(self) | Set up options for SuperLU parallel solve. | Use ./configure --download-superlu_dist --download-parmetis --download-metis --download-ptscotch | to have PETSc installed with SuperLU_DIST | | ---------------------------------------------------------------------- | Data descriptors defined here: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined) A useful trick is to be able to imitate the classic \"penalty method\" which can be very efficient with modest-sized (2D) problems. In the penalty method, we add a term to the weak form of the Stokes equation which penalises \\lambda | \\nabla \\cdot \\mathbf{u}| > 0 \\lambda | \\nabla \\cdot \\mathbf{u}| > 0 and where \\lambda \\lambda is a sufficiently large constant to enforce the constraint. Typically 10^7 10^7 is considered sufficient. The problem with this method is that the condition number of the system is severely compromised by adding the penalty term and standard iterative methods do not work well. Our solvers have been configured with the penalty term and, for sufficiently robust choices of the inner solver, this can help solve problems faster (by improving pressure convergence). An indestructible solver like lu or mumps (Mumps is a direct solve that will work in parallel) can use very large penalties. Hence we can recreate the penalty method as follows (though it still follows the pattern of the Schur complement solver, while the classical method takes some shortcuts). solver.set_inner_method(\"mumps\") solver.options.scr.ksp_type=\"cg\" solver.set_penalty(1.0e7) solver.solve() solver.print_stats() \u001b[1;35m Pressure iterations: 0 Velocity iterations: 0 (presolve) Velocity iterations: 0 (pressure solve) Velocity iterations: 0 (backsolve) Velocity iterations: 0 (total solve) SCR RHS solve time: 9.3489e-03 Pressure solve time: 3.6509e-03 Velocity solve time: 7.2331e-03 (backsolve) Total solve time : 9.9900e-02 Velocity solution min/max: 0.0000e+00/0.0000e+00 Pressure solution min/max: 0.0000e+00/0.0000e+00 \u001b[00m Now let's go back to using multigrid. We can use a penalty here too, but the gigantic numbers won't work. solver.set_inner_method(\"mg\") solver.set_penalty(1.0) solver.solve() solver.print_stats() \u001b[1;35m Pressure iterations: 6 Velocity iterations: 6 (presolve) Velocity iterations: 30 (pressure solve) Velocity iterations: 5 (backsolve) Velocity iterations: 41 (total solve) SCR RHS solve time: 7.7661e-02 Pressure solve time: 1.7966e-01 Velocity solve time: 6.2589e-02 (backsolve) Total solve time : 4.1504e-01 Velocity solution min/max: 0.0000e+00/0.0000e+00 Pressure solution min/max: 0.0000e+00/0.0000e+00 \u001b[00m Let's run help on the solver itself. The whole thing is reasonably well documented and help works for all the subcomponents. help(solver) Help on StokesSolver in module underworld.systems._bsscr object: class StokesSolver(underworld._stgermain.StgCompoundComponent) | The Block Stokes Schur Complement Solver: | This solves the saddle-point system | | .. math:: | \\begin{bmatrix} K & G \\\\ G^T & C \\end{bmatrix} \\begin{bmatrix} u \\\\ p \\end{bmatrix} = \\begin{bmatrix}f \\\\ h \\end{bmatrix} | | via a Schur complement method. | | We first solve: | | .. math:: | S p= G^T K^{-1} f - h, | :label: a | | where :math:`S = G^T K^{-1} G-C` | | Then we backsolve for the velocity: | | .. math:: | K u = f - G p. | :label: b | | The effect of :math:`K^{-1}` in :eq:`a` is obtained via a KSPSolve in PETSc. | This has the prefix 'A11' (often called the 'inner' solve) | | The solve in :eq:`a` for the pressure has prefix 'scr'. | | Assuming the returned solver is called 'solver', it is possible to configure | these solves individually via the `solver.options.A11` and | `solver.options.scr` dictionaries. | | Try uw.help(solver.options.A11) for some details. | | Common configurations are provided via the | solver.set_inner_method() function. | | solver.set_inner_method(\"mg\") sets up a multigrid solve for the inner solve. This is the default. | solver.set_inner_method(\"mumps\") will set up a parallel direct solve on the inner solve. | solver.set_inner_method(\"lu\") will set up a serial direct solve on the inner solve. | | uw.help(solver.set_inner_method) for more. | | For more advanced configurations use the | solver.options.A11/scr dictionaries directly. | | uw.help(solver.options) to see more. | | Method resolution order: | StokesSolver | underworld._stgermain.StgCompoundComponent | underworld._stgermain.StgClass | underworld._stgermain.LeftOverParamsChecker | __builtin__.object | | Methods defined here: | | __init__(self, stokesSLE, **kwargs) | | get_nonLinearStats(self) | | get_stats(self) | | print_stats(self) | | set_inner_method(self, solve_type='mg') | Configure velocity/inner solver (A11 PETSc prefix). | | solve_type can be one of: | | mg : Geometric multigrid (default). | mumps : MUMPS parallel direct solver. | superludist : SuperLU parallel direct solver. | superlu : SuperLU direct solver (serial only). | lu : LU direct solver (serial only). | | set_inner_rtol(self, rtol) | | set_mg_levels(self, levels) | Set the number of multigrid levels manually. | It is set automatically by default. | | set_outer_rtol(self, rtol) | | set_penalty(self, penalty) | By setting the penalty, the Augmented Lagrangian Method is used as the solve. | This method is not recommended for normal use as there is additional memory and cpu overhead. | This method can often help improve convergence issues for problems with large viscosity | contrasts that are having trouble converging. | | A penalty of roughly 0.1 of the maximum viscosity contrast is not a bad place to start as a guess. (check notes/paper) | | solve(self, nonLinearIterate=None, nonLinearTolerance=0.01, nonLinearKillNonConvergent=False, nonLinearMaxIterations=500, callback_post_solve=None, print_stats=False, reinitialise=True, fpwarning=True, petscwarning=True, **kwargs) | Solve the stokes system | | Parameters | ---------- | nonLinearIterate: bool | True will perform non linear iterations iterations, False (or 0) will not | | nonLinearTolerance: float, Default=1.0e-2 | Relative tolerance criterion for the change in the velocity field | | nonLinearMaxIterations: int, Default=500 | Maximum number of non linear iteration to perform | | callback_post_sovle: func, Default=None | Optional callback function to be performed at the end of a linear solve iteration. | Commonly this will be used to perform operations between non linear iterations, for example, | calibrating the pressure solution or removing the system null space. | | print_stats: bool, Default=False | Print out solver iteration and timing counts per solver | | reinitialise: bool, Default=True, | Rebuild the system discretisation storage (location matrix/petsc mats & vecs) and repopulate, if available, | the stokes voronio swarm before the system is solved. | | ---------------------------------------------------------------------- | Data and other attributes defined here: | | __abstractmethods__ = frozenset([]) | | ---------------------------------------------------------------------- | Static methods inherited from underworld._stgermain.StgCompoundComponent: | | __new__(cls, *args, **kwargs) | Creates stgermain instances of underlying objects. | | The list of required instances is provided as a dictionary ('_objectsDict') on the class, | with the entry key being the object name, and entry value being the object type. | | A second class data member ('_selfObjectName') provides the object name | which should be considered the object 'self'. | | For example: | class Drawing(_stgermain.StgCompoundComponent): | _selfObjectName = \"_dr\" # child should set this | _objectsDict = { \"_cm\": \"lucColourMap\", | \"_dr\": None } | | Note that this example is for an abstract class ('Drawing'), so it does not define | a type for '_dr', but instead defers to child classes to define the type of '_dr'. | | Args: | objectsDictOverrule (dict): If provided, this will overwrite any objects | in the class level _objectDicts. Useful for | programatically modifying behaviour. | | | Returns: | New created instance of child class. | | ---------------------------------------------------------------------- | Data and other attributes inherited from underworld._stgermain.StgCompoundComponent: | | __metaclass__ = <class 'underworld._stgermain._SetupClass'> | This metaclass allows us to invoke a _setup method after the __init__ method. | Borrowed from: | http://stackoverflow.com/questions/22261763/in-python-is-it-possible-to-write-a-method-that-will-be-automatically-called-aft | | ---------------------------------------------------------------------- | Methods inherited from underworld._stgermain.StgClass: | | __del__(self) | | ---------------------------------------------------------------------- | Data descriptors inherited from underworld._stgermain.LeftOverParamsChecker: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined)","title":"Stokes Solver"}]}